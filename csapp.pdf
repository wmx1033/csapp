%PDF-1.4
1 0 obj
<< /Type /Catalog /Pages 2 0 R >>
endobj
2 0 obj
<< /Type /Pages /Kids [3 0 R 4 0 R 5 0 R 6 0 R 7 0 R 8 0 R 9 0 R 10 0 R 11 0 R 12 0 R 13 0 R 14 0 R 15 0 R 16 0 R 17 0 R 18 0 R 19 0 R 20 0 R 21 0 R 22 0 R 23 0 R 24 0 R 25 0 R 26 0 R 27 0 R 28 0 R 29 0 R 30 0 R 31 0 R 32 0 R 33 0 R 34 0 R 35 0 R 36 0 R 37 0 R 38 0 R 39 0 R 40 0 R 41 0 R 42 0 R 43 0 R 44 0 R 45 0 R 46 0 R 47 0 R 48 0 R 49 0 R 50 0 R 51 0 R 52 0 R 53 0 R 54 0 R 55 0 R 56 0 R 57 0 R 58 0 R 59 0 R 60 0 R 61 0 R 62 0 R 63 0 R 64 0 R 65 0 R 66 0 R 67 0 R 68 0 R 69 0 R 70 0 R 71 0 R 72 0 R 73 0 R 74 0 R 75 0 R 76 0 R 77 0 R 78 0 R 79 0 R 80 0 R 81 0 R 82 0 R 83 0 R 84 0 R 85 0 R 86 0 R 87 0 R 88 0 R 89 0 R 90 0 R 91 0 R 92 0 R 93 0 R 94 0 R 95 0 R 96 0 R 97 0 R 98 0 R 99 0 R 100 0 R 101 0 R 102 0 R 103 0 R 104 0 R 105 0 R 106 0 R 107 0 R 108 0 R 109 0 R 110 0 R 111 0 R 112 0 R 113 0 R 114 0 R 115 0 R 116 0 R 117 0 R 118 0 R 119 0 R 120 0 R 121 0 R 122 0 R 123 0 R 124 0 R 125 0 R 126 0 R 127 0 R 128 0 R 129 0 R 130 0 R 131 0 R 132 0 R 133 0 R 134 0 R 135 0 R 136 0 R 137 0 R 138 0 R 139 0 R 140 0 R 141 0 R 142 0 R 143 0 R 144 0 R 145 0 R 146 0 R 147 0 R 148 0 R 149 0 R 150 0 R 151 0 R 152 0 R 153 0 R 154 0 R 155 0 R 156 0 R 157 0 R 158 0 R 159 0 R 160 0 R 161 0 R 162 0 R 163 0 R 164 0 R 165 0 R 166 0 R 167 0 R 168 0 R 169 0 R 170 0 R 171 0 R 172 0 R 173 0 R 174 0 R 175 0 R 176 0 R 177 0 R 178 0 R 179 0 R 180 0 R 181 0 R 182 0 R 183 0 R 184 0 R 185 0 R 186 0 R 187 0 R 188 0 R 189 0 R 190 0 R 191 0 R 192 0 R 193 0 R 194 0 R 195 0 R 196 0 R 197 0 R 198 0 R 199 0 R 200 0 R 201 0 R 202 0 R 203 0 R 204 0 R 205 0 R 206 0 R 207 0 R 208 0 R 209 0 R 210 0 R 211 0 R 212 0 R 213 0 R 214 0 R 215 0 R 216 0 R 217 0 R 218 0 R 219 0 R 220 0 R 221 0 R 222 0 R 223 0 R 224 0 R 225 0 R 226 0 R 227 0 R 228 0 R 229 0 R 230 0 R 231 0 R 232 0 R 233 0 R 234 0 R 235 0 R 236 0 R 237 0 R 238 0 R 239 0 R 240 0 R 241 0 R 242 0 R 243 0 R 244 0 R 245 0 R 246 0 R 247 0 R 248 0 R 249 0 R 250 0 R 251 0 R 252 0 R 253 0 R 254 0 R 255 0 R 256 0 R 257 0 R 258 0 R 259 0 R 260 0 R 261 0 R 262 0 R 263 0 R 264 0 R 265 0 R 266 0 R 267 0 R 268 0 R 269 0 R 270 0 R 271 0 R 272 0 R 273 0 R 274 0 R 275 0 R 276 0 R 277 0 R 278 0 R 279 0 R 280 0 R 281 0 R 282 0 R 283 0 R 284 0 R 285 0 R 286 0 R 287 0 R 288 0 R 289 0 R 290 0 R 291 0 R 292 0 R 293 0 R 294 0 R 295 0 R 296 0 R 297 0 R 298 0 R 299 0 R 300 0 R 301 0 R 302 0 R 303 0 R 304 0 R 305 0 R 306 0 R 307 0 R 308 0 R 309 0 R 310 0 R 311 0 R 312 0 R 313 0 R 314 0 R 315 0 R 316 0 R 317 0 R 318 0 R 319 0 R 320 0 R 321 0 R 322 0 R 323 0 R 324 0 R 325 0 R 326 0 R 327 0 R 328 0 R 329 0 R 330 0 R 331 0 R 332 0 R 333 0 R 334 0 R 335 0 R 336 0 R 337 0 R 338 0 R 339 0 R] /Count 337 >>
endobj
3 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 340 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
4 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 341 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
5 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 342 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
6 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 343 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
7 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 344 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
8 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 345 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
9 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 346 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
10 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 347 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
11 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 348 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
12 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 349 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
13 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 350 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
14 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 351 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
15 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 352 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
16 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 353 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
17 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 354 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
18 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 355 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
19 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 356 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
20 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 357 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
21 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 358 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
22 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 359 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
23 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 360 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
24 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 361 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
25 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 362 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
26 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 363 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
27 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 364 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
28 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 365 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
29 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 366 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
30 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 367 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
31 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 368 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
32 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 369 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
33 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 370 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
34 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 371 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
35 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 372 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
36 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 373 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
37 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 374 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
38 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 375 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
39 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 376 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
40 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 377 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
41 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 378 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
42 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 379 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
43 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 380 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
44 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 381 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
45 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 382 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
46 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 383 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
47 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 384 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
48 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 385 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
49 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 386 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
50 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 387 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
51 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 388 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
52 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 389 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
53 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 390 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
54 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 391 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
55 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 392 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
56 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 393 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
57 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 394 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
58 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 395 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
59 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 396 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
60 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 397 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
61 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 398 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
62 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 399 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
63 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 400 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
64 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 401 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
65 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 402 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
66 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 403 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
67 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 404 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
68 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 405 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
69 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 406 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
70 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 407 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
71 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 408 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
72 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 409 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
73 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 410 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
74 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 411 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
75 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 412 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
76 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 413 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
77 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 414 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
78 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 415 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
79 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 416 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
80 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 417 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
81 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 418 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
82 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 419 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
83 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 420 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
84 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 421 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
85 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 422 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
86 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 423 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
87 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 424 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
88 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 425 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
89 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 426 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
90 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 427 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
91 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 428 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
92 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 429 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
93 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 430 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
94 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 431 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
95 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 432 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
96 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 433 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
97 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 434 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
98 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 435 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
99 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 436 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
100 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 437 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
101 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 438 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
102 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 439 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
103 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 440 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
104 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 441 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
105 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 442 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
106 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 443 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
107 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 444 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
108 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 445 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
109 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 446 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
110 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 447 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
111 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 448 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
112 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 449 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
113 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 450 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
114 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 451 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
115 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 452 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
116 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 453 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
117 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 454 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
118 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 455 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
119 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 456 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
120 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 457 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
121 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 458 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
122 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 459 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
123 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 460 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
124 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 461 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
125 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 462 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
126 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 463 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
127 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 464 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
128 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 465 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
129 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 466 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
130 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 467 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
131 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 468 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
132 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 469 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
133 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 470 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
134 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 471 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
135 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 472 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
136 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 473 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
137 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 474 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
138 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 475 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
139 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 476 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
140 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 477 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
141 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 478 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
142 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 479 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
143 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 480 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
144 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 481 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
145 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 482 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
146 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 483 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
147 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 484 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
148 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 485 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
149 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 486 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
150 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 487 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
151 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 488 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
152 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 489 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
153 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 490 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
154 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 491 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
155 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 492 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
156 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 493 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
157 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 494 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
158 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 495 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
159 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 496 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
160 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 497 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
161 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 498 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
162 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 499 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
163 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 500 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
164 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 501 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
165 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 502 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
166 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 503 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
167 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 504 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
168 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 505 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
169 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 506 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
170 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 507 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
171 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 508 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
172 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 509 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
173 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 510 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
174 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 511 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
175 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 512 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
176 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 513 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
177 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 514 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
178 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 515 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
179 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 516 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
180 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 517 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
181 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 518 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
182 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 519 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
183 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 520 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
184 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 521 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
185 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 522 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
186 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 523 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
187 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 524 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
188 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 525 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
189 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 526 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
190 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 527 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
191 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 528 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
192 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 529 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
193 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 530 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
194 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 531 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
195 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 532 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
196 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 533 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
197 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 534 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
198 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 535 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
199 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 536 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
200 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 537 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
201 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 538 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
202 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 539 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
203 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 540 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
204 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 541 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
205 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 542 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
206 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 543 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
207 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 544 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
208 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 545 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
209 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 546 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
210 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 547 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
211 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 548 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
212 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 549 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
213 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 550 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
214 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 551 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
215 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 552 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
216 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 553 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
217 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 554 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
218 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 555 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
219 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 556 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
220 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 557 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
221 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 558 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
222 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 559 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
223 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 560 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
224 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 561 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
225 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 562 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
226 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 563 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
227 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 564 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
228 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 565 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
229 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 566 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
230 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 567 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
231 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 568 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
232 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 569 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
233 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 570 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
234 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 571 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
235 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 572 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
236 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 573 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
237 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 574 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
238 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 575 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
239 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 576 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
240 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 577 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
241 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 578 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
242 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 579 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
243 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 580 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
244 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 581 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
245 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 582 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
246 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 583 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
247 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 584 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
248 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 585 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
249 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 586 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
250 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 587 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
251 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 588 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
252 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 589 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
253 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 590 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
254 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 591 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
255 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 592 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
256 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 593 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
257 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 594 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
258 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 595 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
259 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 596 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
260 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 597 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
261 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 598 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
262 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 599 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
263 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 600 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
264 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 601 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
265 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 602 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
266 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 603 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
267 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 604 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
268 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 605 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
269 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 606 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
270 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 607 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
271 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 608 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
272 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 609 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
273 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 610 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
274 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 611 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
275 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 612 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
276 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 613 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
277 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 614 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
278 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 615 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
279 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 616 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
280 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 617 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
281 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 618 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
282 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 619 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
283 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 620 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
284 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 621 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
285 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 622 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
286 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 623 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
287 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 624 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
288 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 625 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
289 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 626 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
290 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 627 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
291 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 628 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
292 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 629 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
293 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 630 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
294 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 631 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
295 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 632 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
296 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 633 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
297 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 634 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
298 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 635 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
299 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 636 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
300 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 637 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
301 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 638 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
302 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 639 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
303 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 640 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
304 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 641 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
305 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 642 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
306 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 643 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
307 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 644 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
308 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 645 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
309 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 646 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
310 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 647 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
311 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 648 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
312 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 649 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
313 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 650 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
314 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 651 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
315 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 652 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
316 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 653 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
317 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 654 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
318 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 655 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
319 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 656 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
320 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 657 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
321 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 658 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
322 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 659 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
323 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 660 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
324 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 661 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
325 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 662 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
326 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 663 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
327 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 664 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
328 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 665 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
329 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 666 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
330 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 667 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
331 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 668 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
332 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 669 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
333 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 670 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
334 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 671 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
335 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 672 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
336 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 673 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
337 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 674 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
338 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 675 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
339 0 obj
<< /Type /Page /Parent 2 0 R /MediaBox [0 0 612 792] /Contents 676 0 R /Resources << /Font << /F1 677 0 R >> >> >>
endobj
340 0 obj
<< /Length 2167 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(================================================================================) Tj
T*
(本电子书信息) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(本电子书信息) Tj
T*
() Tj
T*
() Tj
T*
( 个人整理的《深入理解计算机系统》中文电子版（原书第 3 版）与实验材料：https://hansimov.gitbook.io/csapp/) Tj
T*
( \(https://hansimov.gitbook.io/csapp/\)) Tj
T*
() Tj
T*
(制作者：Hansimov \(https://github.com/Hansimov\)\\\\\\\\) Tj
T*
() Tj
T*
(OCR 支持：WPS PDF) Tj
T*
() Tj
T*
(感谢：九卿 \(https://github.com/taseikyo\)) Tj
T*
() Tj
T*
(GitHub：https://github.com/Hansimov/csapp \(https://github.com/Hansimov/csapp\)) Tj
T*
() Tj
T*
(已施工部分：序、前言、第 1、7、8、9、10、11、12 章，全部实验简介，实验 1、2 文档) Tj
T*
() Tj
T*
(待施工部分：第 2、3、4、5、6 章，实验 3、4、5、6、7、8、9 文档) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
([Image: &#x6DF1;&#x5165;&#x7406;&#x89E3;&#x8BA1;&#x7B97;&#x673A;&#x7CFB;&#x7EDF; -) Tj
T*
(Computer Systems: A Programmer&apos;s Perspective]) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(出版者的话) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(出版者的话) Tj
T*
() Tj
T*
() Tj
T*
(文艺复兴以来，源远流长的科学精神和逐步形成的学术规范，使西方国家在自然科学的各个领域取得了垄断性的优势；也正是这样的优势，使美国在信息技术发展的六十多年间名家辈出、独领风骚。在商业) Tj
T*
(化的进程中，美国的产业界与教育界越来越紧密地结合，计算机学科中的许多泰山北斗同时身处科研和教学的最前线，由此而产生的经典科学著作，不仅擘划了研究的范畴，还揭示了学术的源变，既遵循学) Tj
T*
(术规范，又自有学者个性，其价值并不会因年月的流逝而减退。) Tj
T*
ET
endstream
endobj
341 0 obj
<< /Length 4084 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(近年，在全球信息化大潮的推动下，我国的计算机产业发展迅猛，对专业人才的需求日益迫切。这对计算机教育界和出版界都既是机遇，也是挑战；而专业教材的建设在教育战略上显得举足轻重。在我国信) Tj
T*
(息技术发展时间较短的现状下，美国等发达国家在其计算机科学发展的几) Tj
T*
(十年间积淀和发展的经典教材仍有许多值得借鉴之处。因此，引进一批国外优秀计算机教材将对我国计算机教育事业的发展起到积极的推动作用，也是与世界接轨、建设真正的世界一流大学的必由之路。) Tj
T*
() Tj
T*
(机械工业出版社华章公司较早意识到“出版要为教育服务”。自 1998 年开始，我们就将工作重点放在了遴选、移译国外优秀教材上。经过多年的不懈努力，我们与) Tj
T*
(Pearson，McGraw-Hill，Elsevier，MIT，John Wiley & Sons，Cengage) Tj
T*
(等世界著名出版公司建立了良好的合作关系，从他们现有的数百种教材中甄选出 Andrew S. Tanenbaum，Bjarne Stroustrup，Brian W.) Tj
T*
(Kernighan，Dennis Ritchie，Jim Gray，Afred V. Aho，John E . Hopcroft，Jefrey D. Ullman，Abraham) Tj
T*
(Silberschatz，Wilam Sallings，Donald E. Knuth，John L. Hennessy，Larry L.) Tj
T*
(Peterson等大师名家的一批经典作品，以“计算机科学丛书”为总称出版，供读者学习、研究及珍藏。大理石纹理的封面，也正体现了这套丛书的品位和格调。) Tj
T*
() Tj
T*
(“计算机科学丛书”的出版工作得到了国内外学者的鼎力相助，国内的专家不仅提供了中肯的选题指导，还不辞劳苦地担任了翻译和审校的工作；而原书的作者也相当关注其作品在中国的传播，有的还专门) Tj
T*
(为其书的中译本作序。迄今，“计算机科学丛书”已经出版了近两百个品种，这些书籍在读者中树立了良好的口碑，并被许多高校采用为正式教材和参考书籍。其影印版“经典原版书库”作为姊妹篇也被越) Tj
T*
(来越多实施双语教学的学校所采用。) Tj
T*
() Tj
T*
(权威的作者、经典的教材、一流的译者、严格的审校、精细的编辑，这些因素使我们的图书有了质量的保证。随着计算机科学与技术专业学科建设的不断完善和教材改革的逐渐深化，教育界对国外计算机教) Tj
T*
(材的需求和应用都将步人一个新的阶段，我们的目标是尽善尽美，而反馈的意见正是我们达到这一终极目标的重要帮助。华章公司欢迎老师和读者对我们的工作提出建议或给予指正，我们的联系方法如下∶) Tj
T*
() Tj
T*
(华章网站：www.hzbook.com) Tj
T*
() Tj
T*
(电子邮件：hzjsj@hzbook.com) Tj
T*
() Tj
T*
(联系电话：\\\(010\\\) 88379604) Tj
T*
() Tj
T*
(联系地址：北京市西城区百万庄南街 1 号) Tj
T*
() Tj
T*
(邮政编码：10037) Tj
T*
() Tj
T*
(华章科技图书出版中心) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(中文版序一) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(中文版序一) Tj
T*
() Tj
T*
() Tj
T*
(梅宏，中国科学院院士、发展中国家科学院院士) Tj
T*
() Tj
T*
(华章公司温莉芳女士邀我为即将出版的《Computer Systems∶A Programmer's Perspective》第 3) Tj
T*
(版的中文译本《深入理解计算机系统》写个序，出于两方面的考虑，欣然允之。) Tj
T*
() Tj
T*
(一是源于我个人的背景和兴趣。我长期从事软件工程和系统软件领域的研究，对计算机学科的认识可概括为两大方面：计算系统的构建和基于计算系统的计算技术应用。出于信息时代国家掌握关键核心技术) Tj
T*
(的重大需求以及我个人专业的本位视角，我一直对系统级技术的研发给予更多关注，由于这种) Tj
T*
ET
endstream
endobj
342 0 obj
<< /Length 6915 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(“偏爱”和研究习惯的养成，以至于自己在面对非本专业领域问题时，也常常喜欢从“系统观”来看待问题和解决问题。我自己也和《深入理解计算机系统》有过“亲密接触”。2012 年，我还在北京) Tj
T*
(大学信息科学技术学院院长任上，学院从更好地培养适应新技术、发展具有系统设计和系统应用能力的计算机专门人才出发，在调查若干国外高校计算机学科本科生教学体系基础上，决定加强计算机系统能) Tj
T*
(力培养，在本科生二年级增设了一门系统级课程，即) Tj
T*
("计算机系统导论"。其时，学校正在倡导小班课教学模式，这门课也被选为学院的第一个小班课教学试点。为了体现学院的重视，我亲自担任了这门课的主持人，带领一个 18 人组成的 "豪华") Tj
T*
(教学团队负责该课程的教学工作，将学生分成 14 个小班，每个小班不超过 15) Tj
T*
(人。同时，该课程涉及教师集体备课组合授课、大班授课基础上的小班课教学和讨论、定期教学会议、学生自主习题课和实验课等新教学模式的探索，其中一项非常重要的举措就是选用了卡内基 -) Tj
T*
(梅隆大学 Randal E. Bryant 教授和 David R. O'Hallaron 教授编写的《Computer Systems∶A Programmer's) Tj
T*
(Perspective》（第 2 版）作为教材，虽然这门课程我只主持了一次，但对这本教材的印象颇深颇佳。) Tj
T*
() Tj
T*
(二是源于我和华章公司已有的良好合作和相互了解。2000 年前后，我先后翻译了华章公司引进（机械工业出版社出版）的 Roger Pressman 编写的《Software) Tj
T*
(Engineering：A Practitioner's Approach》一书的第 4 版和第 5 版。其后，在计算机学会软件工程专业委员会和系统软件专业委员会的诸多学术活动中也) Tj
T*
(和华章公司及温莉芳女士本人有不少合作。近二十年来，华章公司的编辑们引进出版了大量计算机学科的优秀教材和学术著作，对国内高校计算机学科的教学改革起到了积极的促进作用，本书的翻译出版仍) Tj
T*
(是这项工作的延续。这是一项值得褒扬的工作，我也想借此机会代表计算机界同仁表达对华章公司的感谢！) Tj
T*
() Tj
T*
(计算机系统类别的课程一直是计算机科学与技术专业的主要教学内容之一。由于历史原因，我国的计算机专业的课程体系曾广泛参考 ACM 和 IEEE) Tj
T*
(制订的计算机科学与技术专业教学计划（Computing Curricula）设计，计算机系统类课程也参照该计划分为汇编语言、操作系统、组成原理、体系结构、计算机网络等多门课程。应该) Tj
T*
(说，该课程体系在历史上对我国的计算机专业教育起了很好的引导作用。) Tj
T*
() Tj
T*
(进入新世纪以来，计算技术发生了重要的发展和变化，我国的信息技术和产业也得到了迅猛发展，对计算机专业的毕业生提出了更高要求。重新审视原来我们参照 ACM/IEEE) Tj
T*
(计算机专业计划的课程体系，会发现存在以下几个方面的主要问题。) Tj
T*
() Tj
T*
(1）课程体系中缺乏一门独立的能够贯穿整个计算机系统的基础课程。计算机系统方面的基础知识被分成了很多门独立的课程，课程内容彼此之间缺乏关联和系统性。学生学习之后，虽然在计算机系统的各) Tj
T*
(个部分理解了很多概念和方法，但往往会忽视各个部分之间的关联，难以系统性地理解整个计算机系统的工作原理和方法。) Tj
T*
() Tj
T*
(2）现有课程往往偏重理论，和实践关联较少。如现有的系统课程中通常会介绍函数调用过程中的压栈和退栈方式，但较少和实践关联来理解压栈和退栈过程的主要作用。实际上，压栈和退栈与理解 C) Tj
T*
(等高级语言的工作原理息息相关，也是常用的攻击手段 Bufer Overflow 的主要技术基础。) Tj
T*
() Tj
T*
(3）教学内容比较传统和陈旧，基本上是早期 PC 时代的内容。比如，现在的主流台式机 CPU 都已经是 x86-64 指令集，但较多课程还在教授 80386) Tj
T*
(甚至更早的指令集。对于近年来出现的多核/众核处理器、SSD 硬盘等实际应用中遇到的内容更是涉及较少。) Tj
T*
() Tj
T*
(4）课程大多数从设计者的角度出发，而不是从使用者的角度出发。对于大多数学生来说，毕业之后并不会成为专业的 CPU) Tj
T*
(设计人员、操作系统开发人员等，而是会成为软件开发工程师。对他们而言，最重要的是理解主流计算机系统的整体设计以及这些设计因素对于应用软件开发和运行的影响。) Tj
T*
() Tj
T*
(这本教材很好地克服了上述传统课程的不足，这也是当初北大计算机学科本科生教学改革时选择该教材的主要考量。其一，该教材系统地介绍了整个计算机系统的工作原理，可帮助学生系统性地理解计算机) Tj
T*
(如何执行程序、存储信息和通信；其二，该教材非常强调实践，全书包括 9 个配套的实验，在这些实验中，学生需要攻破计算机系统、设计) Tj
T*
(CPU、实现命令行解释器、根据缓存优化程序等，在新鲜有趣的实验中理解系统原理，培养动手能力；其三，该教材紧跟时代的发展，加入了 x86-64 指令集、Intel Core i7) Tj
T*
(的虚拟地址结构、SSD 磁盘、IPv6) Tj
T*
(等新技术内容；其四，该教材从程序员的角度看待计算机系统，重点讨论系统的不同结构对于上层应用软件编写、执行和数据存储的影响，以培养程序员在更广阔空间应用计算机系统知识的能力。) Tj
T*
() Tj
T*
(基于该教材的北大“计算机系统导论”课程实施已有五年，得到了学生的广泛赞誉，学生们通过这门课程的学习建立了完整的计算机系统的知识体系和整体知识框架，养成了良好的编程习惯并获得了编写高) Tj
T*
(性能、可移植和健壮的程序的能力，莫定了后续学习操作系统、编译、计算机体系结构等专业课程的基础。北大的教学实践表明，这是一本值得推荐采用的好教材。) Tj
T*
() Tj
T*
(该书的第 3 版相对于第 2 版进行了较大程度的修改和扩充。第 3 版从一开始就采用最新 x86-64 架构来贯穿各部分知识，在内存技术、网络技术上也有一系列更新，并且重组了之前的) Tj
T*
(一些比较难懂的内容。我相信，该书的出版，将有助于国内计算机系统教学的进一步改进，为培养从事系统级创新的计算机人才奠定很好的基础。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
ET
endstream
endobj
343 0 obj
<< /Length 6426 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(2016 年 10 月 8 日) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(中文版序二) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(中文版序二) Tj
T*
() Tj
T*
() Tj
T*
(臧斌宇，上海交通大学软件学院院长) Tj
T*
() Tj
T*
(2002 年 8 月本书第 1 版首次印刷。一个月之后，我在复旦大学软件学院开设了“计算机系统基础”课程，成为国内第一个采用这本教材授课的老师。这本教材有四个特点。第一，涉及面广，) Tj
T*
(覆盖了二进制、汇编、组成、体系结构、操作系统、网络与并发程序设计等计算机系统最重要的方面。第二，具有相当的深度，本书从程序出发逐步深人到系统领域的重要问题，而非点到为止，学完本书后) Tj
T*
(读者可以很好地理解计算机系统的工作原理。第三，它是面向低年级学生的教材，在过去的教学体系中这本书所涉及的很多内容只能在高年级讲授，而本书通过合理的安排将计算机系统领域最核心的内容巧) Tj
T*
(妙地展现给学生（例如，不需要掌握逻辑设计与硬件描述语言的完整知识，就可以体验处理器设计）。第四，本书配备了非常实用、有趣的实验。例如，模仿硬件仅用位操作完成复杂的运算，模仿) Tj
T*
(tracker 和 hacker 去破解密码以及攻击自身的程序，设计处理器，实现简单但功能强大的 Shell 和 Proxy) Tj
T*
(等。这些实验既强化了学生对书本知识的理解，也进一步激发了学生探究计算机系统的热情。) Tj
T*
() Tj
T*
(以低年级开设“深入理解计算机系统”课程为基础，我先后在复旦大学和上海交通大学软件学院主导了激进的教学改革。必修课时被大量压缩，现在软件工程专业必修课由问题求解、计算机系统基础、应用) Tj
T*
(开发基础、软件工程四个模块 9 门课构成。其他传统的必修课如操作系统、编译原理、数字逻辑等都成为方向课。课程体系的变化，减少了学生修读课程的总数和总课时，因而为大幅度增加实验总量、) Tj
T*
(提高实验难度和强度、增强实验的综合性和创新性提供了有力保障。现在我的课题组的青年教师全部是首批经历此项教学改革的学生。本科的扎实基础为他们从事系统软件研究打下了良好基础，他们实现了) Tj
T*
(亚洲学术界在操作系统旗舰会议 SOSP 上论文发表零的突破，目前研究成果在国际上具有较大的影响力。师资力量的补充，又为全面推进更加激进的教学改革创造了条件。) Tj
T*
() Tj
T*
(本书的出版标志着国际上计算机教学进入了第三阶段。从历史来看，国际上计算机教学先后经历了三个主要阶段。第一阶段是上世纪 70 年代中期至 80) Tj
T*
(年代中期．那时理论、技术还不成熟，系统不稳定，因此教材主要围绕若干重要问题讲授不同流派的观点，学生解决实际问题的能力不强。第二阶段是上世纪 80 年代中期至本世纪初，当时计算机单机) Tj
T*
(系统的理论和技术已逐步趋于成熟，主流系统稳定，因此教材主要围绕主流系统讲解理论和技术，学生的理论基础扎实，动手能力强。第三阶段从本世纪初开始，主要背景是随着互联网的兴起，信息技术开) Tj
T*
(始渗透到人类工作和生活的方方面面。技术爆炸迫使教学者必须重构传统的以计算机单机系统为主导的课程体系。新的体系大面积调整了核心课程的内容。核心课程承担了帮助学生构建专业知识框架的任务) Tj
T*
(，为学生在毕业后相当长时间内的专业发展奠定坚实基础。现在一般认为问题抽象、系统抽象和数据抽象是计算机类专业毕业生的核心能力。而本书担负起了系统抽象的重任，因此美国的很多高校都采用了) Tj
T*
(该书作为计算机系统核心课程的教材。第三阶段的教材与第二阶段的教材是互补关系。第三阶段的教材主要强调坚实而宽广的基础，第二阶段的教材主要强调深入系统的专门知识，因此依然在本科高年级方) Tj
T*
(向课和研究生专业课中占据重要地位。) Tj
T*
() Tj
T*
(上世纪 80 年代初，我国借鉴美国经验建立了自己的计算机教学体系并引进了大量教材。从 21) Tj
T*
(世纪初开始，一些学校开始借鉴美国第二阶段的教学方法，采用了部分第二阶段的著名教材，这些改革正在走向成熟并得以推广。2012 年北京大学计算机专业采用本书作为教材后，采用本教材开设) Tj
T*
("计算机系统基础" 课程的高校快速增加。以此为契机，国内的计算机教学也有望全面进人第三阶段。) Tj
T*
() Tj
T*
(本书的第 3 版完全按照 x86-64 系统进行改写。此外，第 2 版中删除了以 x87 呈现的浮点指令，在第 3 版中浮点指令又以标量 AVX2 的形式得以恢复。第 3 版更加强) Tj
T*
(调并发，增加了较大篇幅用于讨论信号处理程序与主程序间并发时的正确性保障。总体而言，本书的三个版本在结构上没有太大变化，不同版本的出现主要是为了在细节上能够更好地反映技术的最新变化。) Tj
T*
() Tj
T*
(当然本书的某些部分对于初学者而言还是有些难以阅读。本书涉及大量重要概念，但一些概念首次亮相时并没有编排好顺序。例如寄存器的概念、汇编指令的顺序执行模式、PC) Tj
T*
(的概念等对于初学者而言非常陌生，但这些介绍仅仅出现在第 1 章的总览中，而当第 3 章介绍汇编时完全没有进一步的展开就假设读者已经非常清楚这些概念。事实上这些概念原本就介绍得过于简) Tj
T*
(单，短暂亮相之后又立即退场，相隔较长时间后，当这些概念再次登场时，初学者早已忘却了它们是什么。同样，第 8) Tj
T*
(章对进程、并发等概念的介绍也存在类似问题。因此，中文翻译版将配备导读部分，希望这些导读能够帮助初学者顺利阅读。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
ET
endstream
endobj
344 0 obj
<< /Length 4109 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(2016 年 10 月 15 日) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(译者序) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(译者序) Tj
T*
() Tj
T*
() Tj
T*
(本书第 1 版出版于 2003 年，第 2 版出版于 2011 年，去年发行的已经是原书第 3 版了。第 3 版还是采用以下组合方式∶在经典的 x86 架构机器上运行 Linux) Tj
T*
(操作系统，采用 C 语言编程。这样的组合经受住了时间的考验。这一版的一个明显变化就是从讲解 IA32 和 x86-64 转变为完全以 x86-64 为基础，相应地修改了第) Tj
T*
(3、4、5、6 和 7 章。同时，还改写了第 2 章，使之更易读、好懂; 用近期的新技术更新了第 6、11 和 12) Tj
T*
(章。这些变化使得本书既和新技术保持了同步，又保留了描述系统本质的内容以及从程序员角度出发的特色。) Tj
T*
() Tj
T*
(除了翻译本书，我们也开始以本书为教材讲授 "计算机系统基础") Tj
T*
(课程，对这本书的理解也随之越来越深人，意识到除了阅读之外，动手实践更是学习计算机系统的必经之路。本书的官网提供了很多实验作业（Lab) Tj
T*
(Assignment），其中不乏有趣且有一定难度的实验，比如 Bomb Lab。有兴趣的读者除了阅读本书的内容之外，还应该试着去完成这些实验，让纸面上的内容在实际动手中得到巩固和加) Tj
T*
(强。本书的官方博客也不断更新着有关这本书和配套课程的最新变化，这也是对本书的有益补充。) Tj
T*
() Tj
T*
(第 3 版从翻译的角度来说，我们尽量做到更流畅，更符合中文表达的习惯。对于一些术语，比如) Tj
T*
(memory，以前怕出错就统一翻译成存储器，现在则尽可能地按照语境去区分，翻译成内存或者存储器。) Tj
T*
(在此，要感谢本书的编辑朱劫、姚蕾以及和静，有她们的支持、鼓励和耐心细致的工作，才能让本书如期与读者见面。) Tj
T*
() Tj
T*
(由于本书内容多，翻译时间紧迫，尽管我们尽量做到认真仔细，但还是难以避免出现错误和不尽如人意的地方。在此欢迎广大读者批评指正。我们也会一如既往地维护勘误表，及时在网上更新，方便大家阅) Tj
T*
(读。（另外，本版第 1 次印刷时，我们已经根据官网 2016 年 3 月 1 日前发布的勘误进行了修正，就不在中文勘误中再翻译了。）) Tj
T*
() Tj
T*
(龚奕利 贺莲) Tj
T*
() Tj
T*
(2016 年 5 月于珞珈山) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(前言) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(前言) Tj
T*
() Tj
T*
() Tj
T*
(本书（简称 CS：APP）的主要读者是计算机科学家、计算机工程师，以及那些想通过学习计算机系统的内在运作而能够写出更好程序的人。) Tj
T*
() Tj
T*
(我们的目的是解释所有计算机系统的本质概念，并向你展示这些概念是如何实实在在地影响应用程序的正确性、性能和实用性的。其他的系统类书籍都是从构建者的角度来写的，讲述如何实现硬件或系统软) Tj
T*
(件，包括操作系统、编译器和网络接口。而本书是从程序员的角度来写的，讲述应用程序员如何能够利用系统知识来编写出更好的程序。当然，学习一个计算机系统应该做些什么，是学习如何构建一个计算) Tj
T*
(机系统的很好的出发点，所以，对于希望继续学习系统软硬件实现的人来说，本书也是一本很有价值的介绍性读物。大多数系统书籍还倾向于重点关注系统的某一个方面，比如：硬件架构、操作系统、编译) Tj
T*
(器或者网络。本书则以程序员的视角统一覆盖了上述所有方面的内容。) Tj
T*
ET
endstream
endobj
345 0 obj
<< /Length 4926 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(如果你研究和领会了这本书里的概念，你将开始成为极少数的"牛人"，这些"牛人"知道事情是如何运作的，也知道当事情出现故障时如何修复。你写的程序将能够更好地利用操作系统和系统软件提供的) Tj
T*
(功能，对各种操作条件和运行时参数都能正确操作，运行起来更快，并能避免出现使程序容易受到网络攻击的缺陷。同时，你也要做好更深入探究的准备，研究像编译器、计算机体系结构、操作系统、嵌入) Tj
T*
(式系统、网络互联和网络安全这样的高级题目。) Tj
T*
() Tj
T*
(读者应具备的背景知识) Tj
T*
() Tj
T*
() Tj
T*
(本书的重点是执行 x86-64 机器代码的系统。对英特尔及其竞争对手而言，x86-64 是他们自 1978 年起，以8086) Tj
T*
(微处理器为代表，不断进化的最新成果。按照英特尔微处理器产品线的命名规则，这类微处理器俗称为) Tj
T*
(“x86”。随着半导体技术的演进，单芯片上集成了更多的晶体管，这些处理器的计算能力和内存容量有了很大的增长。在这个过程中，它们从处理 16 位字，发展到引人 IA32 处理器处理) Tj
T*
(32 位字，再到最近的 x86-64 处理 64 位字。) Tj
T*
() Tj
T*
(我们考虑的是这些机器如何在 Linux 操作系统上运行 C 语言程序。Linux 是众多继承自最初由贝尔实验室开发的 Unix 的操作系统中的一种。这类操作系统的其他成员包括) Tj
T*
(Solaris、FreeBSD 和 Mac OSX。近年来，由于 Posix 和标准 Unix 规范的标准化努力，这些操作系统保持了高度兼容性。因此，本书内容几乎直接适用于这些“类) Tj
T*
(Unix”操作系统。) Tj
T*
() Tj
T*
(文中包含大量已在 Linux 系统上编译和运行过的程序示例。我们假设你能访问一台这样的机器，并且能够登录，做一些诸如切换目录之类的简单操作。如果你的计算机运行的是) Tj
T*
(Microsoft Windows 系统，我们建议你选择安装一个虚拟机环境（例如 VirtualBox 或者 VMWare），以便为一种操作系统（客户) Tj
T*
(OS）编写的程序能在另一种系统（宿主 OS）上运行。) Tj
T*
() Tj
T*
(我们还假设你对 C 和 C++ 有一定的了解。如果你以前只有 Java 经验，那么你需要付出更多的努力来完成这种转换，不过我们也会帮助你。Java 和 C) Tj
T*
(有相似的语法和控制语句。不过，有一些 C 语言的特性（特别是指针、显式的动态内存分配和格式化 I/O）在 Java 中都是没有的。所幸的是，C 是一个较小的语言，在Brian) Tj
T*
(Kernighan和Dennis Ritchie经典的"K8.R"文献中得到了清晰优美的描述【61】。无论你的编程背景如何，都应该考虑将 K&R) Tj
T*
(作为个人系统藏书的一部分。如果你只有使用解释性语言的经验，如 Python、Ruby 或 Perl，那么在使用本书之前，需要花费一些时间来学习 C。) Tj
T*
() Tj
T*
(本书的前几章揭示了C语言程序和它们相对应的机器语言程序之间的交互作用。机器语言示例都是用运行在 x86-64 处理器上的 GNUGCC) Tj
T*
(编译器生成的。我们不需要你以前有任何硬件、机器语言或是汇编语言编程的经验。) Tj
T*
() Tj
T*
(给C语言初学者 - 关于C编程语言的建议) Tj
T*
() Tj
T*
() Tj
T*
(为了帮助C语言编程背景薄弱（或全无背景）的读者，我们在书中加入了这样一些专门的注释来突出 C 中一些特别重要的特性。我们假设你熟悉 C++ 或 Java。) Tj
T*
() Tj
T*
(如何阅读此书) Tj
T*
() Tj
T*
() Tj
T*
(从程序员的角度学习计算机系统是如何工作的会非常有趣，主要是因为你可以主动地做这件事情。无论何时你学到一些新的东西，都可以马上试验并且直接看到运行结果。事实上，我们相信学习系统的唯一) Tj
T*
(方法就是做（do）系统，即在真正的系统上解决具体的问题，或是编写和运行程序。) Tj
T*
() Tj
T*
(这个主题观念贯穿全书。当引入一个新概念时，将会有一个或多个练习题紧随其后，你应该马上做一做来检验你的理解。这些练习题的解答在每章的末尾。当你阅读时，尝试自己来解答每个问题，然后再查) Tj
T*
(阅答案，看自已的答案是否正确。除第 1 章外，每章后面都有难度不同的家庭作业。对每个家庭作业题，我们标注了难度级别：) Tj
T*
() Tj
T*
(* ① 只需要几分钟。几乎或完全不需要编程。) Tj
T*
(* ② 可能需要将近 20 分钟。通常包括编写和测试一些代码。（许多都源自我们在考试中出的题目。）) Tj
T*
(* ③ 需要很大的努力，也许是 1～2 个小时。一般包括编写和测试大量的代码。) Tj
T*
ET
endstream
endobj
346 0 obj
<< /Length 7299 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(* ④ 一个实验作业，需要将近 10 个小时。) Tj
T*
() Tj
T*
(文中每段代码示例都是由经过 GCC 编译的 C 程序直接生成并在 Linux 系统上进行了测试，没有任何人为的改动。当然，你的系统上 GCC) Tj
T*
(的版本可能不同，或者根本就是另外一种编译器，那么可能生成不一样的机器代码，但是整体行为表现应该是一样的。所有的源程序代码都可以从 csapp.cs.cmu.edu 上) Tj
T*
(的CS：APP 主页上获取。在本书中，源程序的文件名列在两条水平线的右边，水平线之间是格式化的代码。比如，图1中的程序能在 code/intro/ 目录下的 hello.c) Tj
T*
(文件中找到。当遇到这些示例程序时，我们鼓励你在自己的系统上试着运行它们。) Tj
T*
() Tj
T*
(为了避免本书体积过大、内容过多，我们添加了许多网络旁注（Web aside），包括一些对本书主要内容的补充资料。本书中用 CHAP：TOP 这样的标记形式来引用这些旁注，这里) Tj
T*
(CHAP 是该章主题的缩写编码，而 TOP 是涉及的话题的缩写编码。例如，网络旁注 DATA：BOOL 包含对第 2 章中数据表示里面有关布尔代数内容的补充资料；而网络旁注) Tj
T*
(ARCH：VLOG 包含的是用 Verilog 硬件描述语言进行处理器设计的资料，是对第 4 章中处理器设计部分的补充。所有的网络旁注都可以从 CS：APP 的主页上获取。) Tj
T*
() Tj
T*
(旁注 - 什么是旁注) Tj
T*
() Tj
T*
() Tj
T*
(在整本书中，你将会遇到很多以这种形式出现的旁注。旁注是附加说明，能使你对当前讨论的主题多一些了解。旁注可以有很多用处。一些是小的历史故事。例如，C 语言、Linux 和) Tj
T*
(Internet 是从何而来的？有些旁注则是用来澄清学生们经常感到疑感的问题。例如，高速缓存的行、组和块有什么区别？还有些旁注给出了一些现实世界的例子。例如，一个浮点错误怎么毁掉了) Tj
T*
(法国的一枚火箭，或是给出市面上出售的一个磁盘驱动器的几何和运行参数。最后，还有一些旁注仅仅就是一些有趣的内容，例如，什么是“hoinky”？) Tj
T*
() Tj
T*
(本书概述) Tj
T*
() Tj
T*
() Tj
T*
(本书由 12 章组成，旨在阐述计算机系统的核心概念。内容概述如下：) Tj
T*
() Tj
T*
(* 第1章：计算机系统漫游。 这一章通过研究 “hello, world” 这个简单程序的生命周期，介绍计算机系统的主要概念和主题。) Tj
T*
(* 第2章：信息的表示和处理。 我们讲述了计算机的算术运算，重点描述了会对程序员有 影响的无符号数和数的补码表示的特性。我们考虑数字是如何表示的，以及由此确定对于一个给定的字长，其) Tj
T*
(可能编码值的范围。我们探讨有符号和无符号数字之间类型转换的效果，还阐述算术运算的数学特性。菜鸟级程序员经常很惊奇地了解到（用补码表示的）两个正数的和或者积可能为负。另一方面，补码的) Tj
T*
(算术运算满足很多整数运算的代数特性，因此，编译器可以很安全地把一个常量乘法转化为一系列的移位和加法。我们用C 语言的位级操作来说明布尔代数的原理和应用。我们从两个方面讲述了) Tj
T*
(IEEE 标准的浮点格式：一是如何用它来表示数值，一是浮点运算的数学属性。) Tj
T*
() Tj
T*
(  对计算机的算术运算有深刻的理解是写出可靠程序的关键。比如，程序员和编译器不能用表达式（x-y&lt;0）来替代（x&lt;y），因为前者可能会产生溢出。甚至也不能用表达式（-) Tj
T*
(  y&lt;-x）来替代，因为在补码表示中负数和正数的范围是不对称的。算术溢出是造成程序错误和安全漏洞的一个常见根源，然而很少有书从程序员的角度来讲述计算机算术运算的特性。) Tj
T*
() Tj
T*
(* 第3章：程序的机器级表示。 我们教读者如何阅读由 C 编译器生成的 x86-64 机器代码。我们说明为不同控制结构（比如条件、循环和开关语句）生成的基本指令模式。我们还讲述过程) Tj
T*
(的实现，包括栈分配、寄存器使用惯例和参数传递。我们讨论不同数据结构（如结构、联合和数组）的分配和访问方式。我们还说明实现整数和浮点数算术运算的指令。我们还以分析程序在机器级的样子作) Tj
T*
(为途径，来理解常见的代码安全漏洞（例如缓冲区溢出），以及理解程序员、编译器和操作系统可以采取的减轻这些威胁的措施。学习本章的概念能够帮助读者成为更好的程序员，因为你们懂得程序在机器) Tj
T*
(上是如何表示的。另外一个好处就在于读者会对指针有非常全面而具体的理解。) Tj
T*
(* 第4章：处理器体系结构。 这一章讲述基本的组合和时序逻辑元素，并展示这些元素如何在数据通路中组合到一起，来执行 x86-64 指令集的一个称为 “Y86-64” 的简化子集。我) Tj
T*
(们从设计单时钟周期数据通路开始。这个设计概念上非常简单，但是运行速度不会太快。然后我们引入流水线的思想，将处理一条指令所需要的不同步骤实现为独立的阶段。这个设计中，在任何时刻，每个) Tj
T*
(阶段都可以处理不同的指令。我们的五阶段处理器流水线更加实用。本章中处理器设计的控制逻辑是用一种称为 HCL 的简单硬件描述语言来描述的。用 HCL) Tj
T*
(写的硬件设计能够编译和链接到本书提供的模拟器中，还可以根据这些设计生成 Verilog 描述，它适合合成到实际可以运行的硬件上去。) Tj
T*
(* 第5章：优化程序性能。 在这一章里，我们介绍了许多提高代码性能的技术，主要思想就是让程序员通过使编译器能够生成更有效的机器代码来学习编写 C 代码。我们一开始介绍的是减少程序需) Tj
T*
(要做的工作的变换，这些是在任何机器上写任何程序时都应该遵循的。然后讲的是增加生成的机器代码中指令级并行度的变换，因而提高了程序在现代“超标量”处理器上的性能。为了解释这些变换行之有) Tj
T*
(效的原理，我们介绍了一个简单的操作模型，它描述了现代乱序处理器是如何工作的，然后给出了如何根据一个程序的图形化表示中的关键路径来测量一个程序可能的性能。你会惊讶于对 C) Tj
T*
(代码做一些简单的变换能给程序带来多大的速度提升。) Tj
T*
(* 第6章：存储器层次结构。 对应用程序员来说，存储器系统是计算机系统中最直接可见的部分之一。到目前为止，读者一直认同这样一个存储器系统概念模型，认为它是一个有一致访问时间的线性数) Tj
T*
(组。实际上，存储器系统是一个由不同容量、造价和访问时间的存储设备组成的层次结构。我们讲述不同类型的随机存取存储器（RAM）和只读存储器（ROM），以及磁盘和✦固态硬盘✦的几何形状和) Tj
T*
ET
endstream
endobj
347 0 obj
<< /Length 7307 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(组织构造。我们描述这些存储设备是如何放置在层次结构中的，讲述访问局部性是如何使这种层次结构成为可能的。我们通过一个独特的观点使这些理论具体化，那就是将存储器系统视为一个“存储器山”) Tj
T*
(，山脊是时间局部性，而斜坡是空间局部性。最后，我们向读者阐述如何通过改善程序的时间局部性和空间局部性来提高应用程序的性能。) Tj
T*
() Tj
T*
(✦固态硬盘✦：直译应为固态驱动器，但固态硬盘一词已经被大家接受，所以沿用。——译者注) Tj
T*
() Tj
T*
(* 第7章：链接。 本章讲述静态和动态链接，包括的概念有可重定位的和可执行的目标文件、符号解析、重定位、静态库、共享目标库、位置无关代码，以及库打桩。大多数讲述系统的书中都不讲链接) Tj
T*
(，我们要讲述它是出于以下原因。第一，程序员遇到的最令人迷惑的问题中，有一些和链接时的小故障有关，尤其是对那些大型软件包来说。第二，链接器生成的目标文件是与一些像加载、虚拟内存和内存) Tj
T*
(映射这样的概念相关的。) Tj
T*
(* 第8章：异常控制流。 在本书的这个部分，我们通过介绍异常控制流（即除正常分支和过程调用以外的控制流的变化）的一般概念，打破单一程序的模型。我们给出存在于系统所有层次的异常控制流) Tj
T*
(的例子，从底层的硬件异常和中断，到并发进程的上下文切换，到由于接收 Linux 信号引起的控制流突变，到 C 语言中破坏栈原则的非本地跳转。) Tj
T*
(在这一章，我们介绍进程的基本概念，进程是对一个正在执行的程序的一种抽象。读者会学习进程是如何工作的，以及如何在应用程序中创建和操纵进程。我们会展示应用程序员如何通过 Linux) Tj
T*
(系统调用来使用多个进程。学完本章之后，读者就能够编写带作业控制的 Linux shell 了。同时，这里也会向读者初步展示程序的并发执行会引起不确定的行为。) Tj
T*
(* 第9章：虚拟内存。我们讲述虚拟内存系统是希望读者对它是如何工作的以及它的特性有所了解。我们想让读者了解为什么不同的并发进程各自都有一个完全相同的地址范围，能共享某些页，而又独占) Tj
T*
(另外一些页。我们还讲了一些管理和操纵虚拟内存的问题。特别地，我们讨论了存储分配操作，就像标准库的 malloc 和 free 操作。阐述这些内容是出于下面几个目的。它加强了这样一个) Tj
T*
(概念，那就是虚拟内存空间只是一个字节数组，程序可以把它划分成不同的存储单元。它可以帮助读者理解当程序包含存储泄漏和非法指针引用等内存引用错误时的后果。最后，许多应用程序员编写自己的) Tj
T*
(优化了的存储分配操作来满足应用程序的需要和特性。这一章比其他任何一章都更能展现将计算机系统中的硬件和软件结合起来阐述的优点。而传统的计算机体系结构和操作系统书籍都只讲述虚拟内存的某) Tj
T*
(一方面。) Tj
T*
(* 第10章：系统级 I/O。 我们讲述 Unix I/O 的基本概念，例如文件和描述符。我们描述如何共享文件，I/O) Tj
T*
(重定向是如何工作的，还有如何访问文件的元数据。我们还开发了一个健壮的带缓冲区的 I/O 包，可以正确处理一种称为 short counts) Tj
T*
(的奇特行为，也就是库函数只读取一部分的输入数据。我们阐述 C 的标准 I/O 库，以及它与 Linux I/O 的关系，重点谈到标准 I/O) Tj
T*
(的局限性，这些局限性使之不适合网络编程。总的来说，本章的主题是后面两章——网络和并发编程的基础。) Tj
T*
(* 第11章：网络编程。 对编程而言，网络是非常有趣的 I/O 设备，它将许多我们前面文中学习的概念（比如进程、信号、字节顺序、内存映射和动态内存分配）联系在一起。网络程序还为下一) Tj
T*
(章的主题——并发，提供了一个很令人信服的上下文。本章只是网络编程的一个很小的部分，使读者能够编写一个简单的 Web 服务器。我们还讲述位于所有网络程序底层的客户端-) Tj
T*
(服务器模型。我们展现了一个程序员对 Internet 的观点，并且教读者如何用套接字接口来编写 Internet) Tj
T*
(客户端和服务器。最后，我们介绍超文本传输协议（HTTP），并开发了一个简单的迭代式 Web 服务器。) Tj
T*
(* 第12章：并发编程。 这一章以 Internet) Tj
T*
(服务器设计为例介绍了并发编程。我们比较对照了三种编写并发程序的基本机制（进程、I/O多路复用和线程），并且展示如何用它们来建造并发Internet服务器。我们探讨了用 P、V 信号) Tj
T*
(量操作来实现同步、线程安全和可重入、竞争条件以及死锁等的基本原则。对大多数服务器应用来说，写并发代码都是很关键的。我们还讲述了线程级编程的使用方法，用这种方法来表达应用程序中的并行) Tj
T*
(性，使得程序在多核处理器上能执行得更快。使用所有的核解决同一个计算问题需要很小心谨慎地协调并发线程，既要保证正确性，又要争取获得高性能。) Tj
T*
() Tj
T*
(本版新增内容) Tj
T*
() Tj
T*
() Tj
T*
(本书的第 1 版于 2003 年出版，第 2 版在 2011 年出版。考虑到计算机技术发展如此迅速，这本书的内容还算是保持得很好。事实证明 Intel x86 的机器上运行) Tj
T*
(Linux （以及相关操作系统），加上采用 C) Tj
T*
(语言编程，是一种能够涵盖当今许多系统的组合。然而，硬件技术、编译器和程序库接口的变化，以及很多教师教授这些内容的经验，都促使我们做了大量的修改。) Tj
T*
() Tj
T*
(第 2 版以来的最大整体变化是，我们的介绍从以 IA32 和 x86-64 为基础，转变为完全以 x86-64 为基础。这种重心的转移影响了很多章节的内容。下面列出一些明显的变化∶) Tj
T*
() Tj
T*
(* 第 1 章。我们将第 5 章对 Amdahl 定理的讨论移到了本章。) Tj
T*
(* 第 2 章。读者和评论家的反馈是一致的，本章的一些内容有点令人不知所措。因此，我们澄清了一些知识点，用更加数学的方式来描述，使得这些内容更容易理解。这使得读者能先略过数学细节，) Tj
T*
(获得高层次的总体概念，然后回过头来进行更细致深入的阅读。) Tj
T*
(* 第 3 章。我们将之前基于 IA32 和 x86-64 的表现形式转换为完全基于 x86-64 ，还更新了近期版本 GCC) Tj
T*
(产生的代码。其结果是大量的重写工作，包括修改了一些概念提出的顺序。同时，我们还首次介绍了对处理浮点数据的程序的机器级支持。由于历史原因，我们给出了一个网络旁注描述 IA32) Tj
T*
(机器码。) Tj
T*
(* 第 4 章。我们将之前基于 32 位架构的处理器设计修改为支持 64 位字和操作的设计。) Tj
T*
ET
endstream
endobj
348 0 obj
<< /Length 5672 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(* 第 5 章。我们更新了内容以反映最近几代 x86-64 处理器的性能。通过引入更多的功能单元和更复杂的控制逻辑，我们开发的基于程序数据流表示的程序性能模型，其性能预测变得) Tj
T*
(比之前更加可靠。) Tj
T*
(* 第 6 章。我们对内容进行了更新，以反映更多的近期技术。) Tj
T*
(* 第 7 章。针对 x86-64，我们重写了本章，扩充了关于用 GOT 和 PLT 创建位置无关代码的讨论，新增了一节描述更加强大的链接技术，比如库打桩。) Tj
T*
(* 第 8 章。我们增加了对信号处理程序更细致的描述，包括异步信号安全的函数，编写信号处理程序的具体指导原则，以及用 sigsuspend 等待处理程序。) Tj
T*
(* 第 9 章。本章变化不大。) Tj
T*
(* 第 10 章。我们新增了一节说明文件和文件的层次结构，除此之外，本章的变化 不大。) Tj
T*
(* 第 11 章。我们介绍了采用最新 getaddrinfo 和 getnameinfo 函数的、与协议无关和线程安全的网络编程，取代过时的、不可重入的 gethostbyname) Tj
T*
(和 gethost-byaddr 函数。) Tj
T*
(* 第12章。我们扩充了利用线程级并行性使得程序在多核机器上更快运行的内容。) Tj
T*
() Tj
T*
(此外，我们还增加和修改了很多练习题和家庭作业。) Tj
T*
() Tj
T*
(本书的起源) Tj
T*
() Tj
T*
() Tj
T*
(本书起源于 1998 年秋季，我们在卡内基-梅隆（CMU）大学开设的一门编号为 15-213 的介绍性课程∶计算机系统导论（Introduction to Computer) Tj
T*
(System，ICS）【14】。从那以后，每学期都开设了 ICS 这门课程，每学期有超过 400) Tj
T*
(名学生上课，这些学生从本科二年级到硕士研究生都有，所学专业也很广泛。这门课程是卡内基-梅隆大学计算机科学系（CS）以及电子和计算机工程系（ECE）所有本科生的必修课，也是 CS 和) Tj
T*
(ECE 大多数高级系统课程的先行必修课。) Tj
T*
() Tj
T*
(ICS 这门课程的宗旨是用一种不同的方式向学生介绍计算机。因为，我们的学生中几乎没有人有机会亲自去构造一个计算机系统。另一方面，大多数学生，甚至包括所有的计算机科学家和计算机工程师) Tj
T*
(，也需要日常使用计算机和编写计算机程序。所以我们决定从程序员的角度来讲解系统，并采用这样的原则过滤要讲述的内容∶我们只讨论那些影响用户级 C 语言程序的性能、正确性或实用性的主题。) Tj
T*
() Tj
T*
(比如，我们排除了诸如硬件加法器和总线设计这样的主题。虽然我们谈及了机器语言，但是重点并不在于如何手工编写汇编语言，而是关注 C 语言编译器是如何将 C 语言的结构翻译成机器代码的，) Tj
T*
(包括编译器是如何翻译指针、循环、过程调用以及开关（switch）语句的。更进一步地，我们将更广泛和全盘地看待系统，包括硬件和系统软件，涵盖了包括链接、加载、进程、信号、性能优化、虚) Tj
T*
(拟内存、I/O 以及网络与并发编程等在内的主题。) Tj
T*
() Tj
T*
(这种做法使得我们讲授 ICS 课程的方式对学生来讲既实用、具体，还能动手操作，同时也非常能调动学生的积极性。很快地，我们收到来自学生和教职工非常热烈而积极的反响，我们意识到卡内基-) Tj
T*
(梅隆大学以外的其他人也可以从我们的方法中获益。因此，这本书从 ICS 课程的笔记中应运而生了，而现在我们对它做了修改，使之能够反映科学技术以及计算机系统实现中的变化和进步。) Tj
T*
() Tj
T*
(通过本书的多个版本和多种语言译本， ICS 和许多相似课程已经成为世界范围内数百所高校的计算机科学和计算机工程课程的一部分。) Tj
T*
() Tj
T*
(写给指导教师们∶可以基于本书的课程) Tj
T*
() Tj
T*
() Tj
T*
(指导教师可以使用本书来讲授五种不同类型的系统课程（见图) Tj
T*
(2）。具体每门课程则有赖于课程大纲的要求、个人喜好、学生的背景和能力。图中的课程从左往右越来越强调以程序员的角度来看待系统。以下是简单的描述。) Tj
T*
() Tj
T*
(* ORG：一门以非传统风格讲述传统主题的计算机组成原理课程。传统的主题包括逻辑设计、处理器体系结构、汇编语言和存储器系统，然而这里更多地强调了对程序员的影响。例如，要反过来考虑数) Tj
T*
(据表示对 C 语言程序的数据类型和操作的影响。又例如，对汇编代码的讲解是基于C语言编译器产生的机器代码，而不是手工编写的汇编代码。) Tj
T*
(* ORG+：一门特别强调硬件对应用程序性能影响的 ORG 课程。和 ORG 课程相比，学生要更多地学习代码优化和改进 C 语言程序的内存性能。) Tj
T*
(* ICS：基本的ICS课程，旨在培养一类程序员，他们能够理解硬件、操作系统和编译系统对应用程序的性能和正确性的影响。和 ORG+) Tj
T*
(课程的一个显著不同是，本课程不涉及低层次的处理器体系结构。相反，程序员只同现代乱序处理器的高级模型打交道。ICS 课程非常适合安排到一个 10) Tj
T*
(周的小学期，如果期望步调更从容一些，也可以延长到一个 15 周的学期。) Tj
T*
(* ICS+：在基本的 ICS 课程基础上，额外论述一些系统编程的问题，比如系统级 I/O、网络编程和并发编程。这是卡内基-) Tj
T*
ET
endstream
endobj
349 0 obj
<< /Length 5806 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(梅隆大学的一门一学期时长的课程，会讲述本书中除了低级处理器体系结构以外的所有章。) Tj
T*
(* SP：一门系统编程课程。和 ICS+ 课程相似，但是剔除了浮点和性能优化的内容，更加强调系统编程，包括进程控制、动态链接、系统级I/O、网络编程和并发编程。指导教师可能会想从其) Tj
T*
(他渠道对某些高级主题做些补充，比如守护进程（daemon）、终端控制和 Unix IPC（进程间通信）。) Tj
T*
() Tj
T*
(图 2 要表达的主要信息是本书给了学生和指导教师多种选择。如果你希望学生更多地了解低层次的处理器体系结构，那么通过 ORG 和 ORG+) Tj
T*
(课程可以达到目的。另一方面，如果你想将当前的计算机组成原理课程转换成 ICS 或者 ICS+ 课程，但是又对突然做这样剧烈的变化感到担心，那么你可以逐步递增转向 ICS) Tj
T*
(课程。你可以从 OGR 课程开始，它以一种非传统的方式教授传统的问题。一旦你对这些内容感到驾轻就熟了，就可以转到 ORG+，最终转到 ICS。如果学生没有 C) Tj
T*
(语言的经验（比如他们只用 Java 编写过程序），你可以花几周的时间在 C 语言上，然后再讲述 ORG 或者 ICS 课程的内容。) Tj
T*
() Tj
T*
(最后，我们认为 ORG+ 和 SP 课程适合安排为两期（两个小学期或者两个学期）。或者你可以考虑按照一期 ICS 和一期 SP 的方式来教授 ICS+ 课程。) Tj
T*
() Tj
T*
(写给指导教师们∶经过课堂验证的实验练习) Tj
T*
() Tj
T*
() Tj
T*
(ICS+ 课程在卡内基-梅隆大学得到了学生很高的评价。学生对这门课程的评价，中值分数一般为 5.0/5.0，平均分数一般为) Tj
T*
(4.6/5.0。学生们说这门课非常有趣，令人兴奋，主要就是因为相关的实验练习。这些实验练习可以从 CS∶APP 的主页上获得。下面是本书提供的一些实验的示例。) Tj
T*
() Tj
T*
(* 数据实验。这个实验要求学生实现简单的逻辑和算术运算函数，但是只能使用一个非常有限的C语言子集。比如，只能用位级操作来计算一个数字的绝对值。这个实验可帮助学生了解C语言数据类型的) Tj
T*
(位级表示，以及数据操作的位级行为。) Tj
T*
(* 二进制炸弹实验。二进制炸弹是一个作为目标代码文件提供给学生的程序。运行时，它提示用户输入 6) Tj
T*
(个不同的字符串。如果其中的任何一个不正确，炸弹就会“爆炸”，打印出一条错误消息，并且在一个打分服务器上记录事件日志。学生必须通过对程序反汇编和逆向工程来测定应该是哪 6) Tj
T*
(个串，从而解除各自炸弹的雷管。该实验能教会学生理解汇编语言，并且强制他们学习怎样使用调试器。) Tj
T*
(*) Tj
T*
(缓冲区溢出实验。它要求学生通过利用一个缓冲区溢出漏洞，来修改一个二进制可执行文件的运行时行为。这个实验可教会学生栈的原理，并让他们了解写那种易于遭受缓冲区溢出攻击的代码的危险性。) Tj
T*
(* 体系结构实验。第 4 章的几个家庭作业能够组合成一个实验作业，在实验中，学生修改处理器的 HCL 描述，增加新的指令，修改分支预测策略，或者增加、删除旁路路径和寄存器端口。修改) Tj
T*
(后的处理器能够被模拟，并通过运行自动化测试检测出大多数可能的错误。这个实验使学生能够体验处理器设计中令人激动的部分，而不需要掌握逻辑设计和硬件描述语言的完整知识。) Tj
T*
(* 性能实验。学生必须优化应用程序的核心函数（比如卷积积分或矩阵转置）的性能。这个实验可非常清晰地表明高速缓存的特性，并带给学生低级程序优化的经验。) Tj
T*
(* cache 实验。这个实验类似于性能实验，学生编写一个通用高速缓存模拟器，并优化小型矩阵转置核心函数，以最小化对模拟的高速缓存的不命中次数。我们使用 Valgrind) Tj
T*
(为矩阵转置核心函数生成真实的地址访问记录。) Tj
T*
(* shell实验。学生实现他们自己的带有作业控制的 Unix shell 程序，包括 Ctrl+C和 Ctrl+Z 按键，fg、bg和 jobs) Tj
T*
(命令。这是学生第一次接触并发，并且让他们对 Unix 的进程控制、信号和信号处理有清晰的了解。) Tj
T*
(* malloc 实验。学生实现他们自己的 malloc、free 和) Tj
T*
(realloc（可选）版本。这个实验可让学生们清晰地理解数据的布局和组织，并且要求他们评估时间和空间效率的各种权衡及折中。) Tj
T*
(* 代理实验。实现一个位于浏览器和万维网其他部分之间的并行 Web 代理。这个实验向学生们揭示了 Web) Tj
T*
(客户端和服务器这样的主题，并且把课程中的许多概念联系起来，比如字节排序、文件 I/O、进程控制、信号、信号处理、内存映射、套接字和并发。学生很高兴能够看到他们的程序在真实的 Web) Tj
T*
(浏览器和 Web 服务器之间起到的作用。) Tj
T*
() Tj
T*
(CS∶APP的教师手册中有对实验的详细讨论，还有关于下载支持软件的说明。) Tj
T*
() Tj
T*
(第 3 版的致谢) Tj
T*
() Tj
T*
() Tj
T*
(很荣幸在此感谢那些帮助我们完成本书第3版的人们。) Tj
T*
() Tj
T*
(我们要感谢卡内基-梅隆大学的同事们，他们已经教授了 ICS 课程多年，并提供了富有见解的反馈意见，给了我们极大的鼓励∶Guy Blelloch、Roger) Tj
T*
(Dannenberg、David Eckhardt、Franz Franchetti、Greg Ganger、Seth Goldstein、Khaled Harras、Greg) Tj
T*
ET
endstream
endobj
350 0 obj
<< /Length 4239 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(Kesden、Bruce Maggs、Todd Mowry、Andreas Nowatzyk、Frank Pfenning、Markus Pueschel 和 Anthony) Tj
T*
(Rowe。David Winers 在安装和配置参考 Linux 机器方面给予了我们很大的帮助。) Tj
T*
() Tj
T*
(Jason Frtts（圣路易斯大学，St.Louis University）和 Cindy Noris（阿帕拉契州立大学，Appalachian State）对第 2) Tj
T*
(版提供了细致周密的评论。龚奕利（武汉大学，Wuhan Uni-versity）翻译了中文版，并为其维护勘误，同时还贡献了一些错误报告。Godmar) Tj
T*
(Back（弗吉尼亚理工大学，Virginia Tech）向我们介绍了异步信号安全以及与协议无关的网络编程，帮助我们显著提升了本书质量。) Tj
T*
() Tj
T*
(非常感谢目光敏锐的读者们，他们报告了第 2 版中的错误∶Rami Ammari、Paul An-agnostopoulos、Lucas Barenfanger、Godmar) Tj
T*
(Back、Ji Bin、Sharbel Bousemaan、Richard Callahan、Seth Chaiken、Cheng Chen、Libo Chen、Tao) Tj
T*
(Du、Pascal Garcia、Yili Gong、 XX11 Ronald Greenberg、Dorukhan Gul6z、Dong Han、Dominik) Tj
T*
(Helm、Ronald Jones、Musta-fa Kazdagli、Gordon Kindlmann、Sankar Krishnan、Kanak Kshetri、Junlin) Tj
T*
(Lu、Qian-gqiang Luo、Sebastian Luy、Lei Ma、Ashwin Nanjappa、Gregoire Paradis、Jonas Pfen-) Tj
T*
(ninger、Karl Pichotta、David Ramsey、Kaustabh Roy、David Selvaraj、Sankar Shan-mugam、Dominique) Tj
T*
(Smulkowska、Dag Sorbo、Michael Spear、Yu Tanaka、Steven Tri-canowicz、Scott Wright、Waiki) Tj
T*
(Wright、Han Xu、Zhengshan Yan、Firo Yang、Shuang Yang、John Ye、Taketo Yoshida、Yan Zhu 和 Michael) Tj
T*
(Zink。) Tj
T*
() Tj
T*
( 还要感谢对实验做出贡献的读者，他们是∶Godmar Back（弗吉尼亚理工大学，Vir-ginia Tech）、Taymon Beal（伍斯特理工学院，Worcester) Tj
T*
( Polytechnic Institute）、Aran Clauson（西华盛顿大学，Western Washington University）、Cary) Tj
T*
( Gray（威顿学院，Wheaton College）、Paul Haiduk（德州农机大学，West Texas A&.M University）、Len) Tj
T*
( Hamey（麦考瑞大学，Macquarie University）、Eddie Kohler（哈佛大学，Harvard）、Hugh Lauer（伍斯特理工学院，Worcester) Tj
T*
( Polytechnic Institute）、Robert Marmorstein（朗沃德大学，Longwood University）和James) Tj
T*
( Riely（德保罗大学，DePaul University）。) Tj
T*
() Tj
T*
(再次感谢 Windfall 软件公司的 Paul Anagnostopoulos 在本书排版和先进的制作过程中所做的精湛工作。非常感谢 Paul 和他的优秀团队∶Richard) Tj
T*
(Camp（文字编辑）、Jennifer McClain（校对）、Laurel Muller（美术制作）以及 Ted Laux（索引制作）。Paul 甚至找出了我们对缩写 BSS) Tj
T*
(的起源描述中的一个错误，这个错误从第 1 版起一直没有被发现！) Tj
T*
() Tj
T*
(最后，我们要感谢 Prentice Hall 出版社的朋友们。Marcia Horton 和我们的编辑 Matt Goldstein) Tj
T*
(一直坚定不移地给予我们支持和鼓励，非常感谢他们。) Tj
T*
() Tj
T*
(第 2 版的致谢) Tj
T*
() Tj
T*
() Tj
T*
(我们深深地感谢那些帮助我们写出 CS∶APP 第 2 版的人们。) Tj
T*
() Tj
T*
(首先，我们要感谢在卡内基-梅隆大学教授 ICS 课程的同事们，感谢你们见解深刻的反馈意见和鼓励∶Guy Blelloch、Roger Dannenberg、David) Tj
T*
(Eckhardt、Greg Ganger、Seth Goldstein、Greg Kesden、Bruce Maggs、Todd Mowry、Andreas) Tj
T*
(Nowatzyk、Frank Pfenning 和 Markus Pueschel。) Tj
T*
() Tj
T*
(还要感谢报告第 1 版勘误的目光敏锐的读者们∶Daniel Amelang、Rui Baptista、Quarup Barreirinhas、Michael Bombyk、Jorg) Tj
T*
(Brauer、Jordan Brough、Yixin Cao、James Carll、Rui Car-valho、Hyoung-Kee Choi、Al Davis、Grant) Tj
T*
(Davis、Christian Dufour、Mao Fan、Tim Freeman、Inge Frick、Max Gebhardt、JefGoldblat、Thomas) Tj
T*
(Gross、Anita Gupta、John Hampton、Hiep XXII Hong、Greg Israelsen、Ronald Jones、Haudy) Tj
T*
(Kazemi、Brian Kell、Constantine Kousoulis、Sacha Krakowiak、Arun Krishnaswamy、Martin) Tj
T*
(Kulas、Mchael Li、Zeyang Li、Ricky Liu、Mario Lo Conte、Dirk Maas、Devon Macey、Carl) Tj
T*
ET
endstream
endobj
351 0 obj
<< /Length 5074 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(Marcinik、Will Marrero、Simone Martins、Tho Men、Mark Mrissey、Venkata Naidu、Bhas) Tj
T*
(Nalabothula、Thomas Niemann、Eric Peskin、David Po、Anne Rogers、John Ross、Michael) Tj
T*
(Scott、Seiki、Ray Shih、Drren Shultz、Erik Sikensen、Sury anto、Emil Tarazi、Nawanan) Tj
T*
(TheeraAmpornpunt、Joe Trdinich、Mchael Trigoboff、James Troup、Martin Vopatek、Alan West、Betsy) Tj
T*
(Wolff、Tim Wong、James Woodruff、Scott Wright、Jackie Xao、Guanpeng Xu、Qing Xu、Caren Yang、Yin) Tj
T*
(Yongsheng、Wang Yuanxuan、Steven Zhang 和 Day Zhong。特别感谢 Inge Frck，他发现了我们加锁复制（lockand-) Tj
T*
(copy）例子中一个极不明显但很深刻的错误，还要特别感谢 Ricky Liu，他的校对水平真的很高。) Tj
T*
() Tj
T*
(我们 Intel 实验室的同事 Andrew Chien 和 Limor Fix 在本书的写作过程中一直非常支持。非常感谢 Steve Schlosser) Tj
T*
(提供了一些关于磁盘驱动器的总结描述，Casey Helfrich 和 Michael Ryan 安装并维护了新的 Core i7 机器。Michael Kozuch、Babu) Tj
T*
(Pillai 和 Jason Campbell 对存储器系统性能、多核系统和能量墙问题提出了很有价值的见解。Phil Gib-bons 和 Shimin Chen) Tj
T*
(跟我们分享了大量关于固态硬盘设计的专业知识。) Tj
T*
() Tj
T*
(我们还有机会邀请了 Wen-Mei Hwu、Markus Pueschel 和 Jiri Simsa 这样的高人给予了一些针对具体问题的意见和高层次的建议。James Hoe) Tj
T*
(帮助我们写了 Y86 处理器的 Verilog 描述，还完成了所有将设计合成到可运行的硬件上的工作。) Tj
T*
() Tj
T*
(非常感谢审阅本书草稿的同事们∶James Archibald（百翰杨大学，Brigham Young Univer-sity）、Richard) Tj
T*
(Carver（乔治梅森大学，George Mason University）、Mirela Damian（维拉诺瓦大学，Villanova University）、Peter) Tj
T*
(Dinda（西北大学）、John Fiore（坦普尔大学，Temple Univer-sity）、Jason Frits（圣路易斯大学，St.Louis) Tj
T*
(University）、John Greiner（莱斯大学）、Brian Har-vey（加州大学伯克利分校）、Don Hller（宾夕法利亚州立大学）、Wei Chung) Tj
T*
(Hsu（明尼苏达大学）、Michelle Hugue（马里兰大学）、Jeremy Johnson（德雷克塞尔大学，Drexel University）、Geff) Tj
T*
(Kuening（哈维马德学院，Harvey Mudd College）、Ricky Liu、Sam Madden（麻省理工学院）、Fred) Tj
T*
(Martin（马萨诸塞大学洛厄尔分校，University of Mssachusets，Lowell）、Abraham Matta（波士顿大学）、Markus) Tj
T*
(Puechel（卡内基-梅隆大学）、Norman Ramsey（塔夫茨大学，Tufis University）、Glenn Reinmann（加州大学洛杉矶分校）、Michela) Tj
T*
(Tufer（特拉华大学，University of Delaware）和 Craig Zilles（伊利诺伊大学香槟分校）。) Tj
T*
() Tj
T*
(Windfall 软件公司的 Paul Anagnostopoulos 出色地完成了本书的排版，并领导了制作团队。非常感谢 Paul和他超棒的团队∶Rick) Tj
T*
(Camp（文字编辑）、Joe Snowden（排版）、MaryElen N.Oliver（校对）、Laurel Muller（美术）和 Ted Laux（索引制作）。) Tj
T*
(最后，我们要感谢 Prentice Hall 出版社的朋友们。Marcia Horton 总是支持着我们。我们的编辑 MattGoldstein) Tj
T*
(由始至终表现出了一流的领导才能。我们由衷地感谢他们的帮助、鼓励和真知灼见。) Tj
T*
() Tj
T*
(第 1 版的致谢) Tj
T*
() Tj
T*
() Tj
T*
(我们衷心地感谢那些给了我们中肯批评和鼓励的众多朋友及同事。特别感谢我们 15-213 课程的学生们，他们充满感染力的精力和热情鞭策我们前行。Nick Carter 和 Viny) Tj
T*
(Furia 无私地提供了他们的 malloc 程序包。) Tj
T*
() Tj
T*
(Guy Blelloch、GregKesden、Bruce Maggs 和 Todd Mowry 已教授此课多个学期，他们给了我们鼓励并帮助改进课程内容。Herb Derby) Tj
T*
(提供了早期的精神指导和鼓励。Allan Fisher、Garth Gibson、Thomas Gross、Satya、Peter Steenkiste 和 Hui) Tj
T*
(Zhang从一开始就鼓励我们开设这门课程。Garth 早期给的建议促使本书的工作得以开展，并且在 Allan Fisher 领导的小组的帮助下又细化和修订了本书的工作。Mark) Tj
T*
(Stehlik 和 Peter Lee 提供了极大的支持，使得这些内容成为本科生课程的一部分。Greg Kesden 针对 ICS) Tj
T*
(在操作系统课程上的影响提供了有益的反馈意见。Greg Ganger 和 Jiri Schindler 提供了一些磁盘驱动的描述说明，并回答了我们关于现代磁盘的疑问。Tom) Tj
T*
(Striker 向我们展示了存储器山的比喻。James Hoe 在处理器体系结构方面提出了很多有用的建议和反馈。) Tj
T*
() Tj
T*
(有一群特殊的学生极大地帮助我们发展了这门课程的内容，他们是 Khalil Amiri、Angela Demke Brown、Chris Colohan、Jason) Tj
T*
(Crawford、Peter Dinda、Julio Lopez、Bruce Lowekamp、Jeff Pierce、Sanjay Rao、Balaji) Tj
T*
ET
endstream
endobj
352 0 obj
<< /Length 3934 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(Sarpeshkar、Blake Schll、Sanjit Seshia、Greg Steffan、Tiankai Tu、Kip Walker和Yinglian Xie。尤其是) Tj
T*
(Chris Colohan 建立了愉悦的氛围并持续到今天，还发明了传奇般的“二进制炸弹”，这是一个对教授机器语言代码和调试概念非常有用的工具。) Tj
T*
() Tj
T*
(Chris Bauer、Alan Cox、Peter Dinda、Sandhya Dwarkadis、John Greiner、Bruce Ja-cob、Barry) Tj
T*
(Johnson、Don Heller、Bruce Lowekamp、Greg Mrrset、Brian Noble、Bobie Othmer、BillPugh、Michael) Tj
T*
(Scott、Mark Smotherman、Greg Steffan 和 Bob Wier 花费了大量时间阅读此书的早期草稿，并给予我们建议。特别感谢 Peter) Tj
T*
(Dinda（西北大学）、John Greiner（莱茨大学）、Wei Hsu（明尼苏达大学）、Bruce Lowekamp（威廉&.玛丽大学）、Bobbie) Tj
T*
(Othmer（明尼苏达大学）、Michacl Scott（罗彻斯特大学）和 Bob Wier（落基山学院）在教学中测试此书的试用版。同样特别感谢他们的学生们！) Tj
T*
() Tj
T*
(我们还要感谢 Prentice Hall 出版社的同事。感谢 Marcia Horton、Eric Frank 和 Harold Stone 不懈的支持和远见。Harold) Tj
T*
(还帮我们提供了对 RISC 和 CISC 处理器体系结构准确的历史观点。Jerry Ralya 有惊人的见识，并教会了我们很多如何写作的知识。) Tj
T*
() Tj
T*
(最后，我们衷心感谢伟大的技术作家 Brian Kernighan 以及后来的 W. Richard Stevens，他们向我们证明了技术书籍也能写得如此优美。) Tj
T*
() Tj
T*
(谢谢你们所有的人。) Tj
T*
() Tj
T*
(Randal E. Bryant) Tj
T*
() Tj
T*
(David R. O'Hallaron) Tj
T*
() Tj
T*
(于匹兹堡，宾夕法尼亚州) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(关于作者) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(关于作者) Tj
T*
() Tj
T*
() Tj
T*
(Randal E. Bryant) Tj
T*
() Tj
T*
() Tj
T*
(1973 年于密歇根大学获得学士学位，随即就读于麻省理工学院研究生院，并在 1981 年获计算机科学博士学位。他在加州理工学院做了三年助教，从 1984 年至今一直是卡内基—梅隆大) Tj
T*
(学的教师。这其中有五年的时间，他是计算机科学系主任，有十年的时间是计算机科学学院院长。他现在是计算机科学学院的院长、教授。他同时还受邀任职于电子与计算机工程系。) Tj
T*
() Tj
T*
(他教授本科生和研究生计算机系统方面的课程近 40) Tj
T*
(年。在讲授计算机体系结构课程多年后，他开始把关注点从如何设计计算机转移到程序员如何在更好地了解系统的情况下编写出更有效和更可靠的程序。他和 O'Hallaron) Tj
T*
(教授一起在卡内基一梅隆大学开设了 15-213 课程“计算机系统导论”，那便是此书的基础。他还教授一些有关算法、编程、计算机网络、分布式系统和) Tj
T*
(VLSI（超大规模集成电路）设计方面的课程。) Tj
T*
() Tj
T*
(Bryant 教授的主要研究内容是设计软件工具来帮助软件和硬件设计者验证其系统正确性。其中，包括几种类型的模拟器，以及用数学方法来证明设计正确性的形式化验证工具。他发表了 150) Tj
T*
(多篇技术论文。包括 Intel、IBM、Fujitsu 和 Microsoft 在内的主要计算机制造商都使用着他的研究成果。他还因他的研究获得过数项大奖。其中包括) Tj
T*
(Semiconductor Research Corporation 颁发的两个发明荣誉奖和一个技术成就奖，ACM 颁发的 Kanellakis 理论与实践奖，还有 IEE 颁发的) Tj
T*
(W.R.G.Baker 奖、Emmanuel Piore 奖和 Phil Kaufman 奖。他还是 ACM 院士、IEEE 院士、美国国家工程院院士和美国人文与科学研究院院士。) Tj
T*
() Tj
T*
ET
endstream
endobj
353 0 obj
<< /Length 4337 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(David R. O'Hallaron) Tj
T*
() Tj
T*
() Tj
T*
(卡内基—梅隆大学计算机科学和电子与计算机工程系教授。在弗吉尼亚大学获得计算机科学博士学位，2007~2010 年为 Intel 匹兹堡实验室主任。) Tj
T*
() Tj
T*
(20 年来，他教授本科生和研究生计算机系统方面的课程，例如计算机体系结构、计算机系统导论、并行处理器设计和 Internet 服务。他和 Bryant) Tj
T*
(教授一起在卡内基—梅隆大学开设了作为本书基础的 “计算机系统导论” 课程。2004 年他获得了卡内基 - 梅隆大学计算机科学学院颁发的 Herbert Simon) Tj
T*
(杰出教学奖，这个奖项的获得者是基于学生的投票产生的。) Tj
T*
() Tj
T*
(O'Hallaron 教授从事计算机系统领域的研究，主要兴趣在于科学计算、数据密集型计算和虚拟化方面的软件系统。其中最著名的是 Quake) Tj
T*
(项目，该项目是一群计算机科学家、土木工程师和地震学家为提高对强烈地震中大地运动的预测能力而开发的。2003 年，他同 Quake) Tj
T*
(项目中其他成员一起获得了高性能计算领域中的最高国际奖项——Gordon Bell 奖。他目前的工作重点是自动分级（autograding）概念，即评价其他程序质量的程序。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(第 1 章：计算机系统漫游) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(第 1 章：计算机系统漫游) Tj
T*
() Tj
T*
() Tj
T*
(计算机系统是由硬件和系统软件组成的，它们共同工作来运行应用程序。虽然系统的具体实现方式随着时间不断变化，但是系统内在的概念却没有改变。所有计算机系统都有相似的硬件和软件组件，它们又) Tj
T*
(执行着相似的功能。一些程序员希望深入了解这些组件是如何工作的以及这些组件是如何影响程序的正确性和性能的，以此来提高自身的技能。本书便是为这些读者而写的。) Tj
T*
() Tj
T*
(现在就要开始一次有趣的漫游历程了。如果你全力投身学习本书中的概念，完全理解底层计算机系统以及它对应用程序的影响，那么你会步上成为为数不多的“大牛”的道路。) Tj
T*
() Tj
T*
(你将会学习一些实践技巧，比如如何避免由计算机表示数字的方式引起的奇怪的数字错误。你将学会怎样通过一些小窍门来优化自己的 C 代码，以充分利用现代处理器和存储器系统的设计。你将了解编) Tj
T*
(译器是如何实现过程调用的，以及如何利用这些知识来避免缓冲区溢出错误带来的安全漏洞，这些弱点给网络和因特网软件带来了巨大的麻烦。你将学会如何识别和避免链接时那些令人讨厌的错误，它们困) Tj
T*
(扰着普通的程序员。你将学会如何编写自己的 Unix shell、自己的动态存储分配包，甚至于自己的 Web) Tj
T*
(服务器。你会认识并发带来的希望和陷阱，这个主题随着单个芯片上集成了多个处理器核变得越来越重要。) Tj
T*
() Tj
T*
(在 Kernighan 和 Ritchie 的关于 C 编程语言的经典教材【61】中，他们通过图 1-1 中所示的 hello 程序来向读者介绍 C。尽管 hello) Tj
T*
(程序非常简单，但是为了让它实现运行，系统的每个主要组成部分都需要协调工作。从某种意义上来说，本书的目的就是要帮助你了解当你在系统上执行 hello) Tj
T*
(程序时，系统发生了什么以及为什么会这样。) Tj
T*
() Tj
T*
(    #include <stdio.h>) Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        printf\("hello, world\\n"\);) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 1-1 hello 程序（来源：【60】\\\)) Tj
T*
() Tj
T*
(我们通过跟踪 hello 程序的生命周期来开始对系统的学习——从它被程序员创建开始，到在系统上运行，输出简单的消息，然后终止。我们将沿着这个程序的生命周期，简要地介绍一些逐步出现的) Tj
T*
(关键概念、专业术语和组成部分。后面的章节将围绕这些内容展开。) Tj
T*
ET
endstream
endobj
354 0 obj
<< /Length 4853 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(1.1 信息就是位 + 上下文) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(1.1 信息就是位 + 上下文) Tj
T*
() Tj
T*
() Tj
T*
(hello 程序的生命周期是从一个源程序（或者说源文件）开始的，即程序员通过编辑器创建并保存的文本文件，文件名是 hello.c。源程序实际上就是一个由值 0 和 1) Tj
T*
(组成的位（又称为比特）序列，8 个位被组织成一组，称为字节。每个字节表示程序中的某些文本字符。) Tj
T*
() Tj
T*
(大部分的现代计算机系统都使用 ASCII 标准来表示文本字符，这种方式实际上就是用一个唯一的单字节大小的✦整数值✦来表示每个字符。比如，图 1-2 中给出了 hello.c 程序的) Tj
T*
(ASCII 码表示。) Tj
T*
() Tj
T*
(✦整数值✦：有其他编码方式用于表示非英语类语言文本。具体讨论参见 2.1.4 节的旁注。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-2 hello.c &#x7684; ASCII &#x6587;&#x672C;&#x8868;&#x793A;]) Tj
T*
() Tj
T*
(hello.c 程序是以字节序列的方式储存在文件中的。每个字节都有一个整数值，对应于某些字符。例如，第一个字节的整数值是 35，它对应的就是字符 “\\#”。第二个字节的整数值为) Tj
T*
(105，它对应的字符是 ‘i’，依此类推。注意，每个文本行都是以一个看不见的换行符 ‘\\n’ 来结束的，它所对应的整数值为 10。像 hello.c 这样只由 ASCII) Tj
T*
(字符构成的文件称为文本文件，所有其他文件都称为二进制文件。) Tj
T*
() Tj
T*
(hello.c 的表示方法说明了一个基本思想∶系统中所有的信息——包括磁盘文件、内存中的程序、内存中存放的用户数据以及网络上传送的数据，都是由一串比特表示的。区分不同数据对象的唯一) Tj
T*
(方法是我们读到这些数据对象时的上下文。比如，在不同的上下文中，一个同样的字节序列可能表示一个整数、浮点数、字符串或者机器指令。) Tj
T*
(作为程序员，我们需要了解数字的机器表示方式，因为它们与实际的整数和实数是不同的。它们是对真值的有限近似值，有时候会有意想不到的行为表现。这方面的基本原理将在第 2 章中详细描述。) Tj
T*
() Tj
T*
(旁注 编程语言的起源) Tj
T*
() Tj
T*
() Tj
T*
(C 语言是贝尔实验室的 Dennis Ritchie 于 1969 年 ~ 1973 年间创建的。美国国家标准学会（American National Standards) Tj
T*
(Institute，ANSI）在 1989 年颁布了 ANSI C 的标准，后来 C 语言的标准化成了国际标准化组织（International) Tj
T*
(StandardsOrganization，ISO）的责任。这些标准定义了C语言和一系列函数库，即所谓的 C 标准库。Kernighan 和 Ritchie) Tj
T*
(在他们的经典著作中描述了 ANSI C，这本著作被人们满怀感情地称为 “K&R”【61】。用 Ritchic 的话来说【92】，C) Tj
T*
(语言是“古怪的、有缺陷的，但同时也是一个巨大的成功”。为什么会成功呢?) Tj
T*
() Tj
T*
(* C 语言与 Unix 操作系统关系密切。C 从一开始就是作为一种用于 Unix 系统的程序语言开发出来的。大部分 Unix) Tj
T*
(内核（操作系统的核心部分），以及所有支撑工具和函数库都是用 C 语言编写的。20 世纪 70 年代后期到 80 年代初期，Unix 风行于高等院校，许多人开始接触 C) Tj
T*
(语言并喜欢上它。因为 Unix 几乎全部是用 C 编写的，它可以很方便地移植到新的机器上，这种特点为 C 和 Unix 赢得了更为广泛的支持。) Tj
T*
(* C 语言小而简单。C语言的设计是由一个人而非一个协会掌控的，因此这是一个简洁明了、没有什么冗赘的设计。K&R 这本书用大量的例子和练习描述了完整的 C) Tj
T*
(语言及其标准库，而全书不过  261 页。C 语言的简单使它相对而言易于学习，也易于移植到不同的计算机上。) Tj
T*
(* C语言是为实践目的设计的。C 语言是设计用来实现 Unix 操作系统的。后来，其他人发现能够用这门语言无障碍地编写他们想要的程序。) Tj
T*
() Tj
T*
(C 语言是系统级编程的首选，同时它也非常适用于应用级程序的编写。然而，它也并非适用于所有的程序员和所有的情况。C 语言的指针是造成程序员困惑和程序错误的一个常见原因。同时，C) Tj
T*
(语言还缺乏对非常有用的抽象的显式支持，例如类、对象和异常。像 C++ 和 Java 这样针对应用级程序的新程序语言解决了这些问题。) Tj
T*
() Tj
T*
ET
endstream
endobj
355 0 obj
<< /Length 3934 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(================================================================================) Tj
T*
(1.2 程序被其他程序翻译成不同的格式) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(1.2 程序被其他程序翻译成不同的格式) Tj
T*
() Tj
T*
() Tj
T*
(hello 程序的生命周期是从一个高级 C 语言程序开始的，因为这种形式能够被人读懂。然而，为了在系统上运行 hello.c 程序，每条 C) Tj
T*
(语句都必须被其他程序转化为一系列的低级机器语言指令。然后这些指令按照一种称为可执行目标程序的格式打好包，并以二进制磁盘文件的形式存放起来。目标程序也称为可执行目标文件。) Tj
T*
() Tj
T*
(在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的∶) Tj
T*
() Tj
T*
(linux> gcc -o hello hello.c) Tj
T*
() Tj
T*
(在这里，GCC 编译器驱动程序读取源程序文件 hello.c，并把它翻译成一个可执行目标文件 hello。这个翻译过程可分为四个阶段完成，如图 1-3) Tj
T*
(所示。执行这四个阶段的程序（预处理器、编译器、汇编器和链接器）一起构成了编译系统（compilation system）。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-3 &#x7F16;&#x8BD1;&#x7CFB;&#x7EDF;]) Tj
T*
() Tj
T*
(* 预处理阶段。预处理器（cpp）根据以字符 \\# 开头的命令，修改原始的 C 程序。比如 hello.c 中第 1 行的#include 命令告诉预处理器读取系统头文件) Tj
T*
(stdio.h 的内容，并把它直接插入程序文本中。结果就得到了另一个 C 程序，通常是以 .i 作为文件扩展名。) Tj
T*
(* 编译阶段。编译器（cc1）将文本文件 hello.i 翻译成文本文件 hello.s，它包含一个汇编语言程序。该程序包含函数 main 的定义，如下所示∶) Tj
T*
(* ```bash) Tj
T*
(  main:) Tj
T*
(      subq $8, %rsp) Tj
T*
(      movl $.LC0, %edi) Tj
T*
(      call puts) Tj
T*
(      movl $0, %eax) Tj
T*
(      addq $8, %rsp) Tj
T*
(      ret) Tj
T*
() Tj
T*
(      定义中 2～7 行的每条语句都以一种文本格式描述了一条低级机器语言指令。汇编语言是非常有用的，因为它为不同高级语言的不同编译器提供了通用的输出语言。例如，C编译器和) Tj
T*
(      Fortran 编译器产生的输出文件用的都是一样的汇编语言。) Tj
T*
() Tj
T*
(    * **汇编阶段。**接下来，汇编器（as）将 hello.s 翻译成机器语言指令，把这些指令打包成一种叫做**可重定位目标程序**（relocatable object) Tj
T*
(    program）的格式，并将结果保存在目标文件 hello.o 中。hello.o 文件是一个二进制文件，它包含的 17 个字节是函数 main) Tj
T*
(    的指令编码。如果我们在文本编辑器中打开 hello.o文件，将看到一堆乱码。) Tj
T*
(    * **链接阶段。**请注意，hello 程序调用了 printf 函数，它是每个 C 编译器都提供的标准 C 库中的一个函数。printf 函数存在于一个名为) Tj
T*
(    printf.o 的单独的预编译好了的目标文件中，而这个文件必须以某种方式合并到我们的 hello.o 程序中。链接器（ld）就负责处理这种合并。结果就得到 hello) Tj
T*
(    文件，它是一个**可执行目标文件**（或者简称为**可执行文件**），可以被加载到内存中，由系统执行。) Tj
T*
() Tj
T*
(    ### 旁注 - GNU项目) Tj
T*
() Tj
T*
(    GCC 是 GNU（GNU 是GNU's Not Unix 的缩写）项目开发出来的众多有用工具之一。GNU 项目是 1984 年由 Richard Stallman) Tj
T*
(    发起的一个免税的慈善项目。该项目的目标非常宏大，就是开发出一个完整的类 Unix 的系统，其源代码能够不受限制地被修改和传播。GNU 项目已经开发出了一个包含 Unix) Tj
T*
ET
endstream
endobj
356 0 obj
<< /Length 4934 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    操作系统的所有主要部件的环境，但内核除外，内核是由 Linux 项目独立发展而来的。GNU 环境包括 EMACS 编辑器、GCC 编译器、GDB) Tj
T*
(    调试器、汇编器、链接器、处理二进制文件的工具以及其他一些部件。GCC 编译器已经发展到支持许多不同的语言，能够为许多不同的机器生成代码。支持的语言包括) Tj
T*
(    C、C++、Fortran、Java、Pascal、面向对象 C 语言（Objective-C）和 Ada。) Tj
T*
() Tj
T*
(    GNU 项目取得了非凡的成绩，但是却常常被忽略。现代开放源码运动（通常和 Linux 联系在一起）的思想起源是 GNU 项目中自由软件（free) Tj
T*
(    software）的概念。（此处的free 为自由言论（free speech）中的“自由”之意，而非免费啤酒（free beer）中的“免费”之意。）而且，Linux) Tj
T*
(    如此受欢迎在很大程度上还要归功于 GNU 工具，它们给 Linux 内核提供了环境。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(1.3 了解编译系统如何工作是大有益处的) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(1.3 了解编译系统如何工作是大有益处的) Tj
T*
() Tj
T*
() Tj
T*
(对于像 hello.c 这样简单的程序，我们可以依靠编译系统生成正确有效的机器代码。但是，有一些重要的原因促使程序员必须知道编译系统是如何工作的。) Tj
T*
() Tj
T*
(* 优化程序性能。现代编译器都是成熟的工具，通常可以生成很好的代码。作为程序员，我们无须为了写出高效代码而去了解编译器的内部工作。但是，为了在 C) Tj
T*
(程序中做出好的编码选择，我们确实需要了解一些机器代码以及编译器将不同的 C 语句转化为机器代码的方式。比如，一个 switch 语句是否总是比一系列的 if-else) Tj
T*
(语句高效得多？一个函数调用的开销有多大？while 循环比 for 循环更有效吗？指针引用比数组索引更有效吗？为什么将循环求和的结果放到一个本地变量中，会比将其放到一个通过引用传递) Tj
T*
(过来的参数中，运行起来快很多呢？为什么我们只是简单地重新排列一下算术表达式中的括号就能让函数运行得更快?？) Tj
T*
() Tj
T*
(  在第3章中，我们将介绍 x86-64，最近几代 Linux、Macintosh 和 Windows 计算机的机器语言。我们会讲述编译器是怎样把不同的 C) Tj
T*
(  语言结构翻译成这种机器语言的。在第 5 章中，你将学习如何通过简单转换C语言代码，帮助编译器更好地完成工作，从而调整 C 程序的性能。在第 6) Tj
T*
(  章中，你将学习存储器系统的层次结构特性，C 语言编译器如何将数组存放在内存中，以及 C 程序又是如何能够利用这些知识从而更高效地运行。) Tj
T*
() Tj
T*
(* 理解链接时出现的错误。根据我们的经验，一些最令人困扰的程序错误往往都与链接器操作有关，尤其是当你试图构建大型的软件系统时。比如，链接器报告说它无法解析一个引用，这是什么意思？静) Tj
T*
(态变量和全局变量的区别是什么？如果你在不同的 C) Tj
T*
(文件中定义了名字相同的两个全局变量会发生什么？静态库和动态库的区别是什么？我们在命令行上排列库的顺序有什么影响？最严重的是，为什么有些链接错误直到运行时才会出现？在第 7) Tj
T*
(章中，你将得到这些问题的答案。) Tj
T*
(* 避免安全漏洞。多年来，缓冲区溢出错误是造成大多数网络和 Internet 服务器上安全漏洞的主要原因。存在这些错误是因为很少有程序员能够理解需要限制从不受信任的源接收数据的数量) Tj
T*
(和格式。学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起的后果。作为学习汇编语言的一部分，我们将在第 3) Tj
T*
(章中描述堆栈原理和缓冲区溢出错误。我们还将学习程序员、编译器和操作系统可以用来降低攻击威胁的方法。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(1.4 处理器读并解释储存在内存中的指令) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(1.4 处理器读并解释储存在内存中的指令) Tj
T*
() Tj
T*
() Tj
T*
(此刻，hello.c 源程序已经被编译系统翻译成了可执行目标文件 hello，并被存放在磁盘上。要想在 Unix 系统上运行该可执行文件，我们将它的文件名输入到称为 shell) Tj
T*
(的应用程序中∶) Tj
T*
() Tj
T*
ET
endstream
endobj
357 0 obj
<< /Length 3909 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    linux> ./hello) Tj
T*
(    hello, world) Tj
T*
(    linux>) Tj
T*
() Tj
T*
(shell 是一个命令行解释器，它输出一个提示符，等待输入一个命令行，然后执行这个命令。如果该命令行的第一个单词不是一个内置的 shell 命令，那么 shell) Tj
T*
(就会假设这是一个可执行文件的名字，它将加载并运行这个文件。所以在此例中，shell 将加载并运行 hello 程序，然后等待程序终止。hello) Tj
T*
(程序在屏幕上输出它的消息，然后终止。shell 随后输出一个提示符，等待下一个输入的命令行。) Tj
T*
() Tj
T*
(1.4.1 系统的硬件组成) Tj
T*
() Tj
T*
() Tj
T*
(为了理解运行 hello 程序时发生了什么，我们需要了解一个典型系统的硬件组织，如图 1-4 所示。这张图是近期 Intel) Tj
T*
(系统产品族的模型，但是所有其他系统也有相同的外观和特性。现在不要担心这张图很复杂——我们将在本书分阶段对其进行详尽的介绍。) Tj
T*
() Tj
T*
(1. 总线) Tj
T*
() Tj
T*
() Tj
T*
(贯穿整个系统的是一组电子管道，称作总线，它携带信息字节并负责在各个部件间传递。通常总线被设计成传送定长的字节块，也就是字（word）。字中的字节数（即字长）是一个基本的系统参数，各) Tj
T*
(个系统中都不尽相同。现在的大多数机器字长要么是 4 个字节（32 位），要么是 8 个字节（64) Tj
T*
(位）。本书中，我们不对字长做任何固定的假设。相反，我们将在需要明确定义的上下文中具体说明一个“字”是多大。) Tj
T*
() Tj
T*
(2. I/O 设备) Tj
T*
() Tj
T*
() Tj
T*
(I/O（输入/输出）设备是系统与外部世界的联系通道。我们的示例系统包括四个 I/O) Tj
T*
(设备∶作为用户输入的键盘和鼠标，作为用户输出的显示器，以及用于长期存储数据和程序的磁盘驱动器（简单地说就是磁盘）。最开始，可执行程序 hello 就存放在磁盘上。) Tj
T*
() Tj
T*
(每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连。控制器和适配器之间的区别主要在于它们的封装方式。控制器是 I/O) Tj
T*
(设备本身或者系统的主印制电路板（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论如何，它们的功能都是在 I/O 总线和 I/O 设备之间传递信息。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 1-4 一个典型系统的硬件组成) Tj
T*
(>) Tj
T*
(> CPU：中央处理单元；ALU：算术/逻辑单元；PC：程序计数器；USB：通用串行总线) Tj
T*
() Tj
T*
(第 6 章会更多地说明磁盘之类的 I/O 设备是如何工作的。在第 10 章中，你将学习如何在应用程序中利用 Unix I/O) Tj
T*
(接口访问设备。我们将特别关注网络类设备，不过这些技术对于其他设备来说也是通用的。) Tj
T*
() Tj
T*
(3. 主存) Tj
T*
() Tj
T*
() Tj
T*
(主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据。从物理上来说，主存是由一组动态随机存取存储器（DRAM）芯片组成的。从逻辑上来说，存储器是一个线性的字节数) Tj
T*
(组，每个字节都有其唯一的地址（数组索引），这些地址是从零开始的。一般来说，组成程序的每条机器指令都由不同数量的字节构成。与 C) Tj
T*
(程序变量相对应的数据项的大小是根据类型变化的。比如，在运行 Linux 的 x86-64 机器上，short 类型的数据需要 2 个字节，int 和 float 类型需要 4) Tj
T*
(个字节，而 long 和 double 类型需要 8 个字节。 第 6 章将具体介绍存储器技术，比如 DRAM 芯片是如何工作的，它们又是如何组合起来构成主存的。) Tj
T*
ET
endstream
endobj
358 0 obj
<< /Length 4707 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(4. 处理器) Tj
T*
() Tj
T*
() Tj
T*
(中央处理单元（CPU），简称处理器，是解释（或执行）存储在主存中指令的引擎。处理器的核心是一个大小为一个字的存储设备（或寄存器），称为程序计数器（PC）。在任何时刻，PC) Tj
T*
(都指向主存中的某条机器语言指令（即含有该条指令的地址）。) Tj
T*
() Tj
T*
(PC 也普遍地被用来作为“个人计算机”的缩写。然面，两者之间的区别应该可以很清楚地从上下文中看出来。) Tj
T*
() Tj
T*
(从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器看上去是按照一个非常简单的指令执行模型来操作的，这个模型是由指) Tj
T*
(令集架构决定的。在这个模型中，指令按照严格的顺序执行，而执行一条指令包含执行一系列的步骤。处理器从程序计数器指向的内存处读取指令，解释指令中的位，执行该指令指示的简单操作，然后更新) Tj
T*
(PC，使其指向下一条指令，而这条指令并不一定和在内存中刚刚执行的指令相邻。) Tj
T*
() Tj
T*
(这样的简单操作并不多，它们围绕着主存、寄存器文件（register) Tj
T*
(file）和算术/逻辑单元（ALU）进行。寄存器文件是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。ALU) Tj
T*
(计算新的数据和地址值。下面是一些简单操作的例子，CPU 在指令的要求下可能会执行这些操作。) Tj
T*
() Tj
T*
(* 加载：从主存复制一个字节或者一个字到寄存器，以覆盖寄存器原来的内容。) Tj
T*
(* 存储：从寄存器复制一个字节或者一个字到主存的某个位置，以覆盖这个位置上原 来的内容。) Tj
T*
(* 操作：把两个寄存器的内容复制到 ALU，ALU 对这两个字做算术运算，并将结果存放到一个寄存器中，以覆盖该寄存器中原来的内容。) Tj
T*
(* 跳转：从指令本身中抽取一个字，并将这个字复制到程序计数器（PC）中，以覆盖 PC 中原来的值。) Tj
T*
() Tj
T*
( 处理器看上去是它的指令集架构的简单实现，但是实际上现代处理器使用了非常复杂的机制来加速程序的执行。因此，我们将处理器的指令集架构和处理器的微体系结构区分开来：指令集架构描述的是每) Tj
T*
( 条机器代码指令的效果；而微体系结构描述的是处理器实际上是如何实现的。在第 3 章研究机器代码时，我们考虑的是机器的指令集架构所提供的抽象性。第 4) Tj
T*
( 章将更详细地介绍处理器实际上是如何实现的。第 5 章用一个模型说明现代处理器是如何工作的，从而能预测和优化机器语言程序的性能。) Tj
T*
() Tj
T*
(1.4.2 运行 hello 程序) Tj
T*
() Tj
T*
() Tj
T*
(前面简单描述了系统的硬件组成和操作，现在开始介绍当我们运行示例程序时到底发生了些什么。在这里必须省略很多细节，稍后会做补充，但是现在我们将很满意于这种整体上的描述。) Tj
T*
(初始时，shell 程序执行它的指令，等待我们输人一个命令。当我们在键盘上输人字符串 “./hello” 后，shell 程序将字符逐一读入寄存器，再把它存放到内存中，如图 1-5) Tj
T*
(所示。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-5 &#x4ECE;&#x952E;&#x76D8;&#x4E0A;&#x8BFB;&#x53D6; hello) Tj
T*
(&#x547D;&#x4EE4;]) Tj
T*
() Tj
T*
(当我们在键盘上敲回车键时，shell 程序就知道我们已经结束了命令的输入。然后 shell 执行一系列指令来加载可执行的 hello 文件，这些指令将 hello) Tj
T*
(目标文件中的代码和数据从磁盘复制到主存。数据包括最终会被输出的字符串 “hello, world\\n”。) Tj
T*
() Tj
T*
(利用直接存储器存取（DMA，将在第 6 章中讨论）技术，数据可以不通过处理器而直接从磁盘到达主存。这个步骤如图 1-6 所示。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-6 &#x4ECE;&#x78C1;&#x76D8;&#x52A0;&#x8F7D;&#x53EF;&#x6267;&#x884C;&#x65) Tj
T*
(87;&#x4EF6;&#x5230;&#x4E3B;&#x5B58;]) Tj
T*
() Tj
T*
(一旦目标文件 hello 中的代码和数据被加载到主存，处理器就开始执行 hello 程序的 main 程序中的机器语言指令。这些指令将 “hello, world\\n”) Tj
T*
(字符串中的字节从主存复制到寄存器文件，再从寄存器文件中复制到显示设备，最终显示在屏幕上。这个步骤如图 1-7 所示。) Tj
T*
ET
endstream
endobj
359 0 obj
<< /Length 4760 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
([Image: &#x56FE; 1-7 &#x5C06;&#x8F93;&#x51FA;&#x5B57;&#x7B26;&#x4E32;&#x4ECE;&#x5B58;&#x50) Tj
T*
(A8;&#x5668;&#x5199;&#x5230;&#x663E;&#x793A;&#x5668;]) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(1.5 高速缓存至关重要) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(1.5 高速缓存至关重要) Tj
T*
() Tj
T*
() Tj
T*
(这个简单的示例揭示了一个重要的问题，即系统花费了大量的时间把信息从一个地方挪到另一个地方。hello) Tj
T*
(****程序的机器指令最初是存放在磁盘上，当程序加载时，它们被复制到主存；当处理器运行程序时，指令又从主存复制到处理器。相似地，数据串 “hello, world\\n” 开始时在磁) Tj
T*
(盘上，然后被复制到主存，最后从主存上复制到显示设备。从程序员的角度来看，这些复制就是开销，减慢了程序“真正”的工作。因此，系统设计者的一个主要目标就是使这些复制操作尽可能快地完成。) Tj
T*
() Tj
T*
(根据机械原理，较大的存储设备要比较小的存储设备运行得慢，而快速设备的造价远高于同类的低速设备。比如说，一个典型系统上的磁盘驱动器可能比主存大 1000) Tj
T*
(倍，但是对处理器而言，从磁盘驱动器上读取一个字的时间开销要比从主存中读取的开销大 1000 万倍。) Tj
T*
() Tj
T*
(类似地，一个典型的寄存器文件只存储几百字节的信息，而主存里可存放几十亿字节。然而，处理器从寄存器文件中读数据比从主存中读取几乎要快 100) Tj
T*
(倍。更麻烦的是，随着这些年半导体技术的进步，这种处理器与主存之间的差距还在持续增大。加快处理器的运行速度比加快主存的运行速度要容易和便宜得多。) Tj
T*
(针对这种处理器与主存之间的差异，系统设计者采用了更小更快的存储设备，称为高速缓存存储器（cache memory，简称为 cache) Tj
T*
(或高速缓存），作为暂时的集结区域，存放处理器近期可能会需要的信息。图 1-8 展示了一个典型系统中的高速缓存存储器。位于处理器芯片上的 L1) Tj
T*
(高速缓存的容量可以达到数万字节，访问速度几乎和访问寄存器文件一样快。一个容量为数十万到数百万字节的更大的 L2 高速缓存通过一条特殊的总线连接到处理器。进程访问 L2) Tj
T*
(高速缓存的时间要比访问 L1 高速缓存的时间长 5 倍，但是这仍然比访问主存的时间快 5~10 倍。L1 和 L2) Tj
T*
(高速缓存是用一种叫做静态随机访问存储器（SRAM）的硬件技术实现的。比较新的、处理能力更强大的系统甚至有三级高速缓存∶L1、L2 和 L3。系统可以获得一个很大的存储器，同时访问速) Tj
T*
(度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据，大部分的内存操作都能在快速的高速缓存中完成。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-8 &#x9AD8;&#x901F;&#x7F13;&#x5B58;&#x5B58;&#x50A8;&#x5668;]) Tj
T*
() Tj
T*
(本书得出的重要结论之一就是，意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。你将在第 6 章里学习这些重要的设备以及如何利用它们。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(1.6 存储设备形成层次结构) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(1.6 存储设备形成层次结构) Tj
T*
() Tj
T*
() Tj
T*
(在处理器和一个较大较慢的设备（例如主存）之间插入一个更小更快的存储设备（例如高速缓存）的想法已经成为一个普遍的观念。实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构) Tj
T*
(，如图 1-9 所示。在这个层次结构中，从上至下，设备的访问速度越来越慢、容量越来越大，并且每字节的造价也越来越便宜。寄存器文件在层次结构中位于最顶部，也就是第 0 级或记为) Tj
T*
(L0。这里我们展示的是三层高速缓存 L1 到 L3，占据存储器层次结构的第 1 层到第 3 层。主存在第 4 层，以此类推。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-9 &#x4E00;&#x4E2A;&#x5B58;&#x50A8;&#x5668;&#x5C42;&#x6B21;&#x7ED3;&#x67) Tj
T*
(84;&#x7684;&#x793A;&#x4F8B;]) Tj
T*
ET
endstream
endobj
360 0 obj
<< /Length 4629 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是 L1 的高速缓存，L1 是 L2 的高速缓存，L2 是 L3 的高速缓存，L3) Tj
T*
(是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。) Tj
T*
(正如可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。第 6 章将更详细地讨论这个问题。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(1.7 操作系统管理硬件) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(1.7 操作系统管理硬件) Tj
T*
() Tj
T*
() Tj
T*
(让我们回到 hello 程序的例子。当 shell 加载和运行 hello 程序时，以及 hello 程序输出自己的消息时，shell  和 hello) Tj
T*
(程序都没有直接访问键盘、显示器、磁盘或者主存。取而代之的是，它们依靠操作系统提供的服务。我们可以把操作系统看成是应用程序和硬件之间插入的一层软件，如图 1-10) Tj
T*
(所示。所有应用程序对硬件的操作尝试都必须通过操作系统。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-10) Tj
T*
(&#x8BA1;&#x7B97;&#x673A;&#x7CFB;&#x7EDF;&#x7684;&#x5206;&#x5C42;&#x89C6;&#x56FE;]) Tj
T*
() Tj
T*
(操作系统有两个基本功能∶（1）防止硬件被失控的应用程序滥用；（2）向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。操作系统通过几个基本的抽象概念（进程、虚拟内) Tj
T*
(存和文件）来实现这两个功能。如图 1-11 所示，文件是对 I/O 设备的抽象表示，虚拟内存是对主存和磁盘 I/O 设备的抽象表示，进程则是对处理器、主存和 I/O) Tj
T*
(设备的抽象表示。我们将依次讨论每种抽象表示。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-11) Tj
T*
(&#x64CD;&#x4F5C;&#x7CFB;&#x7EDF;&#x63D0;&#x4F9B;&#x7684;&#x62BD;&#x8C61;&#x8868;&#x793A;]) Tj
T*
() Tj
T*
(旁注 - Unix、Posix 和标准 Unix 规范) Tj
T*
() Tj
T*
() Tj
T*
(20 世纪 60 年代是大型、复杂操作系统盛行的年代，比如 IBM 的 OS/360 和 Honey-well 的 Multics 系统。OS/360) Tj
T*
(是历史上最成功的软件项目之一，而 Multics 虽然持续存在了多年，却从来没有被广泛应用过。贝尔实验室曾经是 Multics) Tj
T*
(项目的最初参与者，但是因为考虑到该项目的复杂性和缺乏进展而于 1969 年退出。鉴于 Mutics 项目不愉快的经历，一群贝尔实验室的研究人员——Ken) Tj
T*
(Thompson、Dennis Ritchie、Doug Mcllroy 和 Joe Ossanna，从 1969 年开始在 DEC PDP-7) Tj
T*
(计算机上完全用机器语言编写了一个简单得多的操作系统。这个新系统中的很多思想，比如层次文件系统、作为用户级进程的 shell 概念，都是来自于) Tj
T*
(Multics，只不过在一个更小、更简单的程序包里实现。1970 年，Brian Kernighan 给新系统命名为 “Unix”，这也是一个双关语，暗指 “Multics”) Tj
T*
(的复杂性。1973 年用 C 重新编写其内核，1974 年，Unix 开始正式对外发布【93】。) Tj
T*
() Tj
T*
(贝尔实验室以慷慨的条件向学校提供源代码，所以 Unix 在大专院校里获得了很多支持并得以持续发展。最有影响的工作发生在 20 世纪 70 年代晚期到 80) Tj
T*
(年代早期，在美国加州大学伯克利分校，研究人员在一系列发布版本中增加了虚拟内存和 Internet 协议，称为 Unix 4.xBSD（Berkeley Software) Tj
T*
(Distribution）。与此同时，贝尔实验室也在发布自己的版本，称为 System V Unix。其他厂商的版本，比如 Sun Microsystems 的 Solaris) Tj
T*
(系统，则是从这些原始的 BSD 和 System V 版本中衍生而来。) Tj
T*
() Tj
T*
(20 世纪 80 年代中期，Unix) Tj
T*
(厂商试图通过加入新的、往往不兼容的特性来使它们的程序与众不同，麻烦也就随之而来了。为了阻止这种趋势，IEEE（电气和电子工程师协会）开始努力标准化 Unix 的开发，后来由) Tj
T*
(Richard Stallman 命名为 “Posix”。结果就得到了一系列的标准，称作 Posix 标准。这套标准涵盖了很多方面，比如 Unix 系统调用的 C) Tj
T*
ET
endstream
endobj
361 0 obj
<< /Length 5394 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(语言接口、shell 程序和工具、线程及网络编程。最近，一个被称为“标准 Unix 规范”的独立标准化工作已经与 Posix 一起创建了统一的 Unix) Tj
T*
(系统标准。这些标准化工作的结果是 Unix 版本之间的差异已经基本消失。) Tj
T*
() Tj
T*
(1.7.1 进程) Tj
T*
() Tj
T*
() Tj
T*
(像 hello 这样的程序在现代系统上运行时，操作系统会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和 I/O 设备。处理器看上去就像在不间断地) Tj
T*
(一条接一条地执行程序中的指令，即该程序的代码和数据是系统内存中唯一的对象。这些假象是通过进程的概念来实现的，进程是计算机科学中最重要和最成功的概念之一。) Tj
T*
() Tj
T*
(进程是操作系统对一个正在运行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。而并发运行，则是说一个进程的指令和另一个进程的指令是交错执行的。在) Tj
T*
(大多数系统中，需要运行的进程数是多于可以运行它们的 CPU 个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器同时能够执行多个程序。无论是在单核还是多核系统中，一个) Tj
T*
(CPU 看上去都像是在并发地执行多个进程，这是通过处理器在进程间切换来实现的。操作系统实现这种交错执行的机制称为上下文切换。为了简化讨论，我们只考虑包含一个 CPU) Tj
T*
(的单处理器系统的情况。我们会在 1.9.2 节中讨论多处理器系统。) Tj
T*
() Tj
T*
(操作系统保持跟踪进程运行所需的所有状态信息。这种状态，也就是上下文，包括许多信息，比如 PC 和寄存器文件的当前值，以及主存的内容。在任何一个时刻，单处理器系统都只能执行一个进程的) Tj
T*
(代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进行上下文切换，即保存当前进程的上下文、恢复新进程的上下文，然后将控制权传递到新进程。新进程就会从它上次停止的地方开) Tj
T*
(始。图 1-12 展示了示例 hello 程序运行场景的基本理念。) Tj
T*
() Tj
T*
(示例场景中有两个并发的进程∶shell 进程和 hello 进程。最开始，只有 shell 进程在运行，即等待命令行上的输入。当我们让它运行 hello 程序时，shell) Tj
T*
(通过调用一个专门的函数，即系统调用，来执行我们的请求，系统调用会将控制权传递给操作系统。操作系统保存 shell 进程的上下文，创建一个新的 hello) Tj
T*
(进程及其上下文，然后将控制权传给新的 hello 进程。hello 进程终止后，操作系统恢复 shell 进程的上下文，并将控制权传回给它，shell) Tj
T*
(进程会继续等待下一个命令行输入。) Tj
T*
() Tj
T*
(如图 1-12 所示，从一个进程到另一个进程的转换是由操作系统内核（kernel）管理的。内核是操作系统代码常驻主存的部分。当应用程序需要操作系统的某些操作时，比如读写文件，它就执) Tj
T*
(行一条特殊的系统调用（system) Tj
T*
(call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。注意，内核不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的集合。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-12 &#x8FDB;&#x7A0B;&#x7684;&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;]) Tj
T*
() Tj
T*
(实现进程这个抽象概念需要低级硬件和操作系统软件之间的紧密合作。我们将在第 8 章中揭示这项工作的原理，以及应用程序是如何创建和控制它们的进程的。) Tj
T*
() Tj
T*
(1.7.2 线程) Tj
T*
() Tj
T*
() Tj
T*
(尽管通常我们认为一个进程只有单一的控制流，但是在现代系统中，一个进程实际上可以由多个称为线程的执行单元组成，每个线程都运行在进程的上下文中，并共享同样的代码和全局数据。由于网络服务) Tj
T*
(器中对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程一般来说都比进程更高效。当有多处理器可用的时候，多线程也是一种使得程序可以运) Tj
T*
(行得更快的方法，我们将在 1.9.2 节中讨论这个问题。在第 12 章中，你将学习并发的基本概念，包括如何写线程化的程序。) Tj
T*
() Tj
T*
(1.7.3 虚拟内存) Tj
T*
() Tj
T*
() Tj
T*
(虚拟内存是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致的，称为虚拟地址空间。图 1-13 所示的是 Linux) Tj
T*
(进程的虚拟地址空间（其他 Unix 系统的设计也与此类似）。在 Linux) Tj
T*
(中，地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。地址空间的底部区域存放用户进程定义的代码和数据。请注意，图中的地址是从下往上增大的。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-13) Tj
T*
ET
endstream
endobj
362 0 obj
<< /Length 3977 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(&#x8FDB;&#x7A0B;&#x7684;&#x865A;&#x62DF;&#x5730;&#x5740;&#x7A7A;&#x95F4;]) Tj
T*
() Tj
T*
(每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。在本书的后续章节你将学到更多有关这些区的知识，但是先简单了解每一个区是非常有益的。我们从最低的地址开始，逐步) Tj
T*
(向上介绍。) Tj
T*
() Tj
T*
(* 程序代码和数据。对所有的进程来说，代码是从同一固定地址开始，紧接着的是和 C) Tj
T*
(全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的，在示例中就是可执行文件 hello。在第 7 章我们研究链接和加载时，你会学习更多有关地址空间的内容。) Tj
T*
(* 堆。代码和数据区后紧随着的是运行时堆。代码和数据区在进程一开始运行时就被指定了大小，与此不同，当调用像 malloc 和 free 这样的 C) Tj
T*
(标准库函数时，堆可以在运行时动态地扩展和收缩。在第 9 章学习管理虚拟内存时，我们将更详细地研究堆。) Tj
T*
(* 共享库。大约在地址空间的中间部分是一块用来存放像 C 标准库和数学库这样的共享库的代码和数据的区域。共享库的概念非常强大，也相当难懂。在第 7) Tj
T*
(章介绍动态链接时，将学习共享库是如何工作的。) Tj
T*
(* 栈。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回) Tj
T*
(时，栈就会收缩。在第 3 章中将学习编译器是如何使用栈的。) Tj
T*
(* 内核虚拟内存。地址空间顶部的区域是为内核保留的。不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。相反，它们必须调用内核来执行这些操作。) Tj
T*
() Tj
T*
(虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。第 9) Tj
T*
(章将解释它如何工作，以及为什么对现代系统的运行如此重要。) Tj
T*
() Tj
T*
(1.7.4 文件) Tj
T*
() Tj
T*
() Tj
T*
(文件就是字节序列，仅此而已。每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以看成是文件。系统中的所有输入输出都是通过使用一小组称为 Unix I/O) Tj
T*
(的系统函数调用读写文件来实现的。) Tj
T*
() Tj
T*
(文件这个简单而精致的概念是非常强大的，因为它向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的 I/O) Tj
T*
(设备。例如，处理磁盘文件内容的应用程序员可以非常幸福，因为他们无须了解具体的磁盘技术。进一步说，同一个程序可以在使用不同磁盘技术的不同系统上运行。你将在第 10 章中学习 Unix) Tj
T*
(I/O。) Tj
T*
() Tj
T*
(旁注 - Linux项目) Tj
T*
() Tj
T*
() Tj
T*
(1991年8月，芬兰研究生 Linus Torvalds 谨慎地发布了一个新的类 Unix 的操作系统内核，内容如下。) Tj
T*
() Tj
T*
(> 来自∶ torvalds@klaava.Helsinki.FI（Linus Benedict Torvalds）) Tj
T*
(>) Tj
T*
(> 新闻组∶comp.os.minix) Tj
T*
(>) Tj
T*
(> 主题∶在 minix中你最想看到什么？) Tj
T*
(>) Tj
T*
(> 摘要∶关于我的新操作系统的小调查) Tj
T*
(>) Tj
T*
(> 时间∶1991 年 8 月 25 日 20:57:08 GMT) Tj
T*
(>) Tj
T*
(> 每个使用 minix 的朋友，你们好。) Tj
T*
(>) Tj
T*
(> 我正在做一个（免费的）用在 386（486）AT 上的操作系统（只是业余爱好，它不会像 GNU 那样庞大和专业）。这个想法自 4) Tj
T*
ET
endstream
endobj
363 0 obj
<< /Length 4108 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(月份就开始酝酿，现在快要完成了。我希望得到各位对 minix 的任何反馈意见，因为我的操作系统在某些方面与它相类似（其中包括相同的文件系统的物理设计（因为某些实际的原 因））。) Tj
T*
(>) Tj
T*
(> 我现在已经移植了 bash（1.08）和) Tj
T*
(gc（1.40），并且看上去能运行。这意味着我需要几个月的时间来让它变得更实用一些，并且，我想要知道大多数人想要什么特性。欢迎任何建议，但是我无法保证我能实现它们。:-\\\)) Tj
T*
(>) Tj
T*
(> Linus \\\(torvalds@kruna.helsinki.fi\\\)) Tj
T*
() Tj
T*
(就像 Torvalds 所说的，他创建 Linux 的起点是 Minix，由 Andrew S. Tanenbaum 出于教育目的开发的一个操作系统【113】。) Tj
T*
(接下来，如他们所说，这就成了历史。Linux 逐渐发展成为一个技术和文化现象。通过和 GNU 项目的力量结合，Linux 项目发展成了一个完整的、符合 Posix 标准的 Unix) Tj
T*
(操作系统的版本，包括内核和所有支撑的基础设施。从手持设备到大型计算机，Linux 在范围如此广泛的计算机上得到了应用。IBM 的一个工作组甚至把 Linux 移植到了一块腕表中！) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(1.8 系统之间利用网络通信) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(1.8 系统之间利用网络通信) Tj
T*
() Tj
T*
() Tj
T*
(系统漫游至此，我们一直是把系统视为一个孤立的硬件和软件的集合体。实际上，现代系统经常通过网络和其他系统连接到一起。从一个单独的系统来看，网络可视为一个 I/O 设备，如图 1-14) Tj
T*
(所示。当系统从主存复制一串字节到网络适配器时，数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取从其他机器发送来的数据，并把数据复制到自己的主存。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-14 &#x7F51;&#x7EDC;&#x4E5F;&#x662F;&#x4E00;&#x79CD; I/O) Tj
T*
(&#x8BBE;&#x5907;]) Tj
T*
() Tj
T*
(随着 Internet 这样的全球网络的出现，从一台主机复制信息到另外一台主机已经成为计算机系统最重要的用途之一。比如，像电子邮件、即时通信、万维网、FTP 和 telnet) Tj
T*
(这样的应用都是基于网络复制信息的功能。 回到 hello 示例，我们可以使用熟悉的 telnet 应用在一个远程主机上运行 hello 程序。假设用本地主机上的 telnet) Tj
T*
(客户端连接远程主机上的 telnet 服务器。在我们登录到远程主机并运行 shell 后，远端的 shell 就在等待接收输入命令。此后在远端运行 hello 程序包括如图) Tj
T*
(1-15  所示的五个基本步骤。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-15 &#x5229;&#x7528; telnet) Tj
T*
(&#x901A;&#x8FC7;&#x7F51;&#x7EDC;&#x8FDC;&#x7A0B;&#x8FD0;&#x884C; hello]) Tj
T*
() Tj
T*
(当我们在 telnet 客户端键入 “hello” 字符串并敲下回车键后，客户端软件就会将这个字符串发送到 telnet 的服务器。telnet) Tj
T*
(服务器从网络上接收到这个字符串后，会把它传递给远端 shell 程序。接下来，远端 shell 运行 hello 程序，并将输出行返回给 telnet 服务器。最后，telnet) Tj
T*
(服务器通过网络把输出串转发给 telnet 客户端，客户端就将输出串输出到我们的本地终端上。 这种客户端和服务器之间交互的类型在所有的网络应用中是非常典型的。在第 11) Tj
T*
(章中，你将学会如何构造网络应用程序，并利用这些知识创建一个简单的 Web 服务器。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(1.9 重要主题) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(1.9 重要主题) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
364 0 obj
<< /Length 3729 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(在此，小结一下我们旋风式的系统漫游。这次讨论得出一个很重要的观点，那就是系统不仅仅只是硬件。系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的最终目的。本书) Tj
T*
(的余下部分会讲述硬件和软件的详细内容，通过了解这些详细内容，你可以写出更快速、更可靠和更安全的程序。) Tj
T*
() Tj
T*
(作为本章的结束，我们在此强调几个贯穿计算机系统所有方面的重要概念。我们会在本书中的多处讨论这些概念的重要性。) Tj
T*
() Tj
T*
(1.9.1 Amdahl 定律) Tj
T*
() Tj
T*
() Tj
T*
(Gene Amdahl，计算领域的早期先锋之一，对提升系统某一部分性能所带来的效果做出了简单却有见地的观察。这个观察被称为 Amdahl 定律（Amdahl's) Tj
T*
(law）。该定律的主要思想是，当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。若系统执行某应用程序需要时间为$$T{old}$$) Tj
T*
(。假设系统某部分所需执行时间与该时间的比例为 $$\\alpha$$ ，而该部分性能提升比例为 $$k$$ 。即该部分初始所需时间为 $$\\alpha T{old}$$) Tj
T*
(，现在所需时间为 $$\(\\alpha T_{old}\) / k$$ 。因此，总的执行时间应为) Tj
T*
() Tj
T*
($$) Tj
T*
(T{new} = \(1-\\alpha\)T{old}+\(\\alpha T{old}\)/k=T{old}[\(1-\\alpha\)+\\alpha/k]) Tj
T*
($$) Tj
T*
() Tj
T*
(由此，可以计算加速比 $$S=T{old}/T{new}$$ 为) Tj
T*
() Tj
T*
($$) Tj
T*
(S=\\frac{1}{\(1-\\alpha\)+\\alpha / k} \\tag{1.1}) Tj
T*
($$) Tj
T*
() Tj
T*
(举个例子，考虑这样一种情况，系统的某个部分初始耗时比例为 60%（α =0.6），其加速比例因子为 3（k=3）。则我们可以获得的加速比为 1/\\[0.4+0.6/3\\]=1.67) Tj
T*
(倍。虽然我们对系统的一个主要部分做出了重大改进，但是获得的系统加速比却明显小于这部分的加速比。这就是 Amdahl) Tj
T*
(定律的主要观点——要想显著加速整个系统，必须提升全系统中相当大的部分的速度。) Tj
T*
() Tj
T*
(旁注 - 表示相对性能) Tj
T*
() Tj
T*
() Tj
T*
(性能提升最好的表示方法就是用比例的形式 $$T{old}/T{new}$$，其中，$$T{old}$$ 为原始系统所需时间， $$T{new}$$) Tj
T*
(为修改后的系统所需时间。如果有所改进，则比值应大于 1。我们用后缀 “×” 来表示比例，因此，“2.2×” 读作 “2.2 倍”。) Tj
T*
() Tj
T*
(表示相对变化更传统的方法是用百分比，这种方法适用于变化小的情况，但其定义是模糊的。应该等于 $$100 \\cdot \(T{old}-T{new}\)/T{new}$$ ，还是) Tj
T*
($$100 \\cdot \(T{old}-T{new}\)/T{old}$$，还是其他的值？此外，它对较大的变化也没有太大意义。与简单地说性能提升 2.2× 相比，“性能提升了) Tj
T*
(120%” 更难理解。) Tj
T*
() Tj
T*
(练习题 1.1) Tj
T*
() Tj
T*
() Tj
T*
(假设你是个卡车司机，要将土豆从爱达荷州的 Boise 运送到明尼苏达州的 Minneapolis，全程 2500 公里。在限速范围内，你估计平均速度为 100) Tj
T*
(公里/小时，整个行程需要 25 个小时。) Tj
T*
() Tj
T*
(A. 你听到新闻说蒙大拿州刚刚取消了限速，这使得行程中有 1500 公里卡车的速度可以为 150 公里/小时。那么这对整个行程的加速比是多少？) Tj
T*
() Tj
T*
(B. 你可以在 www.fasttrucks.com 网站上为自已的卡车买个新的涡轮增压器。网站现货供应各种型号，不过速度越快，价格越高。如果想要让整个行程的加速比为) Tj
T*
ET
endstream
endobj
365 0 obj
<< /Length 3161 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(1.67×，那么你必须以多快的速度通过蒙大拿州？) Tj
T*
() Tj
T*
(该问题说明 Amdahl 定律不仅仅适用于计算机系统。) Tj
T*
() Tj
T*
(A. 根据公式 1.1，有 α=0.6，k=1.5。更直接地说，在蒙大拿行驶的 1500 公里需要10个小时，而其他行程也需要 10 个小时。则加速比为) Tj
T*
(25/\\\(10＋10\\\)=1.25×。) Tj
T*
() Tj
T*
(B. 根据公式 1.1，有 α=0.6，要求 S=1.67，则可算出 k。更直接地说，要使行程加速度达到 1.67×，我们必须把全程时间减少到 15 个小时。蒙大拿以外仍要求为) Tj
T*
(10 小时，因此，通过蒙大拿的时间就为 5 个小时。这就要求行驶速度为 300 公里/小时，对卡车来说这个速度太快了！) Tj
T*
() Tj
T*
(练习题 1.2) Tj
T*
() Tj
T*
() Tj
T*
(公司的市场部向你的客户承诺，下一个版本的软件性能将改进 2×。这项任务被分配给你。你已经确认只有 80% 的系统能够被改进，那么，这部分需要被改进多少（即 k) Tj
T*
(取何值）才能达到整体性能目标？) Tj
T*
() Tj
T*
(理解 Amdahl 定律最好的方法就是解决一些实例。本题要求你从特殊的角度来看公式 1.1。) Tj
T*
() Tj
T*
(本题是公式的简单应用。已知 S=2，α=0.8，则计算 k：) Tj
T*
() Tj
T*
($$) Tj
T*
(\\begin{align}) Tj
T*
(2 & = \\frac{1}{\(1-0.8\)+0.8/k}\\\\) Tj
T*
(0.4+1.6/k & = 1.0\\\\) Tj
T*
(k & = 2.67) Tj
T*
(\\end{align}) Tj
T*
($$) Tj
T*
() Tj
T*
(Amdahl 定律一个有趣的特殊情况是考虑 k 趋向于 ∞ 时的效果。这就意味着，我们可以取系统的某一部分将其加速到一个点，在这个点上，这部分花费的时间可以忽略不计。于是我们得到) Tj
T*
() Tj
T*
($$) Tj
T*
(S_{\\infty}=\\frac{1}{\(1-\\alpha\)} \\tag{1.2}) Tj
T*
($$) Tj
T*
() Tj
T*
(举个例子，如果 60% 的系统能够加速到不花时间的程度，我们获得的净加速比将仍只有 1/0.4=2.5×。) Tj
T*
() Tj
T*
(Amdahl 定律描述了改善任何过程的一般原则。除了可以用在加速计算机系统方面之外，它还可以用在公司试图降低刀片制造成本，或学生想要提高自己的绩点平均值等方面。也许它在计算机世界里) Tj
T*
(是最有意义的，在这里我们常常把性能提升 2 倍或更高的比例因子。这么高的比例因子只有通过优化系统的大部分组件才能获得。) Tj
T*
() Tj
T*
(1.9.2 并发和并行) Tj
T*
() Tj
T*
() Tj
T*
(数字计算机的整个历史中，有两个需求是驱动进步的持续动力：一个是我们想要计算机做得更多，另一个是我们想要计算机运行得更快。当处理器能够同时做更多的事情时，这两个因素都会改进。我们用的) Tj
T*
(术语并发（concurrency）是一个通用的概念，指一个同时具有多个活动的系统；而术语并行（parallelism）指的是用并发来使一个系统运行得更快。并行可以在计算机系统的多个) Tj
T*
(抽象层次上运用。在此，我们按照系统层次结构中由高到低的顺序重点强调三个层次。) Tj
T*
() Tj
T*
ET
endstream
endobj
366 0 obj
<< /Length 5400 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(1. 线程级并发) Tj
T*
() Tj
T*
() Tj
T*
(构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。使用线程，我们甚至能够在一个进程中执行多个控制流。自 20 世纪 60 年代初期出现时间共享以来，计) Tj
T*
(算机系统中就开始有了对并发执行的支持。传统意义上，这种并发执行只是模拟出来的，是通过使一台计算机在它正在执行的进程间快速切换来实现的，就好像一个杂耍艺人保持多个球在空中飞舞一样。这) Tj
T*
(种并发形式允许多个用户同时与系统交互，例如，当许多人想要从一个 Web 服务器获取页面时。它还允许一个用户同时从事多个任务，例如，在一个窗口中开启 Web) Tj
T*
(浏览器，在另一窗口中运行字处理器，同时又播放音乐。在以前，即使处理器必须在多个任务间切换，大多数实际的计算也都是由一个处理器来完成的。这种配置称为单处理器系统。) Tj
T*
() Tj
T*
(当构建一个由单操作系统内核控制的多处理器组成的系统时，我们就得到了一个多处理器系统。其实从 20 世纪 80) Tj
T*
(年代开始，在大规模的计算中就有了这种系统，但是直到最近，随着多核处理器和超线程（hyperthreading）的出现，这种系统才变得常见。图 1-16) Tj
T*
(给出了这些不同处理器类型的分类。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-16 &#x4E0D;&#x540C;&#x7684;&#x5904;&#x7406;&#x5668;&#x914D;&#x7F6E;&#x5) Tj
T*
(206;&#x7C7B;&#x3002;&#x968F;&#x7740;&#x591A;&#x6838;&#x5904;&#x7406;&#x5668;&#x548C;&#x8D8) Tj
T*
(5;&#x7EBF;&#x7A0B;&#x7684;&#x51FA;&#x73B0;&#xFF0C;&#x591A;&#x5904;&#x7406;&#x5668;&#x53D8;) Tj
T*
(&#x5F97;&#x666E;&#x904D;&#x4E86;]) Tj
T*
() Tj
T*
(多核处理器是将多个 CPU（称为“核”）集成到一个集成电路芯片上。图 1-17 描述的是一个典型多核处理器的组织结构，其中微处理器芯片有 4 个 CPU 核，每个核都有自己的 L1) Tj
T*
(和 L2 高速缓存，其中的 L1) Tj
T*
(高速缓存分为两个部分——一个保存最近取到的指令，另一个存放数据。这些核共享更高层次的高速缓存，以及到主存的接口。工业界的专家预言他们能够将几十个、最终会是上百个核做到一个芯片上。) Tj
T*
() Tj
T*
([Image: &#x56FE; 1-17) Tj
T*
(&#x591A;&#x6838;&#x5904;&#x7406;&#x5668;&#x7684;&#x7EC4;&#x7EC7;&#x7ED3;&#x6784;&#x3002;4 ) Tj
T*
(&#x4E2A;&#x5904;&#x7406;&#x5668;&#x6838;&#x96C6;&#x6210;&#x5728;&#x4E00;&#x4E2A;&#x82AF;&#) Tj
T*
(x7247;&#x4E0A;]) Tj
T*
() Tj
T*
(超线程，有时称为同时多线程（simultaneous multi-threading），是一项允许一个 CPU 执行多个控制流的技术。它涉及 CPU) Tj
T*
(某些硬件有多个备份，比如程序计数器和寄存器文件，而其他的硬件部分只有一份，比如执行浮点算术运算的单元。常规的处理器需要大约 20000) Tj
T*
(个时钟周期做不同线程间的转换，而超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。这使得 CPU) Tj
T*
(能够更好地利用它的处理资源。比如，假设一个线程必须等到某些数据被装载到高速缓存中，那 CPU 就可以继续去执行另一个线程。举例来说，Intel Core i7) Tj
T*
(处理器可以让每个核执行两个线程，所以一个 4 核的系统实际上可以并行地执行 8 个线程。) Tj
T*
() Tj
T*
(多处理器的使用可以从两方面提高系统性能。首先，它减少了在执行多个任务时模拟并发的需要。正如前面提到的，即使是只有一个用户使用的个人计算机也需要并发地执行多个活动。其次，它可以使应用) Tj
T*
(程序运行得更快，当然，这必须要求程序是以多线程方式来书写的，这些线程可以并行地高效执行。因此，虽然并发原理的形成和研究已经超过 50) Tj
T*
(年的时间了，但是多核和超线程系统的出现才极大地激发了一种愿望，即找到书写应用程序的方法利用硬件开发线程级并行性。第 12) Tj
T*
(章会更深入地探讨并发，以及使用并发来提供处理器资源的共享，使程序的执行允许有更多的并行。) Tj
T*
() Tj
T*
(2. 指令级并行) Tj
T*
() Tj
T*
() Tj
T*
(在较低的抽象层次上，现代处理器可以同时执行多条指令的属性称为指令级并行。早期的微处理器，如 1978 年的 Intel 8086，需要多个（通常是 3～10) Tj
T*
(个）时钟周期来执行一条指令。最近的处理器可以保持每个时钟周期 2～4 条指令的执行速率。其实每条指令从开始到结束需要长得多的时间，大约 20) Tj
T*
(个或者更多周期，但是处理器使用了非常多的聪明技巧来同时处理多达 100 条指令。在第 4 章中，我们会研究流水线（pipelining）的使用。在流水线中，将执行一条指令所需要的活) Tj
T*
(动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令的不同部分。我们会看到一个相当简单的硬件设计，它能够达到接近于一) Tj
T*
(个时钟周期一条指令的执行速率。) Tj
T*
() Tj
T*
ET
endstream
endobj
367 0 obj
<< /Length 4211 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(如果处理器可以达到比一个周期一条指令更快的执行速率，就称之为超标量（super-scalar）处理器。大多数现代处理器都支持超标量操作。第 5) Tj
T*
(章中，我们将描述超标量处理器的高级模型。应用程序员可以用这个模型来理解程序的性能。然后，他们就能写出拥有更高程度的指令级并行性的程序代码，因而也运行得更快。) Tj
T*
() Tj
T*
(3. 单指令、多数据并行) Tj
T*
() Tj
T*
() Tj
T*
(在最低层次上，许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据，即 SIMD 并行。例如，较新几代的 Intel 和 AMD) Tj
T*
(处理器都具有并行地对 8 对单精度浮点数（C 数据类型 float）做加法的指令。) Tj
T*
() Tj
T*
(提供这些 SIMD 指令多是为了提高处理影像、声音和视频数据应用的执行速度。虽然有些编译器会试图从 C 程序中自动抽取 SIMD) Tj
T*
(并行性，但是更可靠的方法是用编译器支持的特殊的向量数据类型来写程序，比如 GCC 就支持向量数据类型。作为对第 5 章中比较通用的程序优化描述的补充，我们在网络旁注) Tj
T*
(OPT：SIMD 中描述了这种编程方式。) Tj
T*
() Tj
T*
(1.9.3 计算机系统中抽象的重要性) Tj
T*
() Tj
T*
() Tj
T*
(抽象的使用是计算机科学中最为重要的概念之一。例如，为一组函数规定一个简单的应用程序接口（API）就是一个很好的编程习惯，程序员无须了解它内部的工作便可以使用这些代码。不同的编程语言) Tj
T*
(提供不同形式和等级的抽象支持，例如 Java 类的声明和C语言的函数原型。) Tj
T*
() Tj
T*
(我们已经介绍了计算机系统中使用的几个抽象，如图 1-18 所示。在处理器里，指令集架构提供了对实际处理器硬件的抽象。使用这个抽象，机器代码程序表现得就好像运行在一个一次只执行一条指) Tj
T*
(令的处理器上。底层的硬件远比抽象描述的要复杂精细，它并行地执行多条指令，但又总是与那个简单有序的模型保持一致。只要执行模型一样，不同的处理器实现也能执行同样的机器代码，而又提供不同) Tj
T*
(的开销和性能。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 1-18 计算机系统提供的一些抽象。计算机系统中的一个重大主题就是提供不同层次的抽象表示，来隐藏实际实现的复杂性) Tj
T*
() Tj
T*
(在学习操作系统时，我们介绍了三个抽象：文件是对 I/O 设备的抽象，虚拟内存是对程序存储器的抽象，而进程是对一个正在运行的程序的抽象。我们再增加一个新的抽象∶) Tj
T*
(虚拟机，它提供对整个计算机的抽象，包括操作系统、处理器和程序。虚拟机的思想是 IBM 在 20 世纪 60) Tj
T*
(年代提出来的，但是最近才显示出其管理计算机方式上的优势，因为一些计算机必须能够运行为不同的操作系统（例如，Microsoft Windows、MacOS 和) Tj
T*
(Linux）或同一操作系统的不同版本设计的程序。) Tj
T*
() Tj
T*
(在本书后续的章节中，我们会具体介绍这些抽象。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(1.10 小结) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(1.10 小结) Tj
T*
() Tj
T*
() Tj
T*
(计算机系统是由硬件和系统软件组成的，它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位，它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式，开始时是) Tj
T*
(ASCII 文本，然后被编译器和链接器翻译成二进制可执行文件。) Tj
T*
() Tj
T*
(处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/O 设备和 CPU 寄存器之间复制数据，所以将系统中的存储设备划分成层次结构——CPU) Tj
T*
ET
endstream
endobj
368 0 obj
<< /Length 4912 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(寄存器在顶部，接着是多层的硬件高速缓存存储器、DRAM 主存和磁盘存储器。在层次模型中，位于更高层的存储设备比低层的存储设备要更快，单位比特造价也更高。层次结构中较高层次的存储设备) Tj
T*
(可以作为较低层次设备的高速缓存。通过理解和运用这种存储层次结构的知识，程序员可以优化C程序的性能。) Tj
T*
() Tj
T*
(操作系统内核是应用程序和硬件之间的媒介。它提供三个基本的抽象∶1）文件是对 I/O 设备的抽象；2）虚拟内存是对主存和磁盘的抽象；3）进程是处理器、主存和 I/O 设备的抽象。) Tj
T*
() Tj
T*
(最后，网络提供了计算机系统之间通信的手段。从特殊系统的角度来看，网络就是一种 I/O 设备。) Tj
T*
() Tj
T*
(参考文献说明) Tj
T*
() Tj
T*
() Tj
T*
(Ritchie写了关于早期 C 和 Unix 的有趣的第一手资料【91，92】。Ritchie 和 Thompson 提供了最早出版的 Unix) Tj
T*
(资料【93】，Silberschatz、Galvin 和 Gagne【102】提供了关于 Unix 不同版本的详尽历史。GNU（www.gnu.org）和) Tj
T*
(Linux（www.linux.org）的网站上有大量的当前信息和历史资料。Posix 标准可以在线获得（www.unix.org）。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(第 2 章：信息的表示和处理) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(第 2 章：信息的表示和处理) Tj
T*
() Tj
T*
() Tj
T*
(第一部分：程序结构和执行) Tj
T*
() Tj
T*
() Tj
T*
(我们对计算机系统的探索是从学习计算机本身开始的，它由处理器和存储器子系统组成。在核心部分，我们需要方法来表示基本数据类型，比如整数和实数运算的近似值。然后，我们考虑机器级指令如何操) Tj
T*
(作这样的数据，以及编译器又如何将 C) Tj
T*
(程序翻译成这样的指令。接下来，研究几种实现处理器的方法，帮助我们更好地了解硬件资源如何被用来执行指令。一旦理解了编译器和机器级代码，我们就能了解如何通过编写 c) Tj
T*
(程序以及编译它们来最大化程序的性能。本部分以存储器子系统的设计作为结束，这是现代计算机系统最复杂的部分之一。) Tj
T*
() Tj
T*
(本书的这一部分将领着你深入了解如何表示和执行应用程序。你将学会一些技巧，来帮助你写出安全、可靠且充分利用计算资源的程序。) Tj
T*
() Tj
T*
(现代计算机存储和处理的信息以二值信号表示。这些微不足道的二进制数字，或者称为位（bit）, 形成了数字革命的基础。大家熟悉并使用了 1000 多年的十进制（以 10) Tj
T*
(为基数）起源于印度，在 12 世纪被阿拉伯数学家改进，并在 13 世纪被意大利数学家 Leonardo Pisano（大约公元 1170—1250，更为大家所熟知的名字是) Tj
T*
(Fibonacci）带到西方。对于有 10 个手指的人类来说，使用十进制表示法是很自然的事情，但是当构造存储和处理信息的机器时，二进制值工作得更好。二值信号能够很容易地被表示、存储) Tj
T*
(和传输，例如，可以表示为穿孔卡片上有洞或无洞、导线上的高电压或低电压，或者顺时针或逆时针的磁场。对二值信号进行存储和执行计算的电子电路非常简单和可靠，制造商能够在一个单独的硅片上集) Tj
T*
(成数百万甚至数十亿个这样的电路。) Tj
T*
() Tj
T*
(孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释 （interpretation），即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。比如，使用) Tj
T*
(一个二进制数字系统，我们能够用位组来编码非负数。通过使用标准的字符码，我们能够对文档中的字母和符号进行编码。在本章中，我们将讨论这两种编码，以及负数表示和实数近似值的编码。) Tj
T*
() Tj
T*
(我们研究三种最重要的数字表示。无符号（unsigned）编码基于传统的二进制表示法，表示大于或者等于零的数字。补码) Tj
T*
(（two's-complement）编码是表示有符号整数的最常见的方式，有符号整数就是可以为正或者为负的数字。浮点数（floating-point）编码是表示实数的科学记数法的以) Tj
T*
(2 为基数的版本。计算机用这些不同的表示方法实现算术运算，例如加法和乘法，类似于对应的整数和实数运算。) Tj
T*
() Tj
T*
(计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表示时，某些运算就会溢出) Tj
T*
ET
endstream
endobj
369 0 obj
<< /Length 5089 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(（overflow）。溢出会导致某些令人吃惊的后果。例如，在今天的大多数计算机上（使用 32 位来表示数据类型 int），计算表达式 $$\\small 200300400500$$) Tj
T*
(*** 会得出结果 -884901888。这违背了整数运算的特性，计算一组正数的乘积不应产生一个负的结果。) Tj
T*
() Tj
T*
(另一方面，整数的计算机运算满足人们所熟知的真正整数运算的许多性质。例如，利用乘法的结合律和交换律，计算下面任何一个 C 表达式，都会得出结果 -884901888：) Tj
T*
() Tj
T*
($$) Tj
T*
(\\begin{align}) Tj
T*
(& \(500  400\)  \(300 * 200\) \\\\) Tj
T*
(& \(\(500  400\)  300\) * 200 \\\\) Tj
T*
(& \(\(200  500\)  300\) * 400 \\\\) Tj
T*
(& 400  \(200  \(300 * 500\)\)) Tj
T*
(\\end{align}) Tj
T*
($$) Tj
T*
() Tj
T*
(计算机可能没有产生期望的结果，但是至少它是一致的！) Tj
T*
() Tj
T*
(浮点运算有完全不同的数学属性。虽然溢出会产生特殊的值 +∞，但是一组正数的乘积总是正的。由于表示的精度有限，浮点运算是不可结合的。例如，在大多数机器上，C 表达式 $$\\small) Tj
T*
(\(3.14+1e20\) - 1e20$$ 求得的值会是 0.0, 而 $$\\small 3.14 + \(1e20-1e20\) $$ 求得的值会是 3.14。整数运算和浮点数运算会有) Tj
T*
(不同的数学属性是因为它们处理数字表示有限性的方式不同——整数的表示虽然只能编码一个相对较小的数值范围，但是这种表示是精确的；而浮点数虽然可以编码一个较大的数值范围，但是这种表示只是) Tj
T*
(近似的。) Tj
T*
() Tj
T*
(通过研究数字的实际表示，我们能够了解可以表示的值的范围和不同算术运算的属性。为了使编写的程序能在全部数值范围内正确工作，而且具有可以跨越不同机器、操作系统和编译器组合的可移植性，了) Tj
T*
(解这种属性是非常重要的。后面我们会讲到，大量计算机的安全漏洞都是由于计算机算术运算的微妙细节引发的。在早期，当人们碰巧触发了程 序漏洞，只会给人们带来一些不便，但是现在，有众多的黑) Tj
T*
(客企图利用他们能找到的任何漏洞，不经过授权就进入他人的系统。这就要求程序员有更多的责任和义务，去了解他们的程序如何工作，以及如何被迫产生不良的行为。) Tj
T*
() Tj
T*
(计算机用几种不同的二进制表示形式来编码数值。随着第 3 章进入机器级编程，你需要熟悉这些表示方式。在本章中，我们描述这些编码，并且教你如何推出数字的表示。) Tj
T*
() Tj
T*
(通过直接操作数字的位级表示，我们得到了几种进行算术运算的方式。理解这些技术对于理解编译器产生的机器级代码是很重要的，编译器会试图优化算术表达式求值的性能。) Tj
T*
() Tj
T*
(我们对这部分内容的处理是基于一组核心的数学原理的。从编码的基本定义开始，然后得出一些属性，例如可表示的数字的范围、它们的位级表示以及算术运算的属性。我们相信从这样一个抽象的观点来分) Tj
T*
(析这些内容，对你来说是很重要的，因为程序员需要对计算机运算与更为人熟悉的整数和实数运算之间的关系有清晰的理解。) Tj
T*
() Tj
T*
(旁注 - 怎样阅读本章) Tj
T*
() Tj
T*
() Tj
T*
(本章我们研究在计算机上如何表示数字和其他形式数据的基本属性，以及计算机对这些数据执行操作的属性。这就要求我们深入研究数学语言，编写公式和方程式，以及展示重要属性的推导。) Tj
T*
() Tj
T*
(为了帮助你阅读，这部分内容安排如下：首先给出以数学形式表示的属性，作为原理。然后，用例子和非形式化的讨论来解释这个原理。我们建议你反复阅读原理描述和它的示例与讨论，直到你对该属性的) Tj
T*
(说明内容及其重要性有了牢固的直觉。对于更加复杂的属性，还会提供推导，其结构看上去将会像一个数学证明。虽然最终你应该尝试理解这些推导，但在第一次阅读时你可以跳过它们。) Tj
T*
() Tj
T*
(我们也鼓励你在阅读正文的过程中完成练习题，这会促使你主动学习，帮助你理论联系实际。有了这些例题和练习题作为背景知识，再返回推导，你将发现理解起来会容易许多。同时，请放心，掌握好高中) Tj
T*
(代数知识的人都具备理解这些内容所需要的数学技能。) Tj
T*
() Tj
T*
(C++ 编程语言建立在 C 语言基础之上，它们使用完全相同的数字表示和运算。本章中关于 C 的所有内容对 C++ 都有效。另一方面，Java) Tj
T*
(语言创造了一套新的数字表示和运算标准。C 标准的设计允许多种实现方式，而 Java 标准在数据的格式和编码上是非常精确具体的。本章中多处着重介绍了 Java 支持的表示和运算。) Tj
T*
() Tj
T*
ET
endstream
endobj
370 0 obj
<< /Length 4791 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(旁注- C 编程语言的演变) Tj
T*
() Tj
T*
() Tj
T*
(前面提到过，C 编程语言是贝尔实验室的 Dennis Ritchie 最早开发出来的，目的是和 Unix 操作系统一起使用（Unix) Tj
T*
(也是贝尔实验室开发的）。在那个时候，大多数系统程序，例如操作系统，为了访问不同数据类型的低级表示，都必须大量地使用汇编代码。比如说，像 malloc) Tj
T*
(库函数提供的内存分配功能，用当时的其他高级语言是无法编写的。) Tj
T*
() Tj
T*
(Brian Kernighan 和 Dennis Ritchie 的著作的第 1 版【60】记录了最初贝尔实验室的 C 语言版本。随着时间的推移，经过多个标准化组织的努力，C) Tj
T*
(语言也在不断地演变。1989 年，美国国家标准学会下的一个工作组推出了 ANSI C 标准，对最初的贝尔实验室的 C 语言做了重大修改。ANSI C 与贝尔实验室的 C) Tj
T*
(有了很大的不同，尤其是函数声明的方式。Brian Kernighan 和 Dennis Ritchie 在著作的第 2 版【61】中描述了 ANSI C, 这本书至今仍被公认为关于) Tj
T*
(C 语言最好的参考手册之一。) Tj
T*
() Tj
T*
(国际标准化组织接替了对 C 语言进行标准化的任务，在 1990 年推出了一个几乎和 ANSI C 一样的版本，称为 “ISO C90”。该组织在 1999 年又对 C) Tj
T*
(语言做了更新，推出 “ISO C99”。在这一版本中，引入了一些新的数据类型，对使用不符合英语语言字符的文本字符串提供了支持。更新的版本 2011 年得到批准，称为) Tj
T*
(“ISOC11”，其中再次添加了更多的数据类型和特性。最近增加的大多数内容都可以向后兼容，这意味着根据早期标准（至少可以回溯到 ISO C90）) Tj
T*
(编写的程序按新标准编译时会有同样的行为。) Tj
T*
() Tj
T*
(GNU 编译器套装（GNU Compiler Collection，GCC）可以基于不同的命令行选项，依照多个不同版本的 C 语言规则来编译程序，如图 2-1 所示。比如，根据) Tj
T*
(ISOC 11 来编译程序 prog.c，我们就使用命令行：) Tj
T*
() Tj
T*
(linux> gcc -std=c11 prog.c) Tj
T*
() Tj
T*
(编译选项 - ansi 和 - std=c89 的用法是一样的——会根据 ANSI 或者 ISO C90 标准来编译程序。（C90 有时也称为 “C89”,) Tj
T*
(这是因为它的标准化工作是从 1989 年开始的。） 编译选项 -std=c99 会让编译器按照 ISO C99 的规则进行编译。) Tj
T*
() Tj
T*
(本书中，没有指定任何编译选项时，程序会按照基于 ISOC90 的 C 语言版本进行编译，但是也包括一些 C99、C11 的特性，一些 C++ 的特性，还有一些是与 GCC) Tj
T*
(相关的特性。GNU 项目正在开发一个结合了 ISO C11 和其他一些特性的版本，可以通过命令行选项 - std=gnu11) Tj
T*
(来指定。（目前，这个实现还未完成。）今后，这个版本会成为默认的版本。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(2.1 信息存储) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(2.1 信息存储) Tj
T*
() Tj
T*
() Tj
T*
(大多数计算机使用 8 位的块，或者字节（byte），作为最小的可寻址的内存单位，而不是访问内存中单独的位。机器级程序将内存视为一个非常大的字节数组，称为虚拟内存（virtual) Tj
T*
(memory）。内存的每个字节都由一个唯一的数字来标识，称为它的地址（address），所有可能地址的集合就称为虚拟地址空间（virtual address) Tj
T*
(space）。顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。实际的实现（见第 9) Tj
T*
(章）是将动态随机访问存储器（DRAM）、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。) Tj
T*
() Tj
T*
(在接下来的几章中，我们将讲述编译器和运行时系统是如何将存储器空间划分为更可管理的单元，来存放不同的程序对象（program) Tj
T*
(object），即程序数据、指令和控制信息。可以用各种机制来分配和管理程序不同部分的存储。这种管理完全是在虚拟地址空间里完成的。例如，C) Tj
T*
(语言中一个指针的值（无论它指向一个整数、一个结构或是某个其他程序对象）都是某个存储块的第一个字节的虚拟地址。C) Tj
T*
(编译器还把每个指针和类型信息联系起来，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管 C) Tj
T*
ET
endstream
endobj
371 0 obj
<< /Length 1648 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含关于数据类型的信息。每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列。) Tj
T*
() Tj
T*
(给 C 语言初学者 - C 语言中指针的作用) Tj
T*
() Tj
T*
() Tj
T*
(指针是 C 语言的一个重要特性。它提供了引用数据结构（包括数组）的元素的机制。与变量类似，指针也有两个方面：值和类型。它的值表示某个对象的位置，而它的类型表示那个位置上所存储对象的) Tj
T*
(类型（比如整数或者浮点数）。) Tj
T*
() Tj
T*
(真正理解指针需要查看它们在机器级上的表示以及实现。这将是第 3 章的重点之 一，3.10.1 节将对其进行深入介绍。) Tj
T*
() Tj
T*
(2.1.1 十六进制表示法) Tj
T*
() Tj
T*
() Tj
T*
(2.1.2 字数据大小) Tj
T*
() Tj
T*
() Tj
T*
(2.1.3 寻址和字节顺序) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(大端法) Tj
T*
() Tj
T*
(| \\\\\\\\ | 0x100 | 0x101 | 0x102 | 0x103 |  |) Tj
T*
(| :--- | :---: | :---: | :---: | :---: | :---: |) Tj
T*
(| ⋯ | 01 | 23 | 45 | 67 | ⋯ |) Tj
T*
() Tj
T*
(小端法) Tj
T*
() Tj
T*
(| \\\\\\\\ | 0x100 | 0x101 | 0x102 | 0x103 |  |) Tj
T*
(| :--- | :---: | :---: | :---: | :---: | :---: |) Tj
T*
(| ⋯ | 67 | 45 | 23 | 01 | ⋯ |) Tj
T*
() Tj
T*
(2.1.4 表示字符串) Tj
T*
() Tj
T*
() Tj
T*
(2.1.5 表示代码) Tj
T*
() Tj
T*
() Tj
T*
(2.1.6 布尔代数简介) Tj
T*
() Tj
T*
() Tj
T*
(2.1.7 C 语言中的位级运算) Tj
T*
() Tj
T*
() Tj
T*
(2.1.8 C 语言中的逻辑运算) Tj
T*
ET
endstream
endobj
372 0 obj
<< /Length 1411 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
() Tj
T*
(2.1.9 C 语言中的移位运算) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(2.2 整数表示) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(2.2 整数表示) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(2.3 整数运算) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(2.3 整数运算) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(2.4 浮点数) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(2.4 浮点数) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(2.5 小结) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(2.5 小结) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(家庭作业) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(家庭作业) Tj
T*
() Tj
T*
ET
endstream
endobj
373 0 obj
<< /Length 7107 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(第 3 章：程序的机器级表示) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(第 3 章：程序的机器级表示) Tj
T*
() Tj
T*
() Tj
T*
(计算机执行机器代码，用字节序列编码低级的操作，包括处理数据、管理内存、读写存储设备上的数据，以及利用网络通信。编译器基于编程语言的规则、目标机器的指令集和操作系统遵循的惯例，经过一) Tj
T*
(系列的阶段生成机器代码。GCCC 语言编译器以汇编代码的形式产生输出，汇编代码是机器代码的文本表示，给出程序中的每一条指令。然后 GCC) Tj
T*
(调用汇编器和链接器，根据汇编代码生成可执行的机器代码。在本章中，我们会近距离地观察机器代码，以及人类可读的表示一汇编代码。) Tj
T*
() Tj
T*
(当我们用高级语言编程的时候（例如 C 语言，Java 语言更是如此），机器屏蔽了程序的细节，即机器级的实现。与此相反，当用汇编代码编程的时候（就像早期的计算），程序员必须指定程序用) Tj
T*
(来执行计算的低级指令。高级语言提供的抽象级别比较高，大多数时候，在这种抽象级别上工作效率会更高，也更可靠。编译器提供的类型检査能帮助我们发现许多程序错误，并能够保证按照一致的方式来) Tj
T*
(引用和处理数据。通常情况下，使用现代的优化编译器产生的代码至少与一个熟练的汇编语言程序员手工编写的代码一样有效。最大的优点是，用高级语言编写的程序可以在很多不同的机器上编译和执行，) Tj
T*
(而汇编代码则是与特定机器密切相关的。) Tj
T*
() Tj
T*
(那么为什么我们还要花时间学习机器代码呢？即使编译器承担了生成汇编代码的大部分工作，对于严谨的程序员来说，能够阅读和理解汇编代码仍是一项很重要的技能。以适当的命令行选项调用编译器，编) Tj
T*
(译器就会产生一个以汇编代码形式表示的输出文件。通过阅读这些汇编代码，我们能够理解编译器的优化能力，并分析代码中隐含的低效率。就像我们将在第 5 章中体会到的那样，试图最大化一段关键) Tj
T*
(代码性能的程序员，通常会尝试源代码的各种形式，每次编译并检査产生的汇编代码，从而了解程序将要运行的效率如何。此外，也有些时候，高级语言提供的抽象层会隐藏我们想要了解的程序的运行时行) Tj
T*
(为。例如，第 12 章会讲到，用线程包写并发程序时，了解不同的线程是如何共享程序数据或保持数据私有的，以及准确知道如何在哪里访问共享数据，都是很重要的。这些信息在机器代码级是可见的) Tj
T*
(。另外再举一个例子，程序遭受攻击（使得恶意软件侵扰系统）的许多方式中，都涉及程序存储运行时控制信息的方式的细节。许多攻击利用了系统程序中的漏洞重写信息，从而获得了系统的控制权。了解) Tj
T*
(这些漏洞是如何岀现的，以及如何防御它们，需要具备程序机器级表示的知识。程序员学习汇编代码的需求随着时间的推移也发生了变化，开始时要求程序员能直接用汇编语言编写程序，现在则要求他们能) Tj
T*
(够阅读和理解编译器产生的代码。) Tj
T*
() Tj
T*
(在本章中，我们将详细学习一种特别的汇编语言，了解如何将 C) Tj
T*
(程序编译成这种形式的机器代码。阅读编译器产生的汇编代码，需要具备的技能不同于手工编写汇编代码。我们必须了解典型的编译器在将 C 程序结构变换成机器代码时所做的转换。相对于 C 代码) Tj
T*
(表示的计算操作，优化编译器能够重新排列执行顺序，消除不必要的计算，用快速操作替换慢速操作，甚至将递归计算变换成迭代计算。源代码与对应的汇编代码的关系通常不太容易理解——就像要拼出的) Tj
T*
(拼图与盒子上图片的设计有点不太一样。这是一种逆向工程（reverse engineering）——通过研究系统和逆向工作，来试图了解系统的创建过程。在这里，系统是一个机器产生的汇编) Tj
T*
(语言程序，而不是由人设计的某个东西。这简化了逆向工程的任务，因为产生的代码遵循比较规则的模式，而且我们可以做试验，it 编译器产生许多不同程序的代码。本章提供了许多示例和大量的练习) Tj
T*
(，来说明汇编语言和编译器的各个不同方面。精通细节是理解更深和更基本概念的先决条件。有人说：“我理解了一般规则，不愿意劳神去学习细节！”) Tj
T*
(他们实际上是在自欺欺人。花时间研究这些示例、完成练习并对照提供的答案来检査你的答案，是非常关键的。) Tj
T*
() Tj
T*
(我们的表述基于 x86-64，它是现在笔记本电脑和台式机中最常见处理器的机器语言，也是驱动大型数据中心和超级计算机的最常见处理器的机器语言。这种语言的历史悠久，开始于 Intel) Tj
T*
(公司 1978 年的第一个 16 位处理器，然后扩展为 32 位，最近又扩展到 64) Tj
T*
(位。一路以来，逐渐增加了很多特性，以更好地利用已有的半导体技术，以及满足市场需求。这些进步中很多是 Intel 自己驱动的，但它的对手 AMD（Advanced Micro Dev) Tj
T*
(ices）也作出了重要的贡献。演化的结果是得到一个相当奇特的设计，有些特性只有从历史的观点来看才有意义，它还具有提供后向兼容性的特性，而现代编译器和操作系统早已不再使用这些特性。我) Tj
T*
(们将关注 GCC 和 Linux 使用的那些特性，这样可以避免 X86-64 的大量复杂性和许多隐秘特性。) Tj
T*
() Tj
T*
(我们在技术讲解之前，先快速浏览 C 语言、汇编代码以及机器代码之间的关系。然后介绍 x86-64 的细节，从数据的表示和处理以及控制的实现开始。了解如何实现 C) Tj
T*
(语言中的控制结构，如 if、while 和 switch 语句。之后，我们会讲到过程的实现，包括程序如何维护一个运行栈来支持过程间数据和控制的传递，以及局部变量的存储。接着，我们会) Tj
T*
(考虑在机器级如何实现像数组、结构和联合这样的数据结构。有了这些机器级编程的背景知识，我们会讨论内存访问越界的问题，以及系统容易遭受缓冲区溢出攻击的问题。在这一部分的结尾，我们会给出) Tj
T*
(一些用 GDB 调试器检査机器级程序运行时行为的技巧。本章的最后展示了包含浮点数据和操作的代码的机器程序表示。) Tj
T*
() Tj
T*
(网络旁注 ASM: IA32 - IA32 编程) Tj
T*
ET
endstream
endobj
374 0 obj
<< /Length 5200 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
() Tj
T*
(IA32，x86-64 的 32 位前身，是 Intel 在 1985 年提出的。几十年来一直是 Intel 的机器语言之选。今天出售的大多数 x86) Tj
T*
(微处理器，以及这些机器上安装的大多数操作系统，都是为运行 x86-64 设计的。不过，它们也可以向后兼容执行 IA32 程序。所以，很多应用程序还是基于 IA32) Tj
T*
(的。除此之外，由于硬件或系统软件的限制，许多已有的系统不能够执行 x86-64oIA32 仍然是一种重要的机器语言。学习过 x86-64 会使你很容易地学会 IA32 机器语言。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(计算机工业已经完成从 32 位到 64 位机器的过渡。32 位机器只能使用大概 4 GB（232) Tj
T*
(字节）的随机访问存储器。存储器价格急剧下降，而我们对计算的需求和数据的大小持续增加，超越这个限制既经济上可行又有技术上的需要。当前的 64 位机器能够使用多达 256) Tj
T*
(TB（$$2^{48}$$字节）的内存空间，而且很容易就能扩展至 16 EB（$$2^{64}$$字节）。虽然很难想象一台机器需要这么大的内存，但是回想 20 世纪 70 和 80) Tj
T*
(年代，当 32 位机器开始普及的时候，4GB 的内存看上去也是超级大的。 我们的表述集中于以现代操作系统为目标，编译 C 或类似编程语言时，生成的机器级程序类型。x86-64) Tj
T*
(有一些特性是为了支持遗留下来的微处理器早期编程风格，在此，我们不试图去描述这些特性，那时候大部分代码都是手工编写的，而程序员还在努力与 16 位机器允许的有限地址空间奋战。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(3.1 历史观点) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(3.1 历史观点) Tj
T*
() Tj
T*
() Tj
T*
(Intel 处理器系列俗称 x86，经历了一个长期的、不断进化的发展过程。开始时，它是第一代单芯片、16) Tj
T*
(位微处理器之一，由于当时集成电路技术水平十分有限，其中做了很多妥协。以后，它不断地成长，利用进步的技术满足更高性能和支持更高级操作系统的需求。) Tj
T*
() Tj
T*
(以下列举了一些 Intel 处理器的模型，以及它们的一些关键特性，特别是影响机器级编程的特性。我们用实现这些处理器所需要的晶体管数量来说明演变过程的复杂性。其中，“K” 表示) Tj
T*
(1000，“M” 表示 1 000 000，而 “G” 表示 1 000 000 000。) Tj
T*
() Tj
T*
(* 8086（1978 年，29 K 个晶体管）。它是第一代单芯片、16 位微处理器之一。8088 是 8086 的一个变种，在 8086 上增加了一个 8 位外部总线，构成最初的) Tj
T*
(IBM 个人计算机的心脏。IBM 与当时还不强大的微软签订合同，开发 MS-DOS 操作系统。最初的机器型号有 32 768) Tj
T*
(字节的内存和两个软驱（没有硬盘驱动器）。从体系结构上来说，这些机器只有 655 360 字节的地址空间——地址只有 20 位长（可寻址范围为 1048576) Tj
T*
(字节），而操作系统保留了 393216 字节自用。1980 年，Intel 提出了 8087 浮点协处理器（45 K 个晶体管），它与一个 8086 或 8088) Tj
T*
(处理器一同运行，执行浮点指令。8087 建立了 x86 系列的浮点模型，通常被称为 “x87”。) Tj
T*
(* 80286（1982 年，134 K 个晶体管）。增加了更多的寻址模式（现在已经废弃了），构成了 IBM PC-AT 个人计算机的基础，这种计算机是 MS Windows) Tj
T*
(最初的使用平台。) Tj
T*
(* i386（1985 年，275 K 个晶体管）。将体系结构扩展到 32 位。增加了平坦寻址模式（flat addressing model），Linux 和最近版本的) Tj
T*
(Windows 操作系统都是使用的这种模式。这是 Intel 系列中第一台全面支持 Unix 操作系统的机器。) Tj
T*
(* i486（1989 年，1.2 M 个晶体管）。改善了性能，同时将浮点单元集成到了处理器芯片上，但是指令集没有明显的改变。) Tj
T*
(* Pentium（1993 年，3.1 M 个晶体管）。改善了性能，不过只对指令集进行了小的扩展。) Tj
T*
(* Pentium Pro（1995 年，5.5 M 个晶体管）。引入全新的处理器设计，在内部被称为 F6 微体系结构。指令集中增加了一类“条件传送（conditional) Tj
T*
(move）”指令。) Tj
T*
(* Pentium/MMX（1997 年，4.5 M 个晶体管）。在 Pentium 处理器中增加了一类新的处理整数向量的指令。每个数据大小可以是 1、2 或 4) Tj
T*
(字节。每个向量总长 64 位。) Tj
T*
(* Pentium II（1997 年，7 M 个晶体管）。P6 微体系结构的延伸。) Tj
T*
(* Pentium III（1999 年，8.2 M 个晶体管）。引入了 SSE，这是一类处理整数或浮点数向量的指令。每个数据可以是 1、2 或 4 个字节，打包成 128) Tj
T*
(位的向量。由于芯片上包括了二级高速缓存，这种芯片后来的版本最多使用了 24 M 个晶体管。) Tj
T*
ET
endstream
endobj
375 0 obj
<< /Length 4680 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(* Pentium 4（2000 年，42 M 个晶体管）。SSE 扩展到了 SSE2，增加了新的数据类型（包括双精度浮点数），以及针对这些格式的 144) Tj
T*
(条新指令。有了这些扩展，编译器可以使用 SSE 指令（而不是 x87 指令），来编译浮点代码。) Tj
T*
(* Pentium 4E（2004 年，125 M 个晶体管）。增加了超线程（hyperthreading），这种技术可以在一个处理器上同时运行两个程序；还增加了 EM64T，它是) Tj
T*
(Intel 对 AMD 提出的对 IA32 的 64 位扩展的实现，我们称之为 x86-64。) Tj
T*
(* Core2（2006 年，291 M 个晶体管）。回归到类似于 P6 的微体系结构。Intel 的第一个多核微处理器，即多处理器实现在一个芯片上。但不支持超线程。) Tj
T*
(* Core i7，NehaIem（2008 年，781 M 个晶体管）。既支持超线程，也有多核，最初的版本支持每个核上执行两个程序，每个芯片上最多四个核。) Tj
T*
(* Core i7，Sandy Bridge（2011 年，1.17 G 个晶体管）。引入了 AVX，这是对 SSE 的扩展，支持把数据封装进 256 位的向量。) Tj
T*
(* Core i7，Haswell（2013 年，1.4 G 个晶体管）。将 AVX 扩展至 AVX2，增加了更多的指令和指令格式。) Tj
T*
() Tj
T*
(每个后继处理器的设计都是后向兼容的一较早版本上编译的代码可以在较新的处理器上运行。正如我们看到的那样，为了保持这种进化传统，指令集中有许多非常奇怪的东西。Intel) Tj
T*
(处理器系列有好几个名字，包括 IA32，也就是 “Intel 32 位体系结构（Intel Architecture 32-bit）“，以及最新的 Intel64，即 IA32 的) Tj
T*
(64 位扩展，我们也称为 x86-64。最常用的名字是 “x86”，我们用它指代整个系列，也反映了直到 i486 处理器命名的惯例。) Tj
T*
() Tj
T*
(旁注 - 摩尔定律（Moore's Law）) Tj
T*
() Tj
T*
() Tj
T*
(如果我们画出各种不同的 Intel 处理器中晶体管的数量与它们出现的年份之间的图（y) Tj
T*
(轴为晶体管数量的对数值），我们能够看出，增长是很显著的。画一条拟合这些数据的线，可以看到晶体管数量以每年大约 37% 的速率增加，也就是说，晶体管数量每 26 个月就会翻一番。在) Tj
T*
(x86 微处理器的历史上，这种增长已经持续了好几十年。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(1965 年，Gordon Moore，Intel 公司的创始人，根据当时的芯片技术（那时他们能够在一个芯片上制造有大约 64 个晶体管的电路）做出推断，预测在未来 10) Tj
T*
(年，芯片上的晶体管数量每年都会翻一番。这个预测就称为摩尔定律。正如事实证明的那样，他的预测有点乐观，而且短视。在超过 50 年中，半导体工业一直能够使得晶体管数目每 18) Tj
T*
(个月翻一倍。) Tj
T*
() Tj
T*
(对计算机技术的其他方面，也有类似的呈指数增长的情况出现，比如磁盘和半导体存储器的存储容量。这些惊人的增长速度一直是计算机革命的主要驱动力。) Tj
T*
() Tj
T*
(这些年来，许多公司生产出了与 Intel 处理器兼容的处理器，能够运行完全相同的机器级程序。其中，领头的是 AMD。数年来，AMD 在技术上紧跟) Tj
T*
(Intel，执行的市场策略是：生产性能稍低但是价格更便宜的处理器。2002 年，AMD 的处理器变得更加有竞争力，它们率先突破了可商用微处理器的 1GHz) Tj
T*
(的时钟速度屏障，并且引入了广泛釆用的 IA32 的 64 位扩展 x86-64。虽然我们讲的是 Intel) Tj
T*
(处理器，但是对于其竞争对手生产的与之兼容的处理器来说，这些表述也同样成立。) Tj
T*
() Tj
T*
(对于由 GCC 编译器产生的、在 Linux 操作系统平台上运行的程序，感兴趣的人大多并不关心 x86 的复杂性。最初的 8086 提供的内存模型和它在 80286 中的扩展，到) Tj
T*
(i386 的时候就都已经过时了。原来的 x87 浮点指令到引入 SSE2 以后就过时了。虽然在 x86-64 程序中，我们能看到历史发展的痕迹，但 x86) Tj
T*
(中许多最晦涩难懂的特性已经不会出现了。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(3.2 程序编码) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(3.2 程序编码) Tj
T*
() Tj
T*
() Tj
T*
(假设一个 C 程序，有两个文件 p1.c 和 p2.c。我们用 Unix 命令行编译这些代码：) Tj
T*
ET
endstream
endobj
376 0 obj
<< /Length 6261 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(    linux> gcc -Og -o p p1.c p2.c) Tj
T*
() Tj
T*
(命令 gcc 指的就是 GCC C 编译器。因为这是 Linux 默认的编译器，我们也可以简单地用 cc 来启动它。编译选项 ✦-Og✦ 告诉编译器使用会生成符合原始 C) Tj
T*
(代码整体结构的机器代码的优化等级。使用较高级别优化产生的代码会严重变形，以至于产生的机器代码和初始源代码之间的关系非常难以理解。因此我们会使用 -Og) Tj
T*
(优化作为学习工具，然后当我们增加优化级别时，再看会发生什么。实际中，从得到的程序的性能考虑，较高级别的优化（例如，以选项 -O1 或 -O2 指定）被认为是较好的选择。) Tj
T*
() Tj
T*
(✦-Og✦：GCC 版本 4.8 引入了这个优化等级。较早的 GCC 版本和其他一些非 GNU 编译器不认识这个选项。对这样一些编译器，使用一级优化（由命令行标志 -O1) Tj
T*
(指定）可能是最好的选择，生成的代码能够符合原始程序的结构。) Tj
T*
() Tj
T*
(实际上 gcc 命令调用了一整套的程序，将源代码转化成可执行代码。首先，C 预处理器扩展源代码，插入所有用 \\#include 命令指定的文件，并扩展所有用\\#define) Tj
T*
(声明指定的宏。其次，编译器产生两个源文件的汇编代码，名字分别为 p1.s 和 p2.s。接下来，汇编器会将汇编代码转化成二进制目标代码文件 p1.o 和) Tj
T*
(p2.o。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。最后，链接器将两个目标代码文件与实现库函数（例如) Tj
T*
(printf）的代码合并，并产生最终的可执行代码文件 p（由命令行指示符 -o p指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。我们会在第 7) Tj
T*
(章更详细地介绍这些不同形式的机器代码之间的关系以及链接的过程。) Tj
T*
() Tj
T*
(3.2.1 机器级代码) Tj
T*
() Tj
T*
() Tj
T*
(正如在 1.9.3 节中讲过的那样，计算机系统使用了多种不同形式的抽象，利用更简单的抽象模型来隐藏实现的细节。对于机器级编程来说，其中两种抽象尤为重要。第一种是由指令集体系结构或指) Tj
T*
(令集架构（Instruction Set Architecture，ISA）来定义机器级程序的格式和行为，它定义了处理器状态、指令的格式，以及每条指令对状态的影响。大多数) Tj
T*
(ISA，包括) Tj
T*
(x86-64，将程序的行为描述成好像每条指令都是按顺序执行的，一条指令结束后，下一条再开始。处理器的硬件远比描述的精细复杂，它们并发地执行许多指令，但是可以釆取措施保证整体行为与) Tj
T*
(ISA 指定的顺序执行的行为完全一致。第二种抽象是，机器级程序使用的内存地址是虚拟地址，提供的内存模型看上去是一个非常大的字节数组。存储器系统的实际实现是将多个硬件存储器和操作系统) Tj
T*
(软件组合起来，这会在第 9 章中讲到。) Tj
T*
() Tj
T*
(在整个编译过程中，编译器会完成大部分的工作，将把用 C 语言提供的相对比较抽象的执行模型表示的程序转化成处理器执行的非常基本的指令。汇编代码表示非常接近于机器代码。与机器代码的二进) Tj
T*
(制格式相比，汇编代码的主要特点是它用可读性更好的文本格式表示。能够理解汇编代码以及它与原始 C 代码的联系，是理解计算机如何执行程序的关键一步。) Tj
T*
() Tj
T*
(x86-64 的机器代码和原始的 C 代码差别非常大。一些通常对 C 语言程序员隐藏的处理器状态都是可见的：) Tj
T*
() Tj
T*
(* 程序计数器（通常称为 “PC”，在 x86-64 中用 ％rip 表示）给出将要执行的下一条指令在内存中的地址。) Tj
T*
(* 整数寄存器文件包含 16 个命名的位置，分别存储 64 位的值。这些寄存器可以存储地址（对应于 C) Tj
T*
(语言的指针）或整数数据。有的寄存器被用来记录某些重要的程序状态，而其他的寄存器用来保存临时数据，例如过程的参数和局部变量，以及函数的返回值。) Tj
T*
(* 条件码寄存器保存着最近执行的算术或逻辑指令的状态信息。它们用来实现控制或数据流中的条件变化，比如说用来实现 if 和 while 语句。) Tj
T*
(* 一组向量寄存器可以存放一个或多个整数或浮点数值。) Tj
T*
() Tj
T*
(虽然 C 语言提供了一种模型，可以在内存中声明和分配各种数据类型的对象，但是机器代码只是简单地将内存看成一个很大的、按字节寻址的数组。C) Tj
T*
(语言中的聚合数据类型，例如数组和结构，在机器代码中用一组连续的字节来表示。即使是对标量数据类型，汇编代码也不区分有符号或无符号整数，不区分各种类型的指针，甚至于不区分指针和整数。) Tj
T*
() Tj
T*
(程序内存包含：程序的可执行机器代码，操作系统需要的一些信息，用来管理过程调用和返回的运行时栈，以及用户分配的内存块（比如说用 malloc) Tj
T*
(库函数分配的）。正如前面提到的，程序内存用虚拟地址来寻址。在任意给定的时刻，只有有限的一部分虚拟地址被认为是合法的。例如，X86-64 的虚拟地址是由 64) Tj
T*
(位的字来表示的。在目前的实现中，这些地址的高 16 位必须设置为 0，所以一个地址实际上能够指定的是$$2^{48}$$或 256 TB) Tj
T*
(范围内的一个字节。较为典型的程序只会访问几兆字节或几千兆字节的数据。操作系统负责管理虚拟地址空间，将虚拟地址翻译成实际处理器内存中的物理地址。) Tj
T*
() Tj
T*
(一条机器指令只执行一个非常基本的操作。例如，将存放在寄存器中的两个数字相加，在存储器和寄存器之间传送数据，或是条件分支转移到新的指令地址。编译器必须产生这些指令的序列，从而实现（像) Tj
T*
ET
endstream
endobj
377 0 obj
<< /Length 2506 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(算术表达式求值、循环或过程调用和返回这样的）程序结构。) Tj
T*
() Tj
T*
(旁注 - 不断变化的生成代码的格式) Tj
T*
() Tj
T*
() Tj
T*
(在本书的表述中，我们给出的代码是由特定版本的 GCC 在特定的命令行选项设置下产生的。如果你在自己的机器上编译代码，很有可能用到其他的编译器或者不同版本的) Tj
T*
(GCC，因而会产生不同的代码。支持 GCC 的开源社区一直在修改代码产生器，试图根据微处理器制造商提供的不断变化的代码规则，产生更有效的代码。) Tj
T*
() Tj
T*
(本书示例的目标是展示如何查看汇编代码，并将它反向映射到高级编程语言中的结构。你需要将这些技术应用到你的特定的编译器产生的代码格式上。) Tj
T*
() Tj
T*
(3.2.2 代码示例) Tj
T*
() Tj
T*
() Tj
T*
(假设我们写了一个 C 语言代码文件 mstore.c，包含如下的函数定义：) Tj
T*
() Tj
T*
(    long mult2\(long, long\);) Tj
T*
(    void multstore\(long x, long y, long *dest\) {) Tj
T*
(        long t = mult2\(x, y\);) Tj
T*
(        *dest = t;) Tj
T*
(    }) Tj
T*
() Tj
T*
(在命令行上使用 “-S” 选项，就能看到 C 语言编译器产生的汇编代码：) Tj
T*
() Tj
T*
(    linux> gcc -Og -S mstore.c) Tj
T*
() Tj
T*
(这会使 GCC 运行编译器，产生一个汇编文件 mstore.s，但是不做其他进一步的工作。（通常情况下，它还会继续调用汇编器产生目标代码文件）。) Tj
T*
() Tj
T*
(汇编代码文件包含各种声明，包括下面几行：) Tj
T*
() Tj
T*
(    multstore:) Tj
T*
(      pushq   %rbx) Tj
T*
(      movq    %rdx, %rbx) Tj
T*
(      call    mult2) Tj
T*
(      movq    %rax, \(%rbx\)) Tj
T*
(      popq    %rbx) Tj
T*
(      ret) Tj
T*
() Tj
T*
(上面代码中每个缩进去的行都对应于一条机器指令。比如，pushq 指令表示应该将寄存器％rbx 的内容压入程序栈中。这段代码中已经除去了所有关于局部变量名或数据类型的信息。) Tj
T*
() Tj
T*
(如果我们使用 “-c” 命令行选项，GCC 会编译并汇编该代码：) Tj
T*
() Tj
T*
(    linux> gcc -Og -c mstore.c) Tj
T*
() Tj
T*
(这就会产生目标代码文件 mstore.o，它是二进制格式的，所以无法直接查看。1368 字节的文件 mstore.o 中有一段 14 字节的序列，它的十六进制表示为：) Tj
T*
() Tj
T*
(53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3) Tj
T*
ET
endstream
endobj
378 0 obj
<< /Length 3667 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(这就是上面列出的汇编指令对应的目标代码。从中得到一个重要信息，即机器执行的程序只是一个字节序列，它是对一系列指令的编码。机器对产生这些指令的源代码几乎一无所知。) Tj
T*
() Tj
T*
(旁注 - 如何展示程序的字节表示) Tj
T*
() Tj
T*
() Tj
T*
(要展示程序（比如说 mstore）的二进制目标代码，我们用反汇编器（后面会讲到）确定该过程的代码长度是 14 字节。然后，在文件 mstore.o 上运行 GNU 调试工具) Tj
T*
(GDB，输入命令：) Tj
T*
() Tj
T*
(    \(gdb\) x/14xb multstore) Tj
T*
() Tj
T*
(这条命令告诉 GDB 显示（简写为 ‘x’）从函数 multstore 所处地址开始的 14 个十六进制格式表示（也简写为 ‘x’）的字节（简写为 ‘b’）。你会发现，GDB) Tj
T*
(有很多有用的特性可以用来分析机器级程序，我们会在 3.10.2 节中讨论。) Tj
T*
() Tj
T*
(要査看机器代码文件的内容，有一类称为反汇编器（disassembler）的程序非常有用。这些程序根据机器代码产生一种类似于汇编代码的格式。在 Linux 系统中，带 ‘-d’) Tj
T*
(命令行标志的程序 OBJDUMP（表示 “object dump”）可以充当这个角色：) Tj
T*
() Tj
T*
(    linux> objdump -d mstore.o) Tj
T*
() Tj
T*
(结果如下（这里，我们在左边增加了行号，在右边增加了斜体表示的注解）：) Tj
T*
() Tj
T*
(    # Disassembly of function sum in binary file mstore.o) Tj
T*
(    0000000000000000 <multstore>:) Tj
T*
(    ----------------------------------------------------------) Tj
T*
(    Offset   Bytes                Equivalent assembly language) Tj
T*
(    ----------------------------------------------------------) Tj
T*
(        0:   53                   push   %rbx) Tj
T*
(        1:   48 89 d3             mov    %rdx,%rbx) Tj
T*
(        4:   e8 00 00 00 00       callq  9 <multstore+0x9>) Tj
T*
(        9:   48 89 03             mov    %rax,\(%rbx\)) Tj
T*
(        c:   5b                   pop    %rbx) Tj
T*
(        d:   c3                   retq) Tj
T*
() Tj
T*
(在左边，我们看到按照前面给出的字节顺序排列的 14 个十六进制字节值，它们分成了若干组，每组有 1 ~ 5 个字节。每组都是一条指令，右边是等价的汇编语言。) Tj
T*
() Tj
T*
(其中一些关于机器代码和它的反汇编表示的特性值得注意：) Tj
T*
() Tj
T*
(* x86-64 的指令长度从 1 到 15 个字节不等。常用的指令以及操作数较少的指令所需的字节数少，而那些不太常用或操作数较多的指令所需字节数较多。) Tj
T*
(* 设计指令格式的方式是，从某个给定位置开始，可以将字节唯一地解码成机器指令。例如，只有指令 pushq %rbx 是以字节值 53 开头的。) Tj
T*
(* 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。它不需要访问该程序的源代码或汇编代码。) Tj
T*
(* 反汇编器使用的指令命名规则与 GCC 生成的汇编代码使用的有些细微的差别。在我们的示例中，它省略了很多指令结尾的) Tj
T*
(‘q’。这些后缀是大小指示符，在大多数情况中可以省略。相反，反汇编器给 call 和 ret 指令添加了 ‘q’ 后缀，同样，省略这些后缀也没有问题。) Tj
T*
() Tj
T*
(生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个 main 函数。假设在文件 main.c 中有下面这样的函数：) Tj
T*
() Tj
T*
(    #include <stdio.h>) Tj
T*
ET
endstream
endobj
379 0 obj
<< /Length 2511 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(    void multstore\(long, long, long *\);) Tj
T*
() Tj
T*
(    int main\(\) {) Tj
T*
(        long d;) Tj
T*
(        multstore\(2, 3, &d\);) Tj
T*
(        printf\("2 * 3 --> %ld\\n", d\);) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    long mult2\(long a, long b\) {) Tj
T*
(        long s = a * b;) Tj
T*
(        return s;) Tj
T*
(    }) Tj
T*
() Tj
T*
(然后，我们用如下方法生成可执行文件 prog：) Tj
T*
() Tj
T*
(    linux> gcc -Og -o prog main.c mstore.c) Tj
T*
() Tj
T*
(文件 prog 变成了 8655 个字节，因为它不仅包含了两个过程的代码，还包含了用来启动和终止程序的代码，以及用来与操作系统交互的代码。我们也可以反汇编 prog 文件：) Tj
T*
() Tj
T*
(    linux> objdump -d prog) Tj
T*
() Tj
T*
(反汇编器会抽取出各种代码序列，包括下面这段：) Tj
T*
() Tj
T*
(    # Disassembly of function sum in binary file prog) Tj
T*
(    ----------------------------------------------------------) Tj
T*
(    Offset    Bytes                 Equivalent assembly language) Tj
T*
(    ----------------------------------------------------------) Tj
T*
(    0000000000400540 <multstore>:) Tj
T*
(    400540:   53                    push   %rbx) Tj
T*
(    400541:   48 89 d3              mov    %rdx,%rbx) Tj
T*
(    400544:   e8 42 00 00 00        callq  40058b <mult2>) Tj
T*
(    400549:   48 89 03              mov    %rax,\(%rbx\)) Tj
T*
(    40054c:   5b                    pop    %rbx) Tj
T*
(    40054d:   c3                    retq) Tj
T*
(    40054e:   90                    nop) Tj
T*
(    40054f:   90                    nop) Tj
T*
() Tj
T*
(这段代码与 mstore.c 反汇编产生的代码几乎完全一样。其中一个主要的区别是左边列出的地址不同一链接器将这段代码的地址移到了一段不同的地址范围中。第二个不同之处在于链接器填上了) Tj
T*
(callq 指令调用函数 mult2 需要使用的地址（反汇编代码第 4 行）。链接器的任务之一就是为函数调用找到匹配的函数的可执行代码的位置。最后一个区别是多了两行代码（第 8 和) Tj
T*
(9 行）。这两条指令对程序没有影响，因为它们出现在返回指令后面（第 7 行）。插入这些指令是为了使函数代码变为 16 字节，使得就存储器系统性能而言，能更好地放置下一个代码块。) Tj
T*
() Tj
T*
(3.2.3 关于格式的注解) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
380 0 obj
<< /Length 3036 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(GCC 产生的汇编代码对我们来说有点儿难读。一方面，它包含一些我们不需要关心的信息，另一方面，它不提供任何程序的描述或它是如何工作的描述。例如，假设我们用如下命令生成文件) Tj
T*
(mstore.s。) Tj
T*
() Tj
T*
(mstore.s 的完整内容如下：) Tj
T*
() Tj
T*
(            .file   "010-mstore.c") Tj
T*
(            .text) Tj
T*
(            .globl  multstore) Tj
T*
(            .type   multstore, @function) Tj
T*
(    multstore:) Tj
T*
(            pushq   %rbx) Tj
T*
(            movq    %rdx, %rbx) Tj
T*
(            call    mult2) Tj
T*
(            movq    %rax, \(%rbx\)) Tj
T*
(            popq    %rbx) Tj
T*
(            ret) Tj
T*
(            .size   multstore, .-multstore) Tj
T*
(            .ident  "GCC: \(Ubuntu 4.8.1-2ubuntu1~12.04\) 4.8.1") Tj
T*
(            .section        .note.GNU-stack,"",@progbits) Tj
T*
() Tj
T*
(所有以 ‘.’ 开头的行都是指导汇编器和链接器工作的伪指令。我们通常可以忽略这些行。另一方面，也没有关于指令的用途以及它们与源代码之间关系的解释说明。) Tj
T*
() Tj
T*
(为了更清楚地说明汇编代码，我们用这样一种格式来表示汇编代码，它省略了大部分伪指令，但包括行号和解释性说明。对于我们的示例，带解释的汇编代码如下：) Tj
T*
() Tj
T*
(    # void multstore\(long x, long y, long *dest\)) Tj
T*
(    # x in %rdi, y in %rsi, dest in %rdx) Tj
T*
(    multstore:) Tj
T*
(      pushq     %rbx                # Save %rbx) Tj
T*
(      movq      %rdx, %rbx          # Copy dest to %rbx) Tj
T*
(      call      mult2               # Call mult2\(x, y\)) Tj
T*
(      movq      %rax, \(%rbx\)        # Store result at *dest) Tj
T*
(      popq      %rbx                # Restore %rbx) Tj
T*
(      ret                           # Return) Tj
T*
() Tj
T*
(通常我们只会给出与讨论内容相关的代码行。每一行的左边都有编号供引用，右边是注释，简单地描述指令的效果以及它与原始 C) Tj
T*
(语言代码中的计算操作的关系。这是一种汇编语言程序员写代码的风格。) Tj
T*
() Tj
T*
(我们还提供网络旁注，为专门的机器语言爱好者提供一些资料。一个网络旁注描述的是 IA32 机器代码。有了 X86-64 的背景，学习 IA32) Tj
T*
(会相当简单。另外一个网络旁注简要描述了在 C) Tj
T*
(语言中插入汇编代码的方法。对于一些应用程序，程序员必须用汇编代码来访问机器的低级特性。一种方法是用汇编代码编写整个函数，在链接阶段把它们和 C 函数组合起来。另一种方法是利用) Tj
T*
(GCC 的支持，直接在 C 程序中嵌入汇编代码。) Tj
T*
() Tj
T*
(旁注 - ATT 与 Intel 汇编代码格式) Tj
T*
() Tj
T*
() Tj
T*
(我们的表述是 ATT（根据 “AT&T” 命名的，AT&T 是运营贝尔实验室多年的公司）格式的汇编代码，这是 GCC、OBJDUMP) Tj
T*
ET
endstream
endobj
381 0 obj
<< /Length 3321 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(和其他一些我们使用的工具的默认格式。其他一些编程工具，包括 Microsoft 的工具，以及来自 Intel 的文档，其汇编代码都是 Intel) Tj
T*
(格式的。这两种格式在许多方面有所不同。例如，使用下述命令行，GCC 可以产生 multstore 函数的 Intel 格式的代码：) Tj
T*
() Tj
T*
(    linux> gcc -Og -S -masm=intel mstore.c) Tj
T*
() Tj
T*
(这个命令得到下列汇编代码：) Tj
T*
() Tj
T*
(    multstore:) Tj
T*
(      push    rbx) Tj
T*
(      mov     rbx, rdx) Tj
T*
(      call    mult2) Tj
T*
(      mov     QWORD PTR [rbx], rax) Tj
T*
(      pop     rbx) Tj
T*
(      ret) Tj
T*
() Tj
T*
(我们看到 Intel 和 ATT 格式在如下方面有所不同：) Tj
T*
() Tj
T*
(* Intel 代码省略了指示大小的后缀。我们看到指令 push 和 mov，而不是 pushq 和 movq。) Tj
T*
(* Intel 代码省略了寄存器名字前面的 ‘％ ’ 符号，用的是 rbx，而不是 ％rbx。) Tj
T*
(* Intel 代码用不同的方式来描述内存中的位置，例如是 ‘QWORD PTR \\[rbx\\]’ 而不是 ‘\\\(%rbx\\\)’。) Tj
T*
(* 在带有多个操作数的指令情况下，列出操作数的顺序相反。当在两种格式之间进行转换的时候，这一点非常令人困惑。) Tj
T*
() Tj
T*
(虽然在我们的表述中不使用 Intel 格式，但是在来自 Intel 和 Microsoft 的文档中，你会遇到它。) Tj
T*
() Tj
T*
(网络旁注 ASM:EASM - 把 C 程序和汇编代码结合起来) Tj
T*
() Tj
T*
() Tj
T*
(虽然 C 编译器在把程序中表达的计算转换到机器代码方面表现出色，但是仍然有一些机器特性是 C 程序访问不到的。例如，每次 X86-64) Tj
T*
(处理器执行算术或逻辑运算时，如果得到的运算结果的低 8 位中有偶数个 1，那么就会把一个名为 PF 的 1 位条件码（condition code）标志设置为 1，否则就设置为) Tj
T*
(0。这里的 PF 表示 “parity flag（奇偶标志）在 C 语言中计算这个信息需要至少 7 次移位、掩码和异或运算（参见习题) Tj
T*
(2.65）。即使作为每次算术或逻辑运算的一部分，硬件都完成了这项计算，而 C 程序却无法知道 PF 条件码标志的值。在程序中插入几条汇编代码指令就能很容易地完成这项任务。) Tj
T*
() Tj
T*
(在 C 程序中插入汇编代码有两种方法。第一种是，我们可以编写完整的函数，放进一个独立的汇编代码文件中，让汇编器和链接器把它和用 C) Tj
T*
(语言书写的代码合并起来。第二种方法是，我们可以使用 GCC 的内联汇编（inline assembly）特性，用 asm 伪指令可以在 C) Tj
T*
(程序中包含简短的汇编代码。这种方法的好处是减少了与机器相关的代码量。) Tj
T*
() Tj
T*
(当然，在 C 程序中包含汇编代码使得这些代码与某类特殊的机器相关（例如 x86-64），所以只应该在想要的特性只能以此种方式才能访问到时才使用它。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(3.3 数据格式) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(3.3 数据格式) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
382 0 obj
<< /Length 4452 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(由于是从 16 位体系结构扩展成 32 位的，Intel 用术语 “字（word）” 表示 16 位数据类型。因此，称 32 位数为 “双字（double words）”，称 64) Tj
T*
(位数为 “四字（quad words）”。图 3-1 给出了 C 语言基本数据类型对应的 x86-64 表示。标准 int 值存储为双字（32 位）。指针（在此用 char \\*) Tj
T*
(表示）存储为 8 字节的四字，64 位机器本来就预期如此。x86-64 中，数据类型 long 实现为 64 位，允许表示的值范围较大。本章代码示例中的大部分都使用了指针和) Tj
T*
(long 数据类型，所以都是四字操作。x86-64 指令集同样包括完整的针对字节、字和双字的指令。) Tj
T*
() Tj
T*
(| C声明 | Intel数据类型 | 汇编代码后缀 | 大小（字节） |) Tj
T*
(| :--- | :--- | :---: | :---: |) Tj
T*
(| char | 字节 | b | 1 |) Tj
T*
(| short | 字 | w | 2 |) Tj
T*
(| int | 双字 | l | 4 |) Tj
T*
(| long | 四字 | q | 8 |) Tj
T*
(| char \\* | 四字 | q | 8 |) Tj
T*
(| float | 单精度 | s | 4 |) Tj
T*
(| double | 双精度 | l | 8 |) Tj
T*
() Tj
T*
(> 图 3-1 C 语言数据类型在 x86-64 中的大小。在 64 位机器中，指针长 8 字节) Tj
T*
() Tj
T*
(浮点数主要有两种形式：单精度（4 字节）值，对应于 C 语言数据类型 float；双精度（8 字节）值，对应于 C 语言数据类型 double。x86) Tj
T*
(家族的微处理器历史上实现过对一种特殊的 80 位（10 字节）浮点格式进行全套的浮点运算（参见家庭作业 2.86）。可以在 C 程序中用声明 long double) Tj
T*
(来指定这种格式。不过我们不建议使用这种格式。它不能移植到其他类型的机器上，而且实现的硬件也不如单精度和双精度算术运算的高效。) Tj
T*
() Tj
T*
(如图所示，大多数 GCC 生成的汇编代码指令都有一个字符的后缀，表明操作数的大小。例如，数据传送指令有四个变种：movb（传送字节）、movw（传送字）、movl（传送双字）和) Tj
T*
(movq（传送四字）。后缀 ‘l’ 用来表示双字，因为 32 位数被看成是 “长字（long word）”。注意，汇编代码也使用后缀 ‘l’ 来表示 4 字节整数和 8) Tj
T*
(字节双精度浮点数。这不会产生歧义，因为浮点数使用的是一组完全不同的指令和寄存器。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(3.4 访问信息) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(3.4 访问信息) Tj
T*
() Tj
T*
() Tj
T*
(一个 x86-64 的中央处理单元（CPU）包含一组 16 个存储 64 位值的通用目的寄存器。这些寄存器用来存储整数数据和指针。图 3-2 显示了这 16) Tj
T*
(个寄存器。它们的名字都以 %r 开头，不过后面还跟着一些不同的命名规则的名字，这是由于指令集历史演化造成的。最初的 8086 中有 8 个 16 位的寄存器，即图 3-2 中的) Tj
T*
(%ax 到 %bp。每个寄存器都有特殊的用途，它们的名字就反映了这些不同的用途。扩展到 IA32 架构时，这些寄存器也扩展成 32 位寄存器，标号从 %eax 到 %ebp。扩展到) Tj
T*
(x86-64 后，原来的 8 个寄存器扩展成 64 位，标号从 %rax 到 %rbp。除此之外，还增加了 8 个新的寄存器，它们的标号是按照新的命名规则制定的：从 %r8 到) Tj
T*
(%r15。) Tj
T*
() Tj
T*
(如图 3-2 中嵌套的方框标明的，指令可以对这 16 个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16 位操作可以访问最低的 2 个字节，32) Tj
T*
(位操作可以访问最低的 4 个字节，而 64 位操作可以访问整个寄存器。) Tj
T*
() Tj
T*
(在后面的章节中，我们会展现很多指令，复制和生成 1 字节、2 字节、4 字节和 8 字节值。当这些指令以寄存器作为目标时，对于生成小于 8) Tj
T*
(字节结果的指令，寄存器中剩下的字节会怎么样，对此有两条规则：生成 1 字节和 2 字节数字的指令会保持剩下的字节不变；生成 4 字节数字的指令会把高位 4 个字节置为) Tj
T*
(0。后面这条规则是作为从 IA32 到 x86-64 的扩展的一部分而采用的。) Tj
T*
() Tj
T*
ET
endstream
endobj
383 0 obj
<< /Length 4385 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(就像图 3-2 右边的解释说明的那样，在常见的程序里不同的寄存器扮演不同的角色。其中最特别的是栈指针 %rsp，用来指明运行时栈的结束位置。有些程序会明确地读写这个寄存器。另外) Tj
T*
(15 个寄存器的用法更灵活。少量指令会使用某些特定的寄存器。更重要的是，有一组标准的编程规范控制着如何使用寄存器来管理栈、传递函数参数、从函数的返回值，以及存储局部和临时数据。我们) Tj
T*
(会在描述过程的实现时（特别是在 3.7 节中），讲述这些惯例。) Tj
T*
() Tj
T*
(3.4.1 操作数指示符) Tj
T*
() Tj
T*
() Tj
T*
(大多数指令有一个或多个操作数（operand），指示出执行一个操作中要使用的源数据值，以及放置结果的目的位置。x86-64 支持多种操作数格式（参见图) Tj
T*
(3-3）。源数据值可以以常数形式给出，或是从寄存器或内存中读出。结果可以存放在寄存器或内存中。因此，各种不同的操作数的可能性被分为三种类型。) Tj
T*
() Tj
T*
(* 第一种类型是立即数（immediate），用来表示常数值。在 ATT 格式的汇编代码中，立即数的书写方式是 ‘$’ 后面跟一个用标准 C 表示法表示的整数，比如，$-577 或) Tj
T*
($0x1F。不同的指令允许的立即数值范围不同，汇编器会自动选择最紧凑的方式进行数值编码。) Tj
T*
(* 第二种类型是寄存器（register），它表示某个寄存器的内容，16 个寄存器的低位 1 字节、2 字节、4 字节或 8 字节中的一个作为操作数，这些字节数分别对应于 8) Tj
T*
(位、16 位、32 位或 64 位。在图 3-3 中，我们用符号 $$\\rm ra$$ 来表示任意寄存器 a，用引用$$\\rm) Tj
T*
(R[ra]$$来表示它的值，这是将寄存器集合看成一个数组 R，用寄存器标识符作为索引。) Tj
T*
(* 第三类操作数是内存引用，它会根据计算出来的地址（通常称为有效地址）访问某个内存位置。因为将内存看成一个很大的字节数组，我们用符号$$\\rm) Tj
T*
(M_b[Addr]$$表示对存储在内存中从地址 Addr 开始的 b 个字节值的引用。为了简便，我们通常省去下标 b。) Tj
T*
() Tj
T*
(如图 3-3 所示，有多种不同的寻址模式，允许不同形式的内存引用。表中底部用语法 $$Imm\(rb,ri,s\)$$ 表示的是最常用的形式。这样的引用有四个组成部分：一个立即数偏移) Tj
T*
(Imm，一个基址寄存器$$rb$$，一个变址寄存器$$ri$$，和一个比例因子 s，这里 s 必须是 1、2、4 或者 8. 基址和变址寄存器都必须是 64) Tj
T*
(位寄存器。有效地址被计算为$$Imm  +R[rb]+R[ri] \\cdot) Tj
T*
(s$$。引用数组元素时，会用到这种通用形式。其他形式都是这种通用形式的特殊情况，只是省略了某些部分。正如我们将看到的，当引用数组和结构元素时，比较复杂的寻址模式是很有用的。) Tj
T*
() Tj
T*
(| 类型 | 格式 | 操作数值 | 名称 |) Tj
T*
(| :---: | :--- | :--- | :--- |) Tj
T*
(| 立即数 | $$$Imm$$  | $$Imm$$  | 立即数寻址 |) Tj
T*
(| 寄存器 | $$ra$$  | $$R[ra]$$  | 寄存器寻址 |) Tj
T*
(| 存储器 | $$Imm$$ | $$M[Imm]$$  | 绝对寻址 |) Tj
T*
(| 存储器 | $$\(ra\)$$  | $$M[R[ra]]$$ | 间接寻址 |) Tj
T*
(| 存储器 | $$Imm\(rb\)$$  | $$M[Imm+R[rb]]$$ | （基址+偏移量）寻址 |) Tj
T*
(| 存储器 | $$\(rb,ri\)$$  | $$M[R[rb]+R[ri]]$$ | 变址寻址 |) Tj
T*
(| 存储器 | $$Imm\(rb,ri\)$$ | $$M[Imm+R[rb]+R[ri]]$$ | 变址寻址 |) Tj
T*
(| 存储器 | $$\(,ri,s\)$$ | $$M[R[ri]\\cdot s]$$ | 比例变址寻址 |) Tj
T*
(| 存储器 | $$Imm\(,ri,s\)$$ | $$M[Imm+R[ri]\\cdot s]$$ | 比例变址寻址 |) Tj
T*
(| 存储器 | $$\(rb,ri,s\)$$ | $$M[R[rb]+R[ri]\\cdot s]$$ | 比例变址寻址 |) Tj
T*
(| 存储器 | $$Imm\(rb,ri,s\)$$ | $$M[Imm+R[rb]+R[ri]\\cdot s]$$ | 比例变址寻址 |) Tj
T*
() Tj
T*
(> 图 3-3 操作数格式。操作数可以表示立即数（常数）值、寄存器值或是来自内存的值，比例因子 s 必须是 1、2，4 或者 8) Tj
T*
() Tj
T*
(练习题 3.1) Tj
T*
() Tj
T*
() Tj
T*
(假设下面的值存放在指明的内存地址和寄存器中：) Tj
T*
() Tj
T*
(| 地址 | 值 |) Tj
T*
(| :---: | :---: |) Tj
T*
ET
endstream
endobj
384 0 obj
<< /Length 2027 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(| 0x100 | 0xFF |) Tj
T*
(| 0x104 | 0xAB |) Tj
T*
(| 0x108 | 0x13 |) Tj
T*
(| 0x10C | 0x11 |) Tj
T*
() Tj
T*
(| 寄存器 | 值 |) Tj
T*
(| :---: | :---: |) Tj
T*
(| %rax | 0x100 |) Tj
T*
(| %rcx | 0x1 |) Tj
T*
(| %rdx | 0x3 |) Tj
T*
() Tj
T*
(填写下表，给出所示操作数的值：) Tj
T*
() Tj
T*
(| 操作数 | 值 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| %rax |  |) Tj
T*
(| 0x104 |  |) Tj
T*
(| $0x108 |  |) Tj
T*
(| \\\(%rax\\\) |  |) Tj
T*
(| 4\\\(%rax\\\) |  |) Tj
T*
(| 9\\\(%rax,%rdx\\\) |  |) Tj
T*
(| 260\\\(%rcx,%rdx\\\) |  |) Tj
T*
(| 0xFC\\\(,%rcx,4\\\) |  |) Tj
T*
(| \\\(%rax,%rdx,4\\\) |  |) Tj
T*
() Tj
T*
(3.4.2 数据传送指令) Tj
T*
() Tj
T*
() Tj
T*
(最频繁使用的指令是将数据从一个位置复制到另一个位置的指令。操作数表示的通用性使得一条简单的数据传送指令能够完成在许多机器中要好几条不同指令才能完成的功能。我们会介绍多种不同的数据传) Tj
T*
(送指令，它们或者源和目的类型不同，或者执行的转换不同，或者具有的一些副作用不同。在我们的讲述中，把许多不同的指令划分成指令类，每一类中的指令执行相同的操作，只不过操作数大小不同。) Tj
T*
() Tj
T*
(图 3-4 列出的是最简单形式的数据传送指令——MOV 类。这些指令把数据从源位置复制到目的位置，不做任何变化。MOV 类由四条指令组成：movb、movw、movl 和) Tj
T*
(movq。这些指令都执行同样的操作；主要区别在于它们操作的数据大小不同：分别是 1、2、4 和 8 字节。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(| 指令 | 效果 | 描述 |) Tj
T*
(| :--- | :---: | :--- |) Tj
T*
(| MOV          S, D | D ← S | 传送 |) Tj
T*
(| movb |  | 传送字节 |) Tj
T*
(| movw |  | 传送字 |) Tj
T*
(| movl |  | 传送双字 |) Tj
T*
(| movq |  | 传送四字 |) Tj
T*
(| movabsq   I, R | R ← I | 传送绝对的四字 |) Tj
T*
() Tj
T*
(> 图 3-4 简单的数据传送指令) Tj
T*
ET
endstream
endobj
385 0 obj
<< /Length 4246 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(源操作数指定的值是一个立即数，存储在寄存器中或者内存中。目的操作数指定一个位置，要么是一个寄存器或者，要么是一个内存地址。X86-64) Tj
T*
(加了一条限制，传送指令的两个操作数不能都指向内存位置。将一个值从一个内存位置复制到另一个内存位置需要两条指令一第一条指令将源值加载到寄存器中，第二条将该寄存器值写入目的位置。参考图) Tj
T*
(3-2，这些指令的寄存器操作数可以是 16 个寄存器有标号部分中的任意一个，寄存器部分的大小必须与指令最后一个字符（‘b’，‘w’，‘l’ 或) Tj
T*
(‘q’）指定的大小匹配。大多数情况中，MOV 指令只会更新目的操作数指定的那些寄存器字节或内存位置。唯一的例外是 movl 指令以寄存器作为目的时，它会把该寄存器的高位 4) Tj
T*
(字节设置为 0。造成这个例外的原因是 x86-64 采用的惯例，即任何为寄存器生成 32 位值的指令都会把该寄存器的高位部分置成 0。) Tj
T*
() Tj
T*
(下面的 MOV 指令示例给出了源和目的类型的五种可能的组合。记住，第一个是源操作数，第二个是目的操作数：) Tj
T*
() Tj
T*
(    movl $0x4050,%eax       # Immediate--Register,  4 bytes) Tj
T*
(    movw %bp,%sp            # Register--Register,   2 bytes) Tj
T*
(    movb \(%rdi,%rcx\),%al    # Memory--Register,     1 byte) Tj
T*
(    movb $-17,\(%esp\)        # Immediate--Memory,    1 byte) Tj
T*
(    movq %rax,-12\(%rbp\)     # Register--Memory,     8 bytes) Tj
T*
() Tj
T*
(图 3-4 中记录的最后一条指令是处理 64 位立即数数据的。常规的 movq 指令只能以表示为 32 位补码数字的立即数作为源操作数，然后把这个值符号扩展得到 64) Tj
T*
(位的值，放到目的位置。movabsq 指令能够以任意 64 位立即数值作为源操作数，并且只能以寄存器作为目的。) Tj
T*
() Tj
T*
(图 3-5 和图 3-6 记录的是两类数据移动指令，在将较小的源值复制到较大的目的时使用。所有这些指令都把数据从源（在寄存器或内存中）复制到目的寄存器。MOVZ) Tj
T*
(类中的指令把目的中剩余的字节填充为 0，而 MOVS 类中的指令通过符号扩展来填充，把源操作的最高位进行复制。可以观察到，每条指令名字的最后两个字符都是大小指示符：第一个字符指定源) Tj
T*
(的大小，而第二个指明目的的大小。正如看到的那样，这两个类中每个都有三条指令，包括了所有的源大小为 1 个和 2 个字节、目的大小为 2 个和 4) Tj
T*
(个的情况，当然只考虑目的大于源的情况。) Tj
T*
() Tj
T*
(| 指令 | 效果 | 描述 |) Tj
T*
(| :--- | :--- | :--- |) Tj
T*
(| MOVZ       S, R | R ← 零扩展（S） | 以零扩展进行传送 |) Tj
T*
(| movzbw |  | 将做了零扩展的字节传送到字 |) Tj
T*
(| movzbl |  | 将做了零扩展的字节传送到双字 |) Tj
T*
(| movzwl |  | 将做了零扩展的字传送到双字 |) Tj
T*
(| movzbq |  | 将做了零扩展的字节传送到四字 |) Tj
T*
(| movzwq |  | 将做了零扩展的字传送到四字 |) Tj
T*
() Tj
T*
(> 图 3-5 零扩展数据传送指令。这些指令以寄存器或内存地址作为源，以寄存器作为目的) Tj
T*
() Tj
T*
(| 指令 | 效果 | 描述 |) Tj
T*
(| :--- | :--- | :--- |) Tj
T*
(| MOVS        S, R | R ← 符号扩展（S） | 传送符号扩展的字节 |) Tj
T*
(| movsbw |  | 将做了符号扩展的字节传送到字 |) Tj
T*
(| movsbl |  | 将做了符号扩展的字节传送到双字 |) Tj
T*
(| movswl |  | 将做了符号扩展的字传送到双字 |) Tj
T*
(| movsbq |  | 将做了符号扩展的字节传送到四字 |) Tj
T*
(| movswq |  | 将做了符号扩展的字传送到四字 |) Tj
T*
(| movslq |  | 将做了符号扩展的双字传送到四字 |) Tj
T*
(| cltq | %rax ← 符号扩展（%eax） | 把 %eax 符号扩展到 %rax |) Tj
T*
() Tj
T*
(> 图 3-6 符号扩展数据传送指令。MOVS 指令以寄存器或内存地址作为源，以寄存器作为目的。cltq 指令只作用于寄存器 %eax 和 %rax) Tj
T*
ET
endstream
endobj
386 0 obj
<< /Length 3072 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(旁注 - 理解数据传送如何改变目的寄存器) Tj
T*
() Tj
T*
() Tj
T*
(正如我们描述的那样，关于数据传送指令是否以及如何修改目的寄存器的高位字节有两种不同的方法。下面这段代码序列会说明其差别：) Tj
T*
() Tj
T*
(    movl $0x4050,%eax        # Immediate--Register, 4 bytes) Tj
T*
(    movw %bp,%sp             # Register--Register,  2 bytes) Tj
T*
(    movb \(%rdi,%rcx\),%al     # Memory--Register,    1 byte) Tj
T*
(    movb $-17,\(%esp\)         # Immediate--Memory,   1 byte) Tj
T*
(    movq %rax,-12\(%rbp\)      # Register--Memory,    8 bytes) Tj
T*
() Tj
T*
(在接下来的讨论中，我们使用十六进制表示。在这个例子中，第 1 行的指令把寄存器 %rax 初始化为位模式 0011223344556677。剩下的指令的源操作数值是立即数值) Tj
T*
(-1。回想 -1 的十六进制表示形如 FF⋯F，这里 F 的数量是表述中字节数量的两倍。因此 movb 指令（第 2 行）把 %rax 的低位字节设置为 FF，而 movw) Tj
T*
(指令（第 3 行）把低 2 位字节设置为 FFFF，剩下的字节保持不变。movl 指令（第 4 行）将低 4 个字节设置为 FFFFFFFF，同时把高位 4 字节设置为) Tj
T*
(00000000。最后 movq 指令（第 5 行）把整个寄存器设置为 FFFFFFFFFFFFFFFF。) Tj
T*
() Tj
T*
(注意图 3-5 中并没有一条明确的指令把 4 字节源值零扩展到 8 字节目的。这样的指令逻辑上应该被命名为) Tj
T*
(movzlq，但是并没有这样的指令。不过，这样的数据传送可以用以寄存器为目的的 movl 指令来实现。这一技术利用的属性是，生成 4 字节值并以寄存器作为目的的指令会把高 4) Tj
T*
(字节置为 0。对于 64 位的目标，所有三种源类型都有对应的符号扩展传送，而只有两种较小的源类型有零扩展传送。) Tj
T*
() Tj
T*
(图 3-6 还给出 cltq 指令。这条指令没有操作数：它总是以寄存器 %eax 作为源，%rax 作为符号扩展结果的目的。它的效果与指令 movslq %eax,%rax) Tj
T*
(完全一致，不过编码更紧凑。) Tj
T*
() Tj
T*
(练习题 3.2) Tj
T*
() Tj
T*
() Tj
T*
(对于下面汇编代码的每一行，根据操作数，确定适当的指令后缀。（例如，mov 可以被重写成 movb、movw、movl 或者 movq。）) Tj
T*
() Tj
T*
(    mov_   %eax, \(%rsp\)) Tj
T*
(    mov_   \(%rax\), %dx) Tj
T*
(    mov_   $0xFF, %bl) Tj
T*
(    mov_   \(%rsp,%rdx,4\), %dl) Tj
T*
(    mov_   \(%rdx\), %rax) Tj
T*
(    mov_   %dx, \(%rax\)) Tj
T*
() Tj
T*
(旁注 - 字节传送指令比较) Tj
T*
() Tj
T*
() Tj
T*
(下面这个示例说明了不同的数据传送指令如何改变或者不改变目的的高位字节。仔细观察可以发现，三个字节传送指令 movb、movsbq 和 movzbq 之间有细微的差别。示例如下：) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(第 4 章：处理器体系结构) Tj
T*
ET
endstream
endobj
387 0 obj
<< /Length 3279 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(================================================================================) Tj
T*
() Tj
T*
(第 4 章：处理器体系结构) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(第 5 章：优化程序性能) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(第 5 章：优化程序性能) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(第 6 章：存储器层次结构) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(第 6 章：存储器层次结构) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(第 7 章：链接) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(第 7 章：链接) Tj
T*
() Tj
T*
() Tj
T*
(第二部分：在系统上运行程序) Tj
T*
() Tj
T*
() Tj
T*
(继续我们对计算机系统的探索，进一步来看看构建和运行应用程序的系统软件。链接器把程序的各个部分联合成一个文件，处理器可以将这个文件加载到内存，并且执行它。现代操作系统与硬件合作，为每) Tj
T*
(个程序提供一种幻象，好像这个程序是在独占地使用处理器和主存，而实际上，在任何时刻，系统上都有多个程序在运行。) Tj
T*
() Tj
T*
(在本书的第一部分，你很好地理解了程序和硬件之间的交互关系。本书的第二部分将拓宽你对系统的了解，使你牢固地掌握程序和操作系统之间的交互关系。你将学习到如何使用操作系统提供的服务来构建) Tj
T*
(系统级程序，例如 Unix shell 和动态内存分配包。) Tj
T*
() Tj
T*
(链接（linking）是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。链接可以执行于编译时（compile) Tj
T*
(time），也就是在源代码被翻译成机器代码时；也可以执行于加载时（load time），也就是在程序被加载器（loader）加载到内存并执行时；甚至执行于运行时（runtime），) Tj
T*
(也就是由应用程序来执行。在早期的计算机系统中，链接是手动执行的。在现代系统中，链接是由叫做链接器（linker）的程序自动执行的。) Tj
T*
() Tj
T*
(链接器在软件开发中扮演着一个关键的角色，因为它们使得分离编译（separate compilation）成为可能。我们不用将一个大型的应用程序组织为一个巨大的源文件，而是可以把它分) Tj
T*
(解为更小、更好管理的模块，可以独立地修改和编译这些模块。当我们改变这些模块中的一个时，只需简单地重新编译它，并重新链接应用，而不必重新编译其他文件。) Tj
T*
() Tj
T*
(链接通常是由链接器来默默地处理的，对于那些在编程入门课堂上构造小程序的学生而言，链接不是一个重要的议题。那为什么还要这么麻烦地学习关于链接的知识呢？) Tj
T*
ET
endstream
endobj
388 0 obj
<< /Length 3698 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(* 理解链接器将帮助你构造大型程序。构造大型程序的程序员经常会遇到由于缺少模块、缺少库或者不兼容的库版本引起的链接器错误。除非你理解链接器是如何解析引用、什么是库以及链接器是如何使) Tj
T*
(用库来解析引用的，否则这类错误将令你感到迷惑和挫败。) Tj
T*
(* 理解链接器将帮助你避免一些危险的编程错误。Linux 链接器解析符号引用时所做的决定可以不动声色地影响你程序的正确性。在默认情况下，错误地定义多个全局变量的程序将通过链接器，而) Tj
T*
(不产生任何警告信息。由此得到的程序会产生令人迷惑的运行时行为，而且非常难以调试。我们将向你展示这是如何发生的，以及该如何避免它。) Tj
T*
(* 理解链接将帮助你理解语言的作用域规则是如何实现的。例如，全局和局部变量之间的区别是什么？当你定义一个具有 static 属性的变量或者函数时，实际到底意味着什么？) Tj
T*
(* 理解链接将帮助你理解其他重要的系统概念。链接器产生的可执行目标文件在重要的系统功能中扮演着关键角色，比如加载和运行程序、虚拟内存、分页、内存映射。) Tj
T*
(* 理解链接将使你能够利用共享库。多年以来，链接都被认为是相当简单和无趣的。然而，随着共享库和动态链接在现代操作系统中重要性的日益加强，链接成为一个复杂的过程，为掌握它的程序员提供) Tj
T*
(了强大的能力。比如，许多软件产品在运行时使用共享库来升级压缩包装的（shrink-wrapped）二进制程序。还有，大多数 Web 服务器都依赖于共享库的动态链接来提供动态内容。) Tj
T*
() Tj
T*
(这一章提供了关于链接各方面的全面讨论，从传统静态链接到加载时的共享库的动态链接，以及到运行时的共享库的动态链接。我们将使用实际示例来描述基本的机制，而且指出链接问题在哪些情况中会影) Tj
T*
(响程序的性能和正确性。为了使描述具体和便于理解，我们的讨论是基于这样的环境：一个运行 Linux 的 x86-64 系统，使用标准的 ELF-64（此后称为) Tj
T*
(ELF）目标文件格式。不过，无论是什么样的操作系统、ISA 或者目标文件格式，基本的链接概念是通用的，认识到这一点是很重要的。细节可能不尽相同，但是概念是相同的。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.1 编译器驱动程序) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.1 编译器驱动程序) Tj
T*
() Tj
T*
() Tj
T*
(考虑图 7-1 中的 C 语言程序。它将作为贯穿本章的一个小的运行示例，帮助我们说明关于链接是如何工作的一些重要知识点。) Tj
T*
() Tj
T*
(    int sum\(int *a, int n\);) Tj
T*
() Tj
T*
(    int array[2] = {1, 2};) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int val = sum\(array, 2\);) Tj
T*
(        return val;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int sum\(int *a, int n\)) Tj
T*
(    {) Tj
T*
(        int i, s = 0;) Tj
T*
() Tj
T*
(        for \(i = 0; i < n; i++\) {) Tj
T*
(            s += a[i];) Tj
T*
(        }) Tj
T*
(        return s;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 7-1 示例程序 1。这个示例程序由两个源文件组成，main.c 和 sum.c。main 函数初始化一个整数数组，然后调用 sum 函数来对数组元素求和) Tj
T*
() Tj
T*
ET
endstream
endobj
389 0 obj
<< /Length 2682 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(大多数编译系统提供编译器驱动程序（compiler driver），它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。比如，要用 GNU) Tj
T*
(编译系统构造示例程序，我们就要通过在 shell 中输入下列命令来调用 GCC 驱动程序：) Tj
T*
() Tj
T*
(    linux> gcc -Og -o prog main.c sum.c) Tj
T*
() Tj
T*
(图 7-2 概括了驱动程序在将示例程序从 ASCII 码源文件翻译成可执行目标文件时的行为。（如果你想看看这些步骤，用 -v 选项来运行 GCC。）驱动程序首先运行 ✦C) Tj
T*
(预处理器（cpp）✦，它将 C 的源程序 main.c 翻译成一个 ASCII 码的中间文件 main.i：) Tj
T*
() Tj
T*
(    cpp [other arguments] main.c /tmp/main.i) Tj
T*
() Tj
T*
(✦C 预处理器（cpp）✦：在某些 GCC 版本中，预处理器被集成到编译器驱动程序中。) Tj
T*
() Tj
T*
([Image: &#x56FE; 7-2 &#x9759;&#x6001;&#x94FE;&#x63A5;&#x3002;&#x94FE;&#x63A5;&#x5668;&#x5C) Tj
T*
(06;&#x53EF;&#x91CD;&#x5B9A;&#x4F4D;&#x76EE;&#x6807;&#x6587;&#x4EF6;&#x7EC4;&#x5408;&#x8D77) Tj
T*
(;&#x6765;&#xFF0C;&#x5F62;&#x6210;&#x4E00;&#x4E2A;&#x53EF;&#x6267;&#x884C;&#x76EE;&#x6807;&) Tj
T*
(#x6587;&#x4EF6; prog]) Tj
T*
() Tj
T*
(接下来，驱动程序运行 C 编译器（cc1），它将 main.i 翻译成一个 ASCII 汇编语言文件 main.s：) Tj
T*
() Tj
T*
(    cc1 /tmp/main.i -Og [other arguments] -o /tmp/main.s) Tj
T*
() Tj
T*
(然后，驱动程序运行汇编器（as），它将 main.s 翻译成一个可重定位目标文件（relocatable object file）main.o：) Tj
T*
() Tj
T*
(    as [other arguments] -o /tmp/main.o /tmp/main.s) Tj
T*
() Tj
T*
(驱动程序经过相同的过程生成 sum.o。最后，它运行链接器程序 ld，将 main.o 和 sum.o) Tj
T*
(以及一些必要的系统目标文件组合起来，创建一个可执行目标文件（executable object file）prog：) Tj
T*
() Tj
T*
(    ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o) Tj
T*
() Tj
T*
(要运行可执行文件 prog，我们在 Linux shell 的命令行上输入它的名字：) Tj
T*
() Tj
T*
(    linux> ./prog) Tj
T*
() Tj
T*
(shell 调用操作系统中一个叫做加载器（loader）的函数，它将可执行文件 prog 中的代码和数据复制到内存，然后将控制转移到这个程序的开头。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.2 静态链接) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.2 静态链接) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
390 0 obj
<< /Length 4331 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(像 Linux LD 程序这样的静态链接器（static linker）以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入) Tj
T*
(的可重定位目标文件由各种不同的代码和数据节（section）组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中。) Tj
T*
() Tj
T*
(为了构造可执行文件，链接器必须完成两个主要任务：) Tj
T*
() Tj
T*
(* 符号解析（symbol resolution）。目标文件定义和引用符号，每个符号对应于一个函数、一个全局变量或一个静态变量（即 C 语言中任何以 static) Tj
T*
(属性声明的变量）。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。) Tj
T*
(* 重定位（relocation）。编译器和汇编器生成从地址 0 开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用) Tj
T*
(，使得它们指向这个内存位置。链接器使用汇编器产生的重定位条目（relocation entry）的详细指令，不加甄别地执行这样的重定位。) Tj
T*
() Tj
T*
(接下来的章节将更加详细地描述这些任务。在你阅读的时候，要记住关于链接器的一些基本事实：目标文件纯粹是字节块的集合。这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导链) Tj
T*
(接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工) Tj
T*
(作。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.3 目标文件) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.3 目标文件) Tj
T*
() Tj
T*
() Tj
T*
(目标文件有三种形式：) Tj
T*
() Tj
T*
(* 可重定位目标文件。包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。) Tj
T*
(* 可执行目标文件。包含二进制代码和数据，其形式可以被直接复制到内存并执行。) Tj
T*
(* 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。) Tj
T*
() Tj
T*
(编译器和汇编器生成可重定位目标文件（包括共享目标文件）。链接器生成可执行目标文件。从技术上来说，一个目标模块（object) Tj
T*
(module）就是一个字节序列，而一个目标文件（object file）就是一个以文件形式存放在磁盘中的目标模块。不过，我们会互换地使用这些术语。) Tj
T*
() Tj
T*
(目标文件是按照特定的目标文件格式来组织的，各个系统的目标文件格式都不相同。从贝尔实验室诞生的第一个 Unix 系统使用的是 a.out 格式（直到今天，可执行文件仍然称为) Tj
T*
(a.out 文件）。Windows 使用可移植可执行（Portable Executable，PE）格式。MacOS-X 使用 Mach-O 格式。现代 x86-64 Linux) Tj
T*
(和 Unix 系统使用可执行可链接格式（Executable and Linkable Format，ELF）。尽管我们的讨论集中在 ELF) Tj
T*
(上，但是不管是哪种格式，基本的概念是相似的。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.4 可重定位目标文件) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.4 可重定位目标文件) Tj
T*
() Tj
T*
() Tj
T*
(图 7-3 展示了一个典型的 ELF 可重定位目标文件的格式。ELF 头（ELF header）以一个 16) Tj
T*
(字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 ELF) Tj
T*
ET
endstream
endobj
391 0 obj
<< /Length 4709 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(头的大小、目标文件的类型（如可重定位、可执行或者共享的）、机器类型（如 X86-64）、节头部表（section header) Tj
T*
(table）的文件偏移，以及节头部表中条目的大小和数量。不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的条目（entry）。) Tj
T*
() Tj
T*
([Image: &#x56FE; 7-3 &#x5178;&#x578B;&#x7684; ELF) Tj
T*
(&#x53EF;&#x91CD;&#x5B9A;&#x4F4D;&#x76EE;&#x6807;&#x6587;&#x4EF6;]) Tj
T*
() Tj
T*
(夹在 ELF 头和节头部表之间的都是节。一个典型的 ELF 可重定位目标文件包含下面几个节：) Tj
T*
() Tj
T*
(* .text：已编译程序的机器代码。) Tj
T*
(* .rodata：只读数据，比如 printf 语句中的格式串和开关语句的跳转表。) Tj
T*
(* .data：已初始化的全局和静态 C 变量。局部 C 变量在运行时被保存在栈中，既不岀现在 .data 节中，也不岀现在 .bss 节中。) Tj
T*
(* .bss：未初始化的全局和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变) Tj
T*
(量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。) Tj
T*
(* .symtab：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误地认为必须通过 -g) Tj
T*
(选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP) Tj
T*
(命令去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。) Tj
T*
(* .rel.text：一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一) Tj
T*
(方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。) Tj
T*
(* .rel.data：被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。) Tj
T*
(* .debug：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有以 - g 选项调用编译器驱动程序时，才) Tj
T*
(会得到这张表。) Tj
T*
(* .line：原始 C 源程序中的行号和 .text 节中机器指令之间的映射。只有以 -g 选项调用编译器驱动程序时，才会得到这张表。) Tj
T*
(* .strtab：一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部中的节名字。字符串表就是以 null 结尾的字符串的序列。) Tj
T*
() Tj
T*
(旁注 - 为什么未初始化的数据称为 .bss) Tj
T*
() Tj
T*
() Tj
T*
(用术语 .bss 来表示未初始化的数据是很普遍的。它起始于 IBM 704 汇编语言（大约在 1957 年）中“块存储开始（Block Storage) Tj
T*
(Start）”指令的首字母缩写，并沿用至今。一种记住 .data 和 .bss 节之间区别的简单方法是把 “bss” 看成是“更好地节省空间（Better Save Space）”) Tj
T*
(的缩写。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.5 符号和符号表) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.5 符号和符号表) Tj
T*
() Tj
T*
() Tj
T*
(每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：) Tj
T*
() Tj
T*
(* 由模块 m 定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的 C 函数和全局变量。) Tj
T*
(* 由其他模块定义并被模块 m 引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态 C 函数和全局变量。) Tj
T*
(* 只被模块 m 定义和引用的局部符号。它们对应于带 static 属性的 C 函数和全局变量。这些符号在模块 m 中任何位置都可见，但是不能被其他模块引用。) Tj
T*
ET
endstream
endobj
392 0 obj
<< /Length 3239 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(认识到本地链接器符号和本地程序变量不同是很重要的。.symtab 中的符号表不包含对应于本地非静态程序变量的任何符号。这些符号在运行时在栈中被管理，链接器对此类符号不感兴趣。) Tj
T*
() Tj
T*
(有趣的是，定义为带有 C static 属性的本地过程变量是不在栈中管理的。相反，编译器在 .data 或 .bss) Tj
T*
(中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号。 比如，假设在同一模块中的两个函数各自定义了一个静态局部变量 x：) Tj
T*
() Tj
T*
(    int f\(\)) Tj
T*
(    {) Tj
T*
(        static int x = 0;) Tj
T*
(        return x;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int g\(\)) Tj
T*
(    {) Tj
T*
(        static int x = 1;) Tj
T*
(        return x;) Tj
T*
(    }) Tj
T*
() Tj
T*
(在这种情况中，编译器向汇编器输出两个不同名字的局部链接器符号。比如，它可以用 x.1 表示函数 f 中的定义，而用 x.2 表示函数 g 中的定义。) Tj
T*
() Tj
T*
(给 C 语言初学者 - 利用 static 属性隐藏变量和函数名字) Tj
T*
() Tj
T*
() Tj
T*
(C 程序员使用 static 属性隐藏模块内部的变量和函数声明，就像你在 Java 和 C++ 中使用 public 和 private 声明一样。在 C) Tj
T*
(中，源文件扮演模块的角色。任何带有 static 属性声明的全局变量或者函数都是模块私有的。类似地，任何不带 static) Tj
T*
(属性声明的全局变量和函数都是公共的，可以被其他模块访问。尽可能用 static 属性来保护你的变量和函数是很好的编程习惯。) Tj
T*
() Tj
T*
(符号表是由汇编器构造的，使用编译器输出到汇编语言 .s 文件中的符号。.symtab 节中包含 ELF 符号表。这张符号表包含一个条目的数组。图 7-4 展示了每个条目的格式。) Tj
T*
() Tj
T*
(    typedef struct {) Tj
T*
(        int     name;      /* String table offset */) Tj
T*
(        char    type:4,    /* Function or data \(4 bits\) */) Tj
T*
(                binding:4; /* Local or global \(4 bits\) */) Tj
T*
(        char    reserved;  /* Unused */) Tj
T*
(        short   section;   /* Section header index */) Tj
T*
(        long    value;     /* Section offset or absolute address */) Tj
T*
(        long    size;      /* Object size in bytes */) Tj
T*
(    } Elf64_Symbol;) Tj
T*
() Tj
T*
(> 图 7-4 ELF 符号表条目。type 和 binding 字段每个都是 4 位) Tj
T*
() Tj
T*
(name 是字符串表中的字节偏移，指向符号的以 null 结尾的字符串名字。value 是符号的地址。对于可重定位的模块来说，value) Tj
T*
(是距定义目标的节的起始位置的偏移。对于可执行目标文件来说，该值是一个绝对运行时地址。size 是目标的大小（以字节为单位）。type) Tj
T*
(通常要么是数据，要么是函数。符号表还可以包含各个节的条目，以及对应原始源文件的路径名的条目。所以这些目标的类型也有所不同。binding 字段表示符号是本地的还是全局的。) Tj
T*
() Tj
T*
(每个符号都被分配到目标文件的某个节，由 section) Tj
T*
ET
endstream
endobj
393 0 obj
<< /Length 3155 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(字段表示，该字段也是一个到节头部表的索引。有三个特殊的伪节（pseudosection），它们在节头部表中是没有条目的：ABS 代表不该被重定位的符号；UNDEF) Tj
T*
(代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号；COMMON 表示还未被分配位置的未初始化的数据目标。对于 COMMON 符号，value) Tj
T*
(字段给出对齐要求，而 size 给出最小的大小。注意，只有可重定位目标文件中才有这些伪节，可执行目标文件中是没有的。) Tj
T*
() Tj
T*
(COMMON 和 .bss 的区别很细微。现代的 GCC 版本根据以下规则来将可重定位目标文件中的符号分配到 COMMON 和 .bss 中：) Tj
T*
() Tj
T*
(|  |  |) Tj
T*
(| :--- | :--- |) Tj
T*
(| COMMON | 未初始化的全局变量 |) Tj
T*
(| .bss | 未初始化的静态变量，以及初始化为 0 的全局或静态变量 |) Tj
T*
() Tj
T*
(釆用这种看上去很绝对的区分方式的原因来自于链接器执行符号解析的方式，我们会在 7.6 节中加以解释。) Tj
T*
() Tj
T*
(GNU READELF 程序是一个査看目标文件内容的很方便的工具。比如，下面是图 7-1 中示例程序的可重定位目标文件 main.o 的符号表中的最后三个条目。开始的 8) Tj
T*
(个条目没有显示出来，它们是链接器内部使用的局部符号。) Tj
T*
() Tj
T*
(| Num: | Value | Size | Type | Bind | Vis | Ndx | Name |) Tj
T*
(| ---: | :---: | ---: | :--- | :--- | :--- | ---: | :--- |) Tj
T*
(| 8: | 0000000000000000 | 24 | FUNC | GLOBAL | DEFAULT | 1 | main |) Tj
T*
(| 9: | 0000000000000000 | 8 | OBJECT | GLOBAL | DEFAULT | 3 | array |) Tj
T*
(| 10: | 0000000000000000 | 0 | NOTYPE | GLOBAL | DEFAULT | UND | sum |) Tj
T*
() Tj
T*
(在这个例子中，我们看到全局符号 main 定义的条目，它是一个位于 .text 节中偏移量为 0（即 value 值）处的 24 字节函数。其后跟随着的是全局符号 array) Tj
T*
(的定义，它是一个位于 .data 节中偏移量为 0 处的 8 字节目标。最后一个条目来自对外部符号 sum 的引用。READELF 用一个整数索引来标识每个节。Ndx=1 表示) Tj
T*
(.text 节，而 Ndx=3 表示 .data 节。) Tj
T*
() Tj
T*
(练习题 7.1) Tj
T*
() Tj
T*
() Tj
T*
(这个题目针对图 7-5 中的 m.o 和 swap.o 模块。对于每个在 swap.o 中定义或引用的符号，请指出它是否在模块 swap.o 中的 .symtab) Tj
T*
(节中有一个符号表条目。如果是，请指出定义该符号的模块（swap.o 或者 m.o）、符号类型（局部、全局或者外部）以及它在模块中被分配到的节（.text、.data、.bss 或) Tj
T*
(COMMON）。) Tj
T*
() Tj
T*
(| 符号 | .symtab 条目？ | 符号类型 | 在哪个模块中定义 | 节 |) Tj
T*
(| :--- | :--- | :--- | :--- | :--- |) Tj
T*
(| buf |  |  |  |  |) Tj
T*
(| bufp0 |  |  |  |  |) Tj
T*
(| bufp1 |  |  |  |  |) Tj
T*
(| swap |  |  |  |  |) Tj
T*
(| temp |  |  |  |  |) Tj
T*
() Tj
T*
(    void swap\(\);) Tj
T*
() Tj
T*
(    int buf[2] = {1, 2};) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
ET
endstream
endobj
394 0 obj
<< /Length 2346 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    {) Tj
T*
(        swap\(\);) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    extern int buf[];) Tj
T*
() Tj
T*
(    int *bufp0 = &buf[0];) Tj
T*
(    int *bufp1;) Tj
T*
() Tj
T*
(    void swap\(\)) Tj
T*
(    {) Tj
T*
(        int temp;) Tj
T*
() Tj
T*
(        bufp1 = &buf[1];) Tj
T*
(        temp = *bufp0;) Tj
T*
(        *bufp0 = *bufp1;) Tj
T*
(        *bufp1 = temp;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 7-5 练习题 7.1 的示例程序) Tj
T*
() Tj
T*
(这道练习题的目的是帮助你理解链接器符号和 C 变量及函数之间的关系。注意 C 的局部变量 temp 没有符号表条目。) Tj
T*
() Tj
T*
(| 符号 | .symtab 条目？ | 符号类型 | 在哪个模块中定义 | 节 |) Tj
T*
(| :--- | :---: | :---: | :---: | :---: |) Tj
T*
(| buf | ✔️ | 外部 | main.o | .data |) Tj
T*
(| bufp0 | ✔️ | 全局 | swap.o | .data |) Tj
T*
(| bufp1 | ✔️ | 全局 | swap.o | COMMON |) Tj
T*
(| swap | ✔️ | 全局 | swap.o | .text |) Tj
T*
(| temp | ❌ | — | — | — |) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.6 符号解析) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.6 符号解析) Tj
T*
() Tj
T*
() Tj
T*
(链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器) Tj
T*
(只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。) Tj
T*
() Tj
T*
(不过，对全局符号的引用解析就棘手得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器) Tj
T*
(处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条（通常很难阅读的）错误信息并终止。比如，如果我们试着在一台 Linux 机器上编译和链接下面的源文件：) Tj
T*
() Tj
T*
ET
endstream
endobj
395 0 obj
<< /Length 3197 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    void foo\(void\);) Tj
T*
() Tj
T*
(    int main\(\) {) Tj
T*
(        foo\(\);) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(那么编译器会没有障碍地运行，但是当链接器无法解析对 foo 的引用时，就会终止：) Tj
T*
() Tj
T*
(    linux> gcc -Wall -Og -o linkerror linkerror.c) Tj
T*
(    /tmp/ccSz5uti.o: In function 'main':) Tj
T*
(    /tmp/ccSzSuti.o\(.text+0x7\): undefined reference to 'foo') Tj
T*
() Tj
T*
(对全局符号的符号解析很棘手，还因为多个目标文件可能会定义相同名字的全局符号。在这种情况中，链接器必须要么标志一个错误，要么以某种方法选出一个定义并抛弃其他定义。Linux) Tj
T*
(系统采纳的方法涉及编译器、汇编器和链接器之间的协作，这样也可能给不警觉的程序员带来一些麻烦。) Tj
T*
() Tj
T*
(旁注 - 对 C++ 和 Java 中链接器符号的重整) Tj
T*
() Tj
T*
() Tj
T*
(C++ 和 Java 都允许重载方法，这些方法在源代码中有相同的名字，却有不同的参数列表。那么链接器是如何区别这些不同的重载函数之间的差异呢？C++ 和 Java 中能使用重载函数) Tj
T*
(，是因为编译器将每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这种编码过程叫做重整（mangling），而相反的过程叫做恢复（demangling）。) Tj
T*
() Tj
T*
(幸运的是，C++ 和 Java 使用兼容的重整策略。一个被重整的类名字是由名字中字符的整数数量，后面跟原始名字组成的。比如，类 Foo 被编码成) Tj
T*
(3Foo。方法被编码为原始方法名，后面加上 \\\\，加上被重整的类名，再加上每个参数的单字母编码。比如，Foo::bar\(int, long\) 被编码为) Tj
T*
(bar\\\\3Fooil。重整全局变量和模板名字的策略是相似的。) Tj
T*
() Tj
T*
(7.6.1 链接器如何解析多重定义的全局符号) Tj
T*
() Tj
T*
() Tj
T*
(链接器的输入是一组可重定位目标模块。每个模块定义一组符号，有些是局部的（只对定义该符号的模块可见），有些是全局的（对其他模块也可见）。如果多个模块定义同名的全局符号，会发生什么呢？) Tj
T*
(下面是 Linux 编译系统采用的方法。) Tj
T*
() Tj
T*
(在编译时，编译器向汇编器输岀每个全局符号，或者是强（strong）或者是弱（weak），而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，) Tj
T*
(未初始化的全局变量是弱符号。) Tj
T*
() Tj
T*
(根据强弱符号的定义，Linux 链接器使用下面的规则来处理多重定义的符号名：) Tj
T*
() Tj
T*
(* 规则 1：不允许有多个同名的强符号。) Tj
T*
(* 规则 2：如果有一个强符号和多个弱符号同名，那么选择强符号。) Tj
T*
(* 规则 3：如果有多个弱符号同名，那么从这些弱符号中任意选择一个。) Tj
T*
() Tj
T*
(比如，假设我们试图编译和链接下面两个 C 模块：) Tj
T*
() Tj
T*
(    /* foo1.c */) Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
ET
endstream
endobj
396 0 obj
<< /Length 1335 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* bar1.c */) Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(在这个情况中，链接器将生成一条错误信息，因为强符号 main 被定义了多次（规则 1）：) Tj
T*
() Tj
T*
(    linux> gcc foo1.c bar1.c) Tj
T*
(    /tmp/ccq2Uxnd.o: In function 'main':) Tj
T*
(    bar1.c:\(.text+0x9\): multiple definition of 'main') Tj
T*
() Tj
T*
(相似地，链接器对于下面的模块也会生成一条错误信息，因为强符号 x 被定义了两次（规则 1）：) Tj
T*
() Tj
T*
(    /* foo2.c */) Tj
T*
(    int x = 15213;) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* bar2.c */) Tj
T*
(    int x = 15213;) Tj
T*
() Tj
T*
(    void f\(\)) Tj
T*
(    {) Tj
T*
(    }) Tj
T*
() Tj
T*
(然而，如果在一个模块里 x 未被初始化，那么链接器将安静地选择在另一个模块中定义的强符号（规则 2）：) Tj
T*
() Tj
T*
(    /* foo3.c */) Tj
T*
(    #include <stdio.h>) Tj
T*
(    void f\(void\);) Tj
T*
() Tj
T*
(    int x = 15213;) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        f\(\);) Tj
T*
(        printf\("x = %d\\n", x\)) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
ET
endstream
endobj
397 0 obj
<< /Length 1468 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(    /* bar3.c */) Tj
T*
(    int x;) Tj
T*
() Tj
T*
(    void f\(\)) Tj
T*
(    {) Tj
T*
(        x = 15212;) Tj
T*
(    }) Tj
T*
() Tj
T*
(在运行时，函数 f 将 x 的值由 15213 改为 15212，这会给 main 函数的作者带来不受欢迎的意外！注意，链接器通常不会表明它检测到多个 x 的定义：) Tj
T*
() Tj
T*
(    linux> gcc -o foobar3 foo3.c bar3.c) Tj
T*
(    linux> ./foobar3) Tj
T*
(    x = 15212) Tj
T*
() Tj
T*
(如果 x 有两个弱定义，也会发生相同的事情（规则 3）：) Tj
T*
() Tj
T*
(    /* foo4.c */) Tj
T*
(    #include <stdio.h>) Tj
T*
(    void f\(void\);) Tj
T*
() Tj
T*
(    int x;) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        x = 15213;) Tj
T*
(        f\(\);) Tj
T*
(        printf\("x = %d\\n", x\);) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* bar4.c */) Tj
T*
(    int x;) Tj
T*
() Tj
T*
(    void f\(\)) Tj
T*
(    {) Tj
T*
(        x = 15212;) Tj
T*
(    }) Tj
T*
() Tj
T*
(规则 2 和规则 3 的应用会造成一些不易察觉的运行时错误，对于不警觉的程序员来说，是很难理解的，尤其是如果重复的符号定义还有不同的类型时。考虑下面这个例子，其中 x) Tj
T*
(不幸地在一个模块中定义为 int，而在另一个模块中定义为 double：) Tj
T*
() Tj
T*
(    /* foo5.c */) Tj
T*
(    #include <stdio.h>) Tj
T*
(    void f\(void\);) Tj
T*
() Tj
T*
ET
endstream
endobj
398 0 obj
<< /Length 3077 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    int y = 15212;) Tj
T*
(    int x = 15213;) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        f\(\);) Tj
T*
(        printf\("x = 0x%x y = 0x%x \\n",) Tj
T*
(                x, y\);) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* bar5.c */) Tj
T*
(    double x;) Tj
T*
() Tj
T*
(    void f\(\)) Tj
T*
(    {) Tj
T*
(        x = -0.0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(在一台 x86-64/Linux 机器上，double 类型是 8 个字节，而 int 类型是 4 个字节。在我们的系统中，x 的地址是 0x601020，y 的地址是) Tj
T*
(0x601024。因此，bar5.c 的第 6 行中的赋值 x=-0.0 将用负零的双精度浮点表示覆盖内存中 x 和 y 的位置（foo5.c 中的第 5 行和第 6 行）！) Tj
T*
() Tj
T*
(    linux> gcc -Wall -Og -o foobar5 foo5. c bar5 .c) Tj
T*
(    /usr/bin/ld: Warning: alignment 4 of symbol 'x' in /tmp/cclUFK5g.o) Tj
T*
(    is smaller than 8 in /tmp/ccbTLcb9.o) Tj
T*
(    linux> ./foobar5) Tj
T*
(    x = 0x0 y = 0x80000000) Tj
T*
() Tj
T*
(这是一个细微而令人讨厌的错误，尤其是因为它只会触发链接器发出一条警告，而且通常要在程序执行很久以后才表现出来，且远离错误发生地。在一个拥有成百上千个模块的大型系统中，这种类型的错误) Tj
T*
(相当难以修正，尤其因为许多程序员根本不知道链接器是如何工作的。当你怀疑有此类错误时，用像 GCC-fno-common) Tj
T*
(标志这样的选项调用链接器，这个选项会告诉链接器，在遇到多重定义的全局符号时，触发一个错误。或者使用 -Werror 选项，它会把所有的警告都变为错误。) Tj
T*
() Tj
T*
(在 7.5 节中，我们看到了编译器如何按照一个看似绝对的规则来把符号分配为 COMMON 和) Tj
T*
(.bss。实际上，采用这个惯例是由于在某些情况中链接器允许多个模块定义同名的全局符号。当编译器在翻译某个模块时，遇到一个弱全局符号，比如说 x，它并不知道其他模块是否也定义了) Tj
T*
(x，如果是，它无法预测链接器该使用 x 的多重定义中的哪一个。所以编祥器把 x 分配成 COMMON，把决定权留给链接器。另一方面，如果 x 初始化为) Tj
T*
(0，那么它是一个强符号（因此根据规则 2 必须是唯一的），所以编译器可以很自信地将它分配成 .bss。类似地，静态符号的构造就必须是唯一的，所以编译器可以自信地把它们分配成) Tj
T*
(.data 或 .bss。) Tj
T*
() Tj
T*
(练习题 7.2) Tj
T*
() Tj
T*
() Tj
T*
(在此题中，REF\(x.i\) → DEF\(x.k\) 表示链接器将把模块 i 中对符号 x 的任意引用与模块 k 中 x) Tj
T*
(的定义关联起来。对于下面的每个示例，用这种表示法来说明链接器将如何解析每个模块中对多重定义符号的引用。如果有一个链接时错误（规则) Tj
T*
(1），写“错误”。如果链接器从定义中任意选择一个（规则 3），则写“未知”。) Tj
T*
() Tj
T*
(A.) Tj
T*
ET
endstream
endobj
399 0 obj
<< /Length 982 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(\(a\) REF\(main.1\) → DEF\(\\\\\\\\.\\\\\)) Tj
T*
() Tj
T*
(\(b\) REF\(main.2\) → DEF\(\\\\\\\\.\\\\\)) Tj
T*
() Tj
T*
(    /* Module 1 */) Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* Module 2 */) Tj
T*
(    int main;) Tj
T*
(    int p2\(\)) Tj
T*
(    {) Tj
T*
(    }) Tj
T*
() Tj
T*
(B.) Tj
T*
() Tj
T*
(\(a\) REF\(main.1\) → DEF\(\\\\\\\\.\\\\\)) Tj
T*
() Tj
T*
(\(b\) REF\(main.2\) → DEF\(\\\\\\\\.\\\\\)) Tj
T*
() Tj
T*
(    /* Module 1 */) Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* Module 2 */) Tj
T*
(    int main = 1;) Tj
T*
(    int p2\(\)) Tj
T*
(    {) Tj
T*
(    }) Tj
T*
() Tj
T*
(C.) Tj
T*
() Tj
T*
(\(a\) REF\(x.1\) → DEF\(\\\\\\\\.\\\\\)) Tj
T*
() Tj
T*
(\(b\) REF\(x.2\) → DEF\(\\\\\\\\.\\\\\)) Tj
T*
() Tj
T*
(    /* Module 1 */) Tj
T*
(    int x;) Tj
T*
(    void main\(\)) Tj
T*
(    {) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* Module 2 */) Tj
T*
ET
endstream
endobj
400 0 obj
<< /Length 3983 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    double x = 1.0;) Tj
T*
(    int p2\(\)) Tj
T*
(    {) Tj
T*
(    }) Tj
T*
() Tj
T*
(这是一个简单的练习，检査你对 Unix 链接器解析在一个以上模块中有定义的全局符号时所使用规则的理解。理解这些规则可以帮助你避免一些讨厌的编程错误。) Tj
T*
() Tj
T*
(A. 链接器选择定义在模块 1 中的强符号，而不是定义在模块 2 中的弱符号（规则 2）：) Tj
T*
() Tj
T*
(（a）REF\(main.1\) → DEF（main.1）) Tj
T*
() Tj
T*
(（b）REF\(main.2\) → DEF（main.1）) Tj
T*
() Tj
T*
(B. 这是一个错误，因为每个模块都定义了一个强符号 main（规则 1）。) Tj
T*
() Tj
T*
(C. 链接器选择定义在模块 2 中的强符号，而不是定义在模块 1 中的弱符号（规则 2）：) Tj
T*
() Tj
T*
(（a）REF\(x.1\) → DEF（x.2）) Tj
T*
() Tj
T*
(（b）REF\(x.2\) → DEF（x.2）) Tj
T*
() Tj
T*
(7.6.2 与静态链接库) Tj
T*
() Tj
T*
() Tj
T*
(迄今为止，我们都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形成一个输出的可执行文件。实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，) Tj
T*
(称为静态库（staticlibrary），它可以用做链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。) Tj
T*
() Tj
T*
(为什么系统要支持库的概念呢？以 ISO C99 为例，它定义了一组广泛的标准 I/O、字符串操作和整数数学函数，例如 atoi、printf，scanf、strcpy 和) Tj
T*
(rand。它们在 libc.a 库中，对每个 C 程序来说都是可用的。ISO C99 还在 libm.a 库中定义了一组广泛的浮点数学函数，例如 sin、cos 和 sqrt。) Tj
T*
() Tj
T*
(让我们来看看如果不使用静态库，编译器开发人员会使用什么方法来向用户提供这些函数。一种方法是让编译器辨认出对标准函数的调用，并直接生成相应的代码。Pascal（只提供了一小部分标准函) Tj
T*
(数）釆用的就是这种方法，但是这种方法对 C 而言是不合适的，因为 C 标准定义了大量的标准函数。这种方法将给编译器增加显著的复杂性，而且每次添加、删除或修改一个标准函数时，就需要一) Tj
T*
(个新的编译器版本。然而，对于应用程序员而言，这种方法会是非常方便的，因为标准函数将总是可用的。) Tj
T*
() Tj
T*
(另一种方法是将所有的标准 C 函数都放在一个单独的可重定位目标模块中（比如说 libc.o 中）应用程序员可以把这个模块链接到他们的可执行文件中：) Tj
T*
() Tj
T*
(    linux> gcc main.c /usr/lib/libc.o) Tj
T*
() Tj
T*
(这种方法的优点是它将编译器的实现与标准函数的实现分离开来，并且仍然对程序员保持适度的便利。然而，一个很大的缺点是系统中每个可执行文件现在都包含着亠份标准：函数.) Tj
T*
(集合的完全副本，这对磁盘空间是很大的浪费。（在一个典型的系统上，libc.a 大约是 5MB，而 libm.a 大约是 2MB。）更糟的是，每个正在运行的程序都将它自己的这些函数的) Tj
T*
(副本放在内存中，这是对内存的极度浪费。另一个大的缺点是，对任何标准函数的任何改变，无论多么小的改变，都要求库的开发人员重新编译整个源文件，这是一个非常耗时的操作，使得标准函数的开发) Tj
T*
(和维护变得很复杂。) Tj
T*
() Tj
T*
(我们可以通过为每个标准函数创建一个独立的可重定位文件，把它们存放在一个为大家都知道的目录中来解决其中的一些问题。然而，这种方法要求应用程序员显式地链接合适的目标模块到它们的可执行文) Tj
T*
(件中，这是一个容易出错而且耗时的过程：) Tj
T*
() Tj
T*
ET
endstream
endobj
401 0 obj
<< /Length 2532 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    linux> gcc main.c /usr/lib/printf.o /usr/lib/scanf.o ...) Tj
T*
() Tj
T*
(静态库概念被提出来，以解决这些不同方法的缺点。相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些在库) Tj
T*
(中定义的函数。比如，使用 C 标准库和数学库中函数的程序可以用形式如下的命令行来编译和链接：) Tj
T*
() Tj
T*
(    linux> gcc main.c /usr/lib/libm.a /usr/lib/libc.a) Tj
T*
() Tj
T*
(在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字（实际上，C 编译器驱动程序总是传送) Tj
T*
(libc.a 给链接器，所以前面提到的对 libc.a 的引用是不必要的）。) Tj
T*
() Tj
T*
(在 Linux 系统中，静态库以一种称为存档（archive）的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和) Tj
T*
(位置。存档文件名由后缀 .a 标识。) Tj
T*
() Tj
T*
(为了使我们对库的讨论更加形象具体，考虑图 7-6 中的两个向量例程。每个例程，定义在它自己的目标模块中，对两个输入向量进行一个向量操作，并把结果存放在一个输出向量中。每个例程有一个) Tj
T*
(副作用，会记录它自己被调用的次数，每次被调用会把一个全局变量加 1。（当我们在 7.12 节中解释位置无关代码的思想时会起作用。）) Tj
T*
() Tj
T*
(    int addcnt = 0;) Tj
T*
() Tj
T*
(    void addvec\(int *x, int *y,) Tj
T*
(                int *z, int n\)) Tj
T*
(    {) Tj
T*
(        int i;) Tj
T*
() Tj
T*
(        addcnt++;) Tj
T*
() Tj
T*
(        for \( i = 0; i < n; i++\)) Tj
T*
(            z[i] = x[i] + y[i];) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int multcnt = 0;) Tj
T*
() Tj
T*
(    void multvec\(int *x，int *y,) Tj
T*
(                 int *z，int n\)) Tj
T*
(    {) Tj
T*
(        int i;) Tj
T*
() Tj
T*
(        multcnt++;) Tj
T*
() Tj
T*
(        for \(i = 0; i < n; i++\)) Tj
T*
(            z[i] = x[i] * y[i];) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 7-6 libvector 库中的成员目标文件) Tj
T*
() Tj
T*
(要创建这些函数的一个静态库，我们将使用 AR 工具，如下：) Tj
T*
() Tj
T*
ET
endstream
endobj
402 0 obj
<< /Length 2430 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    linux> gcc -c addvec.c multvec.c) Tj
T*
(    linux> ar rcs libvector.a addvec.o multvec.o) Tj
T*
() Tj
T*
(为了使用这个库，我们可以编写一个应用， 比如图 7-7 中的 main2.c，它调用 addvec 库例程。包含（或头）文件 vector .h 定义了 libvector.a) Tj
T*
(中例程的函数原型。) Tj
T*
() Tj
T*
(    #include <stdio.h>) Tj
T*
(    #include "vector.h") Tj
T*
() Tj
T*
(    int x[2] = {1, 2};) Tj
T*
(    int y[2] = {3, 4};) Tj
T*
(    int z[2];) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        addvec\(x, y, z, 2\);) Tj
T*
(        printf\("z = [%d %d]\\n", z[0], z[1]\);) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 7-7 示例程序 2。这个程序调用 libvector 库中的函数) Tj
T*
() Tj
T*
(为了创建这个可执行文件，我们要编译和链接输入文件 main.o 和 libvector.a：) Tj
T*
() Tj
T*
(    linux>gcc -c main2.c) Tj
T*
(    linux>gcc -static -o prog2c main2.o ./libvector.a) Tj
T*
() Tj
T*
(或者等价地使用：) Tj
T*
() Tj
T*
(    linux>gcc -c main2.c) Tj
T*
(    linux>gcc -static -o prog2c main2.o -L. -lvector) Tj
T*
() Tj
T*
(图 7-8 概括了链接器的行为。-static) Tj
T*
(参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无须更进一步的链接。-lvector 参数是 libvector.a) Tj
T*
(的缩写，-L. 参数告诉链接器在当前目录下查找 libvector.a。) Tj
T*
() Tj
T*
([Image: 图 7-8 与静态库链接]) Tj
T*
() Tj
T*
(当链接器运行时，它判定 main2.o 引用了 addvec.o 定义的 addvec 符号，所以复制 addvec.o 到可执行文件。因为程序不引用任何由 multvec.o) Tj
T*
(定义的符号，所以链接器就不会复制这个模块到可执行文件。链接器还会复制 libc.a 中的 printf.o 模块，以及许多 C 运行时系统中的其他模块。) Tj
T*
() Tj
T*
(7.6.3 链接器如何使用静态库来解析引用) Tj
T*
() Tj
T*
() Tj
T*
(虽然静态库很有用，但是它们同时也是一个程序员迷惑的源头，原因在于 Linux) Tj
T*
(链接器使用它们解析外部引用的方式。在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。（驱动程序自动将命令行中所有的 .c) Tj
T*
ET
endstream
endobj
403 0 obj
<< /Length 4350 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(文件翻译为 .o 文件。）在这次扫描中，链接器维护一个可重定位目标文件的集合 E（这个集合中的文件会被合并起来形成可执行文件），一个未解析的符号（即引用了但是尚未定义的符号）集合) Tj
T*
(U，以及一个在前面输入文件中已定义的符号集合 D。初始时，E、U 和 D 均为空。) Tj
T*
() Tj
T*
(* 对于命令行上的每个输入文件 f，链接器会判断 f 是一个目标文件还是一个存档文件。如果 f 是一个目标文件，那么链接器把 f 添加到 E，修改 U 和 D 来反映 f) Tj
T*
(中的符号定义和引用，并继续下一个输入文件。) Tj
T*
(* 如果 f 是一个存档文件，那么链接器就尝试匹配 U 中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员 m，定义了一个符号来解析 U 中的一个引用，那么就将 m) Tj
T*
(加到 E 中，并且链接器修改 U 和 D 来反映 m 中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到 U 和 D 都不再发生变化。此时，任何不包含在 E) Tj
T*
(中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件。) Tj
T*
(* 如果当链接器完成对命令行上输入文件的扫描后，U 是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位 E 中的目标文件，构建输岀的可执行文件。) Tj
T*
() Tj
T*
(不幸的是，这种算法会导致一些令人困扰的链接时错误，因为命令行上的库和目标文件的顺序非常重要。在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，) Tj
T*
(链接会失败。比如，考虑下面的命令行发生了什么？) Tj
T*
() Tj
T*
(    linux> gcc static ./libvector.a main2.c) Tj
T*
(    /tmp/cc9XH6Rp.o: In function 'main':) Tj
T*
(    /tmp/cc9XH6Rp.o（.text+0x18）: undefined reference to 'addvec') Tj
T*
() Tj
T*
(在处理 libvector.a 时，U 是空的，所以没有 libvector.a 中的成员目标文件会添加到 E 中。因此，对 addvec) Tj
T*
(的引用是绝不会被解析的，所以链接器会产生一条错误信息并终止。) Tj
T*
() Tj
T*
(关于库的一般准则是将它们放在命令行的结尾。如果各个库的成员是相互独立的（也就是说没有成员引用另一个成员定义的符号），那么这些库就可以以任何顺序放置在命令行的结尾处。另一方面，如果库) Tj
T*
(不是相互独立的，那么必须对它们排序，使得对于每个被存档文件的成员外部引用的符号 S，在命令行中至少有一个 S 的定义是在对 S 的引用之后的。比如，假设 foo.c 调用) Tj
T*
(libx.a 和 libz.a 中的函数，而这两个库又调用 liby.a 中的函数。那么，在命令行中 libx.a 和 libz.a 必须处在 liby.a 之前：) Tj
T*
() Tj
T*
(    linux>gcc foo.c libx.a libz.a liby.a) Tj
T*
() Tj
T*
(如果需要满足依赖需求，可以在命令行上重复库。比如，假设 foo.c 调用 libx.a 中的函数，该库又调用 liby.a 中的函数，而 liby.a 又调用 libx.a) Tj
T*
(中的函数。那么 libx.a 必须在命令行上重复出现：) Tj
T*
() Tj
T*
(    linux> gcc foo.c libx.a liby.a libx.a) Tj
T*
() Tj
T*
(另一种方法是，我们可以将 libx.a 和 liby.a 合并成一个单独的存档文件。) Tj
T*
() Tj
T*
(练习题 7.3) Tj
T*
() Tj
T*
() Tj
T*
(a 和 b 表示当前目录中的目标模块或者静态库，而 a → b 表示 a 依赖于 b，也就是说 b 定义了一个被 a) Tj
T*
(引用的符号。对于下面每种场景，请给出最小的命令行（即一个含有最少数量的目标文件和库参数的命令），使得静态链接器能解析所有的符号引用。) Tj
T*
() Tj
T*
(A. p.o → libx.a) Tj
T*
() Tj
T*
(B. p.o → libx.a → liby.a) Tj
T*
() Tj
T*
(C. p.o → libx.a → liby.a 且 liby.a → libx.a → p.o) Tj
T*
() Tj
T*
(在命令行中以错误的顺序放置静态库是造成令许多程序员迷惑的链接器错误的常见原因。然而，一旦你理解了链接器是如何使用静态库来解析引用的，它就相当简单易懂了。这个小练习检查了你对) Tj
T*
ET
endstream
endobj
404 0 obj
<< /Length 3603 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(这个概念的理解：) Tj
T*
() Tj
T*
(A. linux> gcc p.o libx.a) Tj
T*
() Tj
T*
(B. linux> gcc p.o libx.a liby.a) Tj
T*
() Tj
T*
(C. linux> gcc p.o libx.a liby.a libx.a) Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.7 重定位) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.7 重定位) Tj
T*
() Tj
T*
() Tj
T*
(一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节) Tj
T*
(的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由两步组成：) Tj
T*
() Tj
T*
(* 重定位节和符号定义。在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自所有输入模块的. data) Tj
T*
(节被全部合并成一个节，这个节成为输出的可执行目标文件的. data) Tj
T*
(节。然后，链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。) Tj
T*
(* 重定位节中的符号引用。在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目（relo) Tj
T*
(cation entry）的数据结构，我们接下来将会描述这种数据结构。) Tj
T*
() Tj
T*
(7.7.1 重定位条目) Tj
T*
() Tj
T*
() Tj
T*
(当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目) Tj
T*
(标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。代码的重定位条目放在 .rel.text 中。已初始化数据的重定位条目放在) Tj
T*
(.rel.data 中。) Tj
T*
() Tj
T*
(图 7-9 展示了 ELF 重定位条目的格式。offset 是需要被修改的引用的节偏移。symbol 标识被修改引用应该指向的符号。type) Tj
T*
(告知链接器如何修改新的引用。addend 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。) Tj
T*
() Tj
T*
(    typedef struct {) Tj
T*
(        long offset;    /* Offset of the reference to relocate */) Tj
T*
(        long type:32,   /* Relocation type */) Tj
T*
(             symbol:32; /* Symbol table index */) Tj
T*
(        long addend;    /* Constant part of relocation expression */) Tj
T*
(    } Elf64_Rela;) Tj
T*
() Tj
T*
(> 图 7-9 ELF 重定位条目。每个条目表示一个必须被重定位的引用，并指明如何计算被修改的引用) Tj
T*
() Tj
T*
(ELF 定义了 32 种不同的重定位类型，有些相当隐秘。我们只关心其中两种最基本的重定位类型：) Tj
T*
() Tj
T*
(* R\\X86\\64\\_PC32。重定位一个使用 32 位 PC 相对地址的引用。回想一下 3.6.3 节，一个 PC 相对地址就是距程序计数器（PC）的当前运行时值的偏移量。当) Tj
T*
ET
endstream
endobj
405 0 obj
<< /Length 3397 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(CPU 执行一条使用 PC 相对寻址的指令时，它就将在指令中编码的 32 位值加上 PC 的当前运行时值，得到有效地址（如 call 指令的目标），PC) Tj
T*
(值通常是下一条指令在内存中的地址。) Tj
T*
(* R\\X86\\64\\_32。重定位一个使用 32 位绝对地址的引用。通过绝对寻址，CPU 直接使用在指令中编码的 32 位值作为有效地址，不需要进一步修改。) Tj
T*
() Tj
T*
(这两种重定位类型支持 x86-64 小型代码模型（small code model），该模型假设可执行目标文件中的代码和数据的总体大小小于 2GB，因此在运行时可以用 32 位) Tj
T*
(PC 相对地址来访问。GCC 默认使用小型代码模型。大于 2GB 的程序可以用 -mcmodel=medium（中型代码模型）和) Tj
T*
(-mcmodel=large（大型代码模型）标志来编译，不过在此我们不讨论这些模型。) Tj
T*
() Tj
T*
(7.7.2 重定位符号引用) Tj
T*
() Tj
T*
() Tj
T*
(图 7-10 展示了链接器的重定位算法的伪代码。第 1 行和第 2 行在每个节 s 以及与每个节相关联的重定位条目 r 上迭代执行。为了使描述具体化，假设每个节 s) Tj
T*
(是一个字节数组，每个重定位条目 r 是一个类型为 Elf64\\_Rela 的结构，如图 7-9 中的定义。另外，还假设当算法运行时，链接器已经为每个节（用 ADDR\\\(s\\\)) Tj
T*
(表示）和每个符号都选择了运行时地址（用 ADDR\\\(r.symbol\\\) 表示）。第 3 行计算的是需要被重定位的 4 字节引用的数组 s 中的地址。如果这个引用使用的是 PC) Tj
T*
(相对寻址，那么它就用第 5 ~ 9 行来重定位。如果该引用使用的是绝对寻址，它就通过第 11 ~ 13 行来重定位。) Tj
T*
() Tj
T*
(    foreach section s {) Tj
T*
(        foreach relocation entry r {) Tj
T*
(            refptr = s + r.offset;  /* ptr to reference to be relocated */) Tj
T*
() Tj
T*
(            /* Relocate a PC-relative reference */) Tj
T*
(            if \(r.type == R_X86_64_PC32\){) Tj
T*
(                refaddr = ADDR\(s\) + r.offset; /* ref's run-time address */) Tj
T*
(                *refptr = \(unsigned\) \(ADDR\(r.symbol\) + r.addend - refaddr\);) Tj
T*
(            }) Tj
T*
() Tj
T*
(            /* Relocate an absolute reference */) Tj
T*
(            if \(r.type ==R_X86_64_32\)) Tj
T*
(                *refptr = \(unsigned\) \(ADDR\(r.symbol\) + r.addend\);) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 7-10 重定位算法) Tj
T*
() Tj
T*
(让我们来看看链接器如何用这个算法来重定位图 7-1 示例程序中的引用。图 7-11 给出了（用 objdump-dx main.o 产生的）GNU OBJDUMP 工具产生的) Tj
T*
(main.o 的反汇编代码。) Tj
T*
() Tj
T*
(    0000000000000000 <main>:) Tj
T*
(       0:   48 83 ec 08             sub    $0x8,%rsp) Tj
T*
(       4:   be 02 00 00 00          mov    $0x2,%esi) Tj
T*
(       9:   bf 00 00 00 00          mov    $0x0,%edi        %edi = &array) Tj
T*
(                            a: R_X86_64_32 array            Relocation entry) Tj
T*
(       e:   e8 00 00 00 00          callq  13 <main+0x13>   sum\(\)) Tj
T*
(                            f: R_X86_64_PC32 sum-0x4        Relocation entry) Tj
T*
(      13:   48 83 c4 08             add $0x8,%rsp) Tj
T*
(      17:   c3                      retq) Tj
T*
ET
endstream
endobj
406 0 obj
<< /Length 2421 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(> 图 7-11 main.o 的代码和重定位条目。原始 C 代码在图 7-1 中) Tj
T*
() Tj
T*
(main 函数引用了两个全局符号：array 和 sum。为每个引用，汇编器产生一个重定位条目，显示在引用的后面一行上。✦这些重定位条目告诉链接器对 sum 的引用要使用 32 位) Tj
T*
(PC 相对地址进行重定位，而对 array 的引用要使用 32 位绝对地址进行重定位。接下来两节会详细介绍链接器是如何重定位这些引用的。) Tj
T*
() Tj
T*
(✦：回想一下. 重定位条目和指令实际上存放在目标文件的不同节中。为了方便，OBJDUMP 工具把它们显示在一起。) Tj
T*
() Tj
T*
(1. 重定位 PC 相对引用) Tj
T*
() Tj
T*
() Tj
T*
(图 7-11 的第 6 行中，函数 main 调用 sum 函数，sum 函数是在模块 sum.o 中定义的。call 指令开始于节偏移 0xe 的地方’包括 1 字节的操作码) Tj
T*
(0xe8，后面跟着的是对目标 sum 的 32 位 PC 相对引用的占位符。) Tj
T*
() Tj
T*
(相应的重定位条目 r 由 4 个字段组成：) Tj
T*
() Tj
T*
(    r.offset = 0xf) Tj
T*
(    r.symbol = sum) Tj
T*
(    r.type   = R_X86_64_PC32) Tj
T*
(    r.addend = -4) Tj
T*
() Tj
T*
(这些字段告诉链接器修改开始于偏移量 0xf 处的 32 位 PC 相对引用，这样在运行时它会指向 sum 例程。现在，假设链接器已经确定) Tj
T*
() Tj
T*
(    ADDR\(s\) = ADDR\(.text\) = 0x4004d0) Tj
T*
() Tj
T*
(和) Tj
T*
() Tj
T*
(    ADDR\(r.symbol\) = ADDR\(sum\) = 0x4004e8) Tj
T*
() Tj
T*
(使用图 7-10 中的算法，链接器首先计算出引用的运行时地址（第 7 行）：) Tj
T*
() Tj
T*
(    refaddr = ADDR\(s\)  + r.offset) Tj
T*
(            = 0x4004d0 + 0xf) Tj
T*
(            = 0x4004df) Tj
T*
() Tj
T*
(然后，更新该引用，使得它在运行时指向 sum 程序（第 8 行）：) Tj
T*
() Tj
T*
(    *refptr = \(unsigned\) \(ADDR\(r.symbol\) + r.addend - refaddr\)) Tj
T*
(            = \(unsigned\) \(0x4004e8       + \(-4\)     - 0x4004df\)) Tj
T*
(            = \(unsigned\) \(0x5\)) Tj
T*
() Tj
T*
(在得到的可执行目标文件中，call 指令有如下的重定位的形式：) Tj
T*
() Tj
T*
(    4004de:  e8 05 00 00 00      callq  4004e8 <sum>       sum\(\)) Tj
T*
() Tj
T*
(在 call 指令之后的指令的地址。为了执行这条指令，CPU 执行以下的步骤：) Tj
T*
ET
endstream
endobj
407 0 obj
<< /Length 2288 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(1）将 PC 压入栈中) Tj
T*
() Tj
T*
(2）PC ← PC + 0x5 = 0x4004e3 + 0x5 = 0x4004e8) Tj
T*
() Tj
T*
(因此，要执行的下一条指令就是 sum 例程的第一条指令，这当然就是我们想要的！) Tj
T*
() Tj
T*
(2. 重定位绝对引用) Tj
T*
() Tj
T*
() Tj
T*
(重定位绝对引用相当简单。例如，图 7-11 的第 4 行中，mov 指令将 array 的地址（一个 32 位立即数值）复制到寄存器％edi 中。mov 指令开始于节偏移量 0x9) Tj
T*
(的位置，包括 1 字节操作码 Oxbf，后面跟着对 array 的 32 位绝对引用的占位符。) Tj
T*
() Tj
T*
(对应的占位符条目 r 包括 4 个字段：) Tj
T*
() Tj
T*
(    r.offset = 0xa) Tj
T*
(    r.symbol = array) Tj
T*
(    r.type   = R_X86_64_32) Tj
T*
(    r.addend = 0) Tj
T*
() Tj
T*
(这些字段告诉链接器要修改从偏移量 0xa 开始的绝对引用，这样在运行时它将会指向 array 的第一个字节。现在，假设链接器巳经确定) Tj
T*
() Tj
T*
(    ADDR\(r.symbol\) = ADDR\(array\) = 0x601018) Tj
T*
() Tj
T*
(链接器使用图 7-10 中算法的第 13 行修改了引用：) Tj
T*
() Tj
T*
(    *refptr = \(unsigned\) \(ADDR\(r.symbol\) + r.addend\)) Tj
T*
(            = \(unsigned\) \(0x601018       + 0\)) Tj
T*
(            = \(unsigned\) \(0x601018\)) Tj
T*
() Tj
T*
(在得到的可执行目标文件中，该引用有下面的重定位形式：) Tj
T*
() Tj
T*
(    4004d9:  bf 18 10 60 00       mov   $0x601018,%edi         %edi = &array) Tj
T*
() Tj
T*
(综合到一起，图 7-12 给出了最终可执行目标文件中已重定位的 .text 节和 .data) Tj
T*
(节。在加载的时候，加载器会把这些节中的字节直接复制到内存，不再进行任何修改地执行这些指令。) Tj
T*
() Tj
T*
(    00000000004004d0 <main>:) Tj
T*
(      4004d0:  48 83 ec 08          sub    $0x8,%rsp) Tj
T*
(      4004d4:  be 02 00 00 00       mov    $0x2,%esi) Tj
T*
(      4004d9:  bf 18 10 60 00       mov    $0x601018,%edi    %edi = &array) Tj
T*
(      4004de:  e8 05 00 00 00       callq  4004e8 <sum>      sum\(\)) Tj
T*
(      4004e3:  48 83 c4 08          add    $0x8,%rsp) Tj
T*
(      4004e7:  c3                   retq) Tj
T*
() Tj
T*
(    00000000004004e8 <sum>:) Tj
T*
ET
endstream
endobj
408 0 obj
<< /Length 2103 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(      4004e8:  b8 00 00 00 00       mov    $0x0,%eax) Tj
T*
(      4004ed:  ba 00 00 00 00       mov    $0x0,%edx) Tj
T*
(      4004f2:  eb 09                jmp    4004fd <sum+0x15>) Tj
T*
(      4004f4:  48 63 ca             movslq %edx,%rcx) Tj
T*
(      4004f7:  03 04 8f             add    \(%rdi,%rcx,4\),%eax) Tj
T*
(      4004fa:  83 c2 01             add    $0x1,%edx) Tj
T*
(      4004fd:  39 f2                cmp    %esi,%edx) Tj
T*
(      4004ff:  7c f3                jl     4004f4 <sum+0xc>) Tj
T*
(      400501:  f3 c3                repz retq) Tj
T*
() Tj
T*
(    0000000000601018 <array>:) Tj
T*
(      601018:  01 00 00 00 02 00 00 00) Tj
T*
() Tj
T*
(> 图 7-12 可执行文件 prog 的已重定位的 .text 节和 .data 节。原始的 C 代码在图 7-1 中) Tj
T*
() Tj
T*
(练习题 7.4) Tj
T*
() Tj
T*
() Tj
T*
(本题是关于图 7-12a 中的已重定位程序的。) Tj
T*
() Tj
T*
(A. 第 5 行中对 sum 的重定位引用的十六进制地址是多少？) Tj
T*
() Tj
T*
(B. 第 5 行中对 sum 的重定位引用的十六进制值是多少？) Tj
T*
() Tj
T*
(这道题涉及的是图 7-12a 中的反汇编列表。目的是让你练习阅读反汇编列表，并检查你对 PC 相对寻址的理解。) Tj
T*
() Tj
T*
(A. 第 5 行被重定位引用的十六进制地址为 0x4004df。) Tj
T*
() Tj
T*
(B. 第 5 行被重定位引用的十六进制值为 0x5。记住，反汇编列表给岀的引用值是用小端法字节顺序表示的。) Tj
T*
() Tj
T*
(练习题 7.5) Tj
T*
() Tj
T*
() Tj
T*
(考虑目标文件 m.o 中对 swap 函数的调用（图 7-5）。) Tj
T*
() Tj
T*
(    9:  e8 00 00 00 00            callq  e <main+0xe>      swap\(\)) Tj
T*
() Tj
T*
(它的重定位条目如下：) Tj
T*
() Tj
T*
(    r.offset = 0xa) Tj
T*
(    r.symbol = swap) Tj
T*
(    r.type   = R_X86_64_PC32) Tj
T*
(    r.addend = -4) Tj
T*
() Tj
T*
(现在假设链接器将 m.o 中的 .text 重定位到地址 0x4004d0，将 swap 重定位到地址 0x4004e8。那么 callq 指令中对 swap) Tj
T*
(的重定位引用的值是什么？) Tj
T*
ET
endstream
endobj
409 0 obj
<< /Length 2669 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(这道题是测试你对链接器重定位PC相对引用的理解的。给定) Tj
T*
() Tj
T*
(ADDR\\\(s\\\) = ADDR\\\(.text\\\) = 0x4004d0) Tj
T*
() Tj
T*
(和) Tj
T*
() Tj
T*
(ADDR\\\(r.symbol\\\) = ADDR\\\(swap\\\) = 0x4004e8) Tj
T*
() Tj
T*
(使用图 7-10 中的算法，链接器首先计算引用的运行时地址：) Tj
T*
() Tj
T*
(    refaddr = ADDR\(s\)  + r.offset) Tj
T*
(            = 0x4004d0 + 0xa) Tj
T*
(            = 0x4004da) Tj
T*
() Tj
T*
(然后修改此引用：) Tj
T*
() Tj
T*
(    *refptr = \(unsigned\) \(ADDR\(r.symbol\) + r.addend - refaddr\)) Tj
T*
(            = \(unsigned\) \(0x4004e8       + \(-4\)     - 0x4004da\)) Tj
T*
(            = \(unsigned\) \(0xa\)) Tj
T*
() Tj
T*
(因此，得到的可执行目标文件中，对 swap 的 PC 相对引用的值为 0xa：) Tj
T*
() Tj
T*
(    4004d9: e8 0a 00 00 00          callq 4004e8 <swap>) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.8 可执行目标文件) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.8 可执行目标文件) Tj
T*
() Tj
T*
() Tj
T*
(我们已经看到链接器如何将多个目标文件合并成一个可执行目标文件。我们的示例 C 程序，开始时是一组 ASCII) Tj
T*
(文本文件，现在已经被转化为一个二进制文件，且这个二进制文件包含加载程序到内存并运行它所需的所有信息。图 7-13 概括了一个典型的 ELF 可执行文件中的各类信息。) Tj
T*
() Tj
T*
([Image: &#x56FE; 7-13 &#x5178;&#x578B;&#x7684; ELF) Tj
T*
(&#x53EF;&#x6267;&#x884C;&#x76EE;&#x6807;&#x6587;&#x4EF6;]) Tj
T*
() Tj
T*
(可执行目标文件的格式类似于可重定位目标文件的格式。ELF 头描述文件的总体格式。它还包括程序的入口点（entry) Tj
T*
(point），也就是当程序运行时要执行的第一条指令的地址。.text、.rodata 和 .data) Tj
T*
(节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址以外。.init 节定义了一个小函数，叫做) Tj
T*
(\\_init，程序的初始化代码会调用它。因为可执行文件是完全链接的（已被重定位），所以它不再需要 .rel 节。) Tj
T*
() Tj
T*
(ELF 可执行文件被设计得很容易加载到内存，可执行文件的连续的片（chunk）被映射到连续的内存段。程序头部表（program header table）描述了这种映射关系。图) Tj
T*
(7-14 展示了可执行文件 prog 的程序头部表，是由 OBJDUMP 显示的。) Tj
T*
ET
endstream
endobj
410 0 obj
<< /Length 2832 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(    Read-only code segment) Tj
T*
(    LOAD off    0x0000000000000000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align) Tj
T*
(    2**21) Tj
T*
(         filesz 0x000000000000069c memsz 0x00000oo000o0069c flags r-x) Tj
T*
() Tj
T*
(    Read/write data segment) Tj
T*
(    LOAD off    0x0000000000000df8 vaddr 0x0000000000600df8 paddr 0x0000000000600df8 align) Tj
T*
(    2**21) Tj
T*
(         filesz 0x0000000000000228 memsz 0x0000000000000230 flags rw-) Tj
T*
() Tj
T*
(> 图 7-14 示例可执行文件 prog 的程序头部表) Tj
T*
(>) Tj
T*
(> off：目标文件中的偏移；vaddr/paddr：内存地址；align：对齐要求；filesz：目标文件中的段大小；memsz：内存中的段大小；flags：运行时访问权限。) Tj
T*
() Tj
T*
(从程序头部表，我们会看到根据可执行目标文件的内容初始化两个内存段。第 1 行和第 2 行告诉我们第一个段（代码段）有读/执行访问权限，开始于内存地址 0x400000) Tj
T*
(处，总共的内存大小是 0x69c 字节，并且被初始化为可执行目标文件的头 0x69c 个字节，其中包括 ELF 头、程序头部表以及 .initx.text 和 .rodata 节。) Tj
T*
() Tj
T*
(第 3 行和第 4 行告诉我们第二个段（数据段）有读/写访问权限，开始于内存地址 0x600df8 处，总的内存大小为 0x230 字节，并用从目标文件中偏移 0xdf8 处开始的) Tj
T*
(.data 节中的 0x228 个字节初始化。该段中剩下的 8 个字节对应于运行时将被初始化为 0 的 .bss 数据。) Tj
T*
() Tj
T*
(对于任何段 s，链接器必须选择一个起始地址 vaddr，使得) Tj
T*
() Tj
T*
(vaddr mod align = off mod align) Tj
T*
() Tj
T*
(这里，off 是目标文件中段的第一个节的偏移量，align 是程序头部中指定的对齐（ $$2^{21}$$ = 0x200000）。例如，图 7-14 中的数据段中) Tj
T*
() Tj
T*
(vaddr mod align = 0x600df8 mod 0x200000 = 0xdf8) Tj
T*
() Tj
T*
(以及) Tj
T*
() Tj
T*
(off mod align = 0xdf8 mod 0x200000 = 0xdf8) Tj
T*
() Tj
T*
(这个对齐要求是一种优化，使得当程序执行时，目标文件中的段能够很有效率地传送到内存中。原因有点儿微妙，在于虚拟内存的组织方式，它被组织成一些很大的、连续的、大小为 2) Tj
T*
(的幂的字节片。第 9 章中你会学习到虚拟内存的知识。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.9 加载可执行目标文件) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.9 加载可执行目标文件) Tj
T*
() Tj
T*
() Tj
T*
(要运行可执行目标文件 prog，我们可以在 Linux shell 的命令行中输入它的名字：) Tj
T*
() Tj
T*
ET
endstream
endobj
411 0 obj
<< /Length 4831 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    linux> ./prog) Tj
T*
() Tj
T*
(因为 prog 不是一个内置的 shell 命令，所以 shell 会认为 prog) Tj
T*
(是一个可执行目标文件，通过调用某个驻留在存储器中称为加载器（loader）的操作系统代码来运行它。任何 Linux 程序都可以通过调用 execve 函数来调用加载器，我们将在) Tj
T*
(8.4.6) Tj
T*
(节中详细描述这个函数。加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。这个将程序复制到内存并运行的过程叫做加载。) Tj
T*
() Tj
T*
(每个 Linux 程序都有一个运行时内存映像，类似于图 7-15 中所示。在 Linux 86-64 系统中，代码段总是从地址 0x400000) Tj
T*
(处开始，后面是数据段。运行时堆在数据段之后，通过调用 malloc 库往上增长。（我们将在 9.9 节中详细描述 mallow) Tj
T*
(和堆。）堆后面的区域是为共享模块保留的。用户栈总是从最大的合法用户地址（ $$\\small 2^{48}-1$$ ）开始，向较小内存地址增长。栈上的区域，从地址 $$\\small) Tj
T*
(2^{48}$$ 开始，是为内核（kernel）中的代码和数据保留的，所谓内核就是操作系统驻留在内存的部分。) Tj
T*
() Tj
T*
(为了简洁，我们把堆、数据和代码段画得彼此相邻，并且把栈顶放在了最大的合法用户地址处。实际上，由于 .data 段有对齐要求（见 7.8) Tj
T*
(节），所以代码段和数据段之间是有间隙的。同时，在分配栈、共享库和堆段运行时地址的时候，链接器还会使用地址空间布局随机化（ASLR，参见 3.10.4) Tj
T*
(节）。虽然每次程序运行时这些区域的地址都会改变，它们的相对位置是不变的。) Tj
T*
() Tj
T*
(当加载器运行时，它创建类似于图 7-15 所示的内存映像。在程序头部表的引导下，加载器将可执行文件的片（chunk）复制到代码段和数据段。接下来，加载器跳转到程序的入口点，也就是) Tj
T*
(start函数的地址。这个函数是在系统目标文件 ctrl.o 中定义的，对所有的 C 程序都是一样的。start 函数调用系统启动函数) Tj
T*
(\\\\libc\\start\\main，该函数定义在 libc.so 中。它初始化执行环境，调用用户层的 main 函数，处理 main) Tj
T*
(函数的返回值，并且在需要的时候把控制返回给内核。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 7-15 Linux x86-64 运行时内存映像。没有展示出由于段对齐要求和地址空间布局随机化（ASLR）造成的空隙。区域大小不成比例) Tj
T*
() Tj
T*
(旁注 - 加载器实际是如何工作的？) Tj
T*
() Tj
T*
() Tj
T*
(我们对于加载的描述从概念上来说是正确的，但也不是完全准确，这是有意为之。要理解加载实际是如何工作的，你必须理解进程、虚拟内存和内存映射的概念，这些我们还没有加以讨论。在后面第 8) Tj
T*
(章和第 9 章中遇到这些概念时，我们将重新回到加载的问题上，并逐渐向你揭开它的神秘面纱。) Tj
T*
() Tj
T*
(对于不够有耐心的读者，下面是关于加载实际是如何工作的一个概述：Linux 系统中的每个程序都运行在一个进程上下文中，有自己的虚拟地址空间。当 shell 运行一个程序时，父) Tj
T*
(shell 进程生成一个子进程，它是父进程的一个复制。子进程通过 execve 系统调用启动加载器。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈段。新的栈和堆) Tj
T*
(段被初始化为零。通过将虚拟地址空间中的页映射到可执行文件的页大小的片（chunk），新的代码和数据段被初始化为可执行文件的内容。最后，加载器跳转到\\_start) Tj
T*
(地址，它最终会调用应用程序的 main 函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到 CPU) Tj
T*
(引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.10 动态链接共享库) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.10 动态链接共享库) Tj
T*
() Tj
T*
() Tj
T*
(我们在 7.6.2 节中研究的静态库解决了许多关于如何让大量相关函数对应用程序可用的问题。然而，静态库仍然有一些明显的缺点。静态库和所有的软件一样，需要定期维护和更新。如果应用程序) Tj
T*
ET
endstream
endobj
412 0 obj
<< /Length 4484 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与更新了的库重新链接。) Tj
T*
() Tj
T*
(另一个问题是几乎每个 C 程序都使用标准 I/O 函数，比如 printf 和 scanf。在运行时，这些函数的代码会被复制到每个运行进程的文本段中。在一个运行上百个进程的典型系统) Tj
T*
(上，这将是对稀缺的内存系统资源的极大浪费。（内存的一个有趣属性就是不论系统的内存有多大，它总是一种稀缺资源。磁盘空间和厨房的垃圾桶同样有这种属性。）) Tj
T*
() Tj
T*
(共享库（shared library）是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个) Tj
T*
(过程称为动态链接（dynamic linking），是由一个叫做动态链接器（dynamic linker）的程序来执行的。共享库也称为共享目标（shared object），在) Tj
T*
(Linux 系统中通常用 .so 后缀来表示。微软的操作系统大量地使用了共享库，它们称为 DLL（动态链接库）。) Tj
T*
() Tj
T*
(共享库是以两种不同的方式来“共享”的。首先，在任何给定的文件系统中，对于一个库只有一个. so 文件。所有引用该库的可执行目标文件共享这个 .so) Tj
T*
(文件中的代码和数据，而不是像静态库的内容那样被复制和嵌入到引用它们的可执行的文件中。其次，在内存中，一个共享库的 .text 节的一个副本可以被不同的正在运行的进程共享。在第 9) Tj
T*
(章我们学习虚拟内存时将更加详细地讨论这个问题。) Tj
T*
() Tj
T*
(图 7-16 概括了图 7-7 中示例程序的动态链接过程。) Tj
T*
() Tj
T*
([Image: &#x56FE; 7-16 &#x52A8;&#x6001;&#x94FE;&#x63A5;&#x5171;&#x4EAB;&#x5E93;]) Tj
T*
() Tj
T*
(为了构造图 7-6 中示例向量例程的共享库 libvector.so，我们调用编译器驱动程序，给编译器和链接器如下特殊指令：) Tj
T*
() Tj
T*
(    linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c) Tj
T*
() Tj
T*
(-fpic 选项指示编译器生成与位置无关的代码（下一节将详细讨论这个问题）。-shared 选项指示链接器创建一个共享的目标文件。一旦创建了这个库，随后就要将它链接到图 7-7) Tj
T*
(的示例程序中：) Tj
T*
() Tj
T*
(    linux> gcc -o prog2l main2.c ./libvector.so) Tj
T*
() Tj
T*
(这样就创建了一个可执行目标文件 prog2l，而此文件的形式使得它在运行时可以和 libvector.so) Tj
T*
(链接。基本的思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。认识到这一点是很重要的：此时，没有任何 libvector.so) Tj
T*
(的代码和数据节真的被复制到可执行文件 prog2l 中。反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对 libvector.so 中代码和数据的引用。) Tj
T*
() Tj
T*
(当加载器加载和运行可执行文件 prog2l 时，它利用 7.9 节中讨论过的技术，加载部分链接的可执行文件 prog2l。接着，它注意到 prog2l 包含一个 .interp) Tj
T*
(节，这一节包含动态链接器的路径名，动态链接器本身就是一个共享目标（如在 Linux 系统上的 ld-linux.so）.) Tj
T*
(加载器不会像它通常所做地那样将控制传递给应用，而是加载和运行这个动态链接器。然后，动态链接器通过执行下面的重定位完成链接任务：) Tj
T*
() Tj
T*
(* 重定位 libc.so 的文本和数据到某个内存段。) Tj
T*
(* 重定位 libvector.so 的文本和数据到另一个内存段。) Tj
T*
(* 重定位 prog2l 中所有对由 libc.so 和 libvector.so 定义的符号的引用。) Tj
T*
() Tj
T*
(最后，动态链接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.11 从应用程序中加载和链接共享库) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.11 从应用程序中加载和链接共享库) Tj
T*
ET
endstream
endobj
413 0 obj
<< /Length 3452 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
() Tj
T*
(到目前为止，我们已经讨论了在应用程序被加载后执行前时，动态链接器加载和链接共享库的情景。然而，应用程序还可能在它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接) Tj
T*
(到应用中。) Tj
T*
() Tj
T*
(动态链接是一项强大有用的技术。下面是一些现实世界中的例子：) Tj
T*
() Tj
T*
(* 分发软件。微软 Wmdows) Tj
T*
(应用的开发者常常利用共享库来分发软件更新。他们生成一个共库的新版本，然后用户可以下载，并用它替代当前的版本。下一次他们运行应用程序时，应用将自动链接和加载新的共享库。) Tj
T*
(* 构建高性能 Web 服务器。许多 Web 服务器生成动态内容，比如个性化的 Web 页面、账户余额和广告标语 s 早期的 Web 服务器通过使用 fork 和 execve) Tj
T*
(创建一个子进程，并在该子进程的上下文中运行 CGI 程序来生成动态内容。然而，现代高性能的 Web 服务器可以使用基于动态链接的更有效和完善的方法来生成动态内容。) Tj
T*
() Tj
T*
(其思路是将每个生成动态内容的函数打包在共享库中。当一个来自 Web 浏览器的请求到达时，服务器动态地加载和链接适当的函数，然后直接调用它，而不是使用 fork 和 execve 在) Tj
T*
(子进程的上下文中运行函数。函数会一直缓存在服务器的地址空间中，所以只要一个简单的函数调用的开销就可以处理随后的请求了。这对一个繁忙的网站来说是有很大影响的。更进一步地说，在运行时无) Tj
T*
(需停止服务器，就可以更新已存在的函数，以及添加新的函数。) Tj
T*
() Tj
T*
(Linux 系统为动态链接器提供了一个简单的接口，允许应用程序在运行时加载和链接共享库。) Tj
T*
() Tj
T*
(    #include <dlfcn.h>) Tj
T*
() Tj
T*
(    void *dlopen\(const char *filename, int flag\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为指向句柄的指针，若出错则为 NULL。) Tj
T*
() Tj
T*
(dlopen 函数加载和链接共享库 filenameo 用已用带 RTLD\\GLOBAL 选项打开了的库解析 filename 中的外部符号。如果当前可执行文件是带 -) Tj
T*
(rdynamic 选项编译的，那么对符号解析而言，它的全局符号也是可用的。flag 参数必须要么包括 RTLD\\NOW，该标志告诉链接器立即解析对外部符号的引用，要么包括) Tj
T*
(RTLD\\LAZY 标志，该标志指示链接器推迟符号解析直到执行来自库中的代码。这两个值中的任意一个都可以和 RTLD\\GLOBAL 标志取或。) Tj
T*
() Tj
T*
(    #include <dlfcn.h>) Tj
T*
() Tj
T*
(    void *dlsym\(void *handle, char *symbol\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为指向符号的指针，若出错则为 NULL。) Tj
T*
() Tj
T*
(dlsym 函数的输入是一个指向前面已经打开了的共享库的句柄和一个 symbol 名字，如果该符号存在，就返回符号的地址，否则返回 NULL。) Tj
T*
() Tj
T*
(    #include <dlfcn.h>) Tj
T*
() Tj
T*
(    int dlclose \(void *handle\);) Tj
T*
() Tj
T*
(    // 返回:若成功则为0，若出错则为-1.) Tj
T*
() Tj
T*
(如果没有其他共享库还在使用这个共享库，dlclose函数就卸载该共享库。) Tj
T*
() Tj
T*
(    include <dlfcn.h>) Tj
T*
() Tj
T*
ET
endstream
endobj
414 0 obj
<< /Length 2012 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    const char *dlerror\(void\);) Tj
T*
() Tj
T*
(    // 返回：如果前面对 dlopen、dlsym 或 dlclose 的调用失败，) Tj
T*
(    // 则为错误消息，如果前面的调用成功，则为 NULL。) Tj
T*
() Tj
T*
(dlerror 函数返回一个字符串，它描述的是调用 dlopen、dlsym 或者 dlclose 函数时发生的最近的错误，如果没有错误发生，就返回 NULL。) Tj
T*
() Tj
T*
(图 7-17 展示了如何利用这个接口动态链接我们的 libvector.so 共享库，然后调用它的 addvec 例程。要编译这个程序，我们将以下面的方式调用 GCC：) Tj
T*
() Tj
T*
(    linux> gcc -rdynamic -o prog2r dll.c -ldl) Tj
T*
() Tj
T*
(    #include <stdio.h>) Tj
T*
(    #include <stdlib.h>) Tj
T*
(    #include <dlfcn.h>) Tj
T*
() Tj
T*
(    int x[2] = {1, 2};) Tj
T*
(    int y[2] = {3, 4};) Tj
T*
(    int z[2];) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        void *handle;) Tj
T*
(        void \(*addvec\)\(int *, int *, int *, int\);) Tj
T*
(        char *error;) Tj
T*
() Tj
T*
(        /* Dynamically load the shared library containing addvec\(\) */) Tj
T*
(        handle = dlopen\("./libvector.so", RTLD_LAZY\);) Tj
T*
(        if \(!handle\) {) Tj
T*
(            fprintf\(stderr, "%s\\n", dlerror\(\)\);) Tj
T*
(            exit\(1\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Get a pointer to the addvec\(\) function we just loaded */) Tj
T*
(        addvec = dlsym\(handle, "addvec"\);) Tj
T*
(        if \(\(error = dlerror\(\)\) != NULL\) {) Tj
T*
(            fprintf\(stderr, "%s\\n", error\);) Tj
T*
(            exit\(1\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Now we can call addvec\(\) just like any other function */) Tj
T*
(        addvec\(x, y, z, 2\);) Tj
T*
(        printf\("z = [%d %d]\\n", z[0], z[1]\);) Tj
T*
() Tj
T*
(        /* Unload the shared library */) Tj
T*
(        if \(dlclose\(handle\) < 0\) {) Tj
T*
(            fprintf\(stderr, "%s\\n", dlerror\(\)\);) Tj
T*
ET
endstream
endobj
415 0 obj
<< /Length 4300 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            exit\(1\);) Tj
T*
(        }) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 7-17 示例程序 3。在运行时动态加载和链接共享库 libvector.so) Tj
T*
() Tj
T*
(旁注 - 共享库和 Java 本地接口) Tj
T*
() Tj
T*
() Tj
T*
(Java 定义了一个标准调用规则，叫做 Java 本地接口（Java Native Interface，JNI），它允许 Java 程序调用“本地的” C 和 C++ 函数。JNI) Tj
T*
(的基本思想是将本地 C 函数（如 foo）编译到一个共享库中（如 foo.so）。 当一个正在运行的 Java 程序试图调用函数 foo 时，Java 解释器利用 dlopen) Tj
T*
(接口（或者与其类似的接口）动态链接和加载 foo.so，然后再调用 foo。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.12 位置无关代码) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.12 位置无关代码) Tj
T*
() Tj
T*
() Tj
T*
(共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源。那么，多个进程是如何共享程序的一个副本的呢？一种方法是给每个共享库分配一个事先预备的专) Tj
T*
(用的地址空间片，然后要求加载器总是在这个地址加载共享库。虽然这种方法很简单，但是它也造成了一些严重的问题。它对地址空间的使用效率不高，因为即使一个进程不使用这个库，那部分空间还是会) Tj
T*
(被分配出来。它也难以管理。我们必须保证没有片会重叠。每次当一个库修改了之后，我们必须确认已分配给它的片还适合它的大小。如果不适合了，必须找一个新的片。并且，如果创建了一个新的库，我) Tj
T*
(们还必须为它寻找空间。随着时间的进展，假设在一个系统中有了成百个库和库的各个版本库，就很难避免地址空间分裂成大量小的、未使用而又不再能使用的小洞。更糟的是，对每个系统而言，库在内存) Tj
T*
(中的分配都是不同的，这就引起了更多令人头痛的管理问题。) Tj
T*
() Tj
T*
(要避免这些问题，现代系统以这样一种方式编译共享模块的代码段，使得可以把它们加载到内存的任何位置而无需链接器修改。使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。（) Tj
T*
(当然，每个进程仍然会有它自己的读/写数据块。）) Tj
T*
() Tj
T*
(可以加载而无需重定位的代码称为位置无关代码（Position-Independent Code，PIC）。用户对 GCC 使用 -fpic 选项指示 GNU 编译系统生成 PIC) Tj
T*
(代码。共享库的编译必须总是使用该选项。) Tj
T*
() Tj
T*
(在一个 x86-64 系统中，对同一个目标模块中符号的引用是不需要特殊处理使之成为 PIC。可以用 PC) Tj
T*
(相对寻址来编译这些引用，构造目标文件时由静态链接器重定位。然而，对共享模块定义的外部过程和对全局变量的引用需要一些特殊的技巧，接下来我们会谈到。) Tj
T*
() Tj
T*
(1. PIC 数据引用) Tj
T*
() Tj
T*
() Tj
T*
(编译器通过运用以下这个有趣的事实来生成对全局变量的 PIC 引用：无论我们在内存中的何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变。因此，代码段中任何指) Tj
T*
(令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置是无关的。) Tj
T*
() Tj
T*
(想要生成对全局变量 PIC 引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做全局偏移量表（Global Offset Table，GOT）。在 GOT) Tj
T*
(中，每个被这个目标模块引用的全局数据目标（过程或全局变量）都有一个 8 字节条目。编译器还为 GOT 中每个条目生成一个重定位记录。在加载时，动态链接器会重定位 GOT) Tj
T*
(中的每个条目，使得它包含目标的正确的绝对地址。每个引用全局目标的目标模块都有自己的 GOT。) Tj
T*
ET
endstream
endobj
416 0 obj
<< /Length 4914 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(图 7-18 展示了示例 libvector.so 共享模块的 GOT。addvec 例程通过 GOT\\[3\\] 间接地加载全局变量 addcnt 的地址，然后把 addcnt) Tj
T*
(在内存中加 1。这里的关键思想是对 GOTQ\\[3\\] 的 PC 相对引用中的偏移量是一个运行时常量。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 7-18 用 GOT 引用全局变量。libvector.so 中的 addvec 例程通过 libvector.so 的 GOT 间接引用了 addcnt) Tj
T*
() Tj
T*
(因为 addcnt 是由 libvector.so 模块定义的，编译器可以利用代码段和数据段之间不变的距离，产生对 addcnt 的直接 PC) Tj
T*
(相对引用，并增加一个重定位，让链接器在构造这个共享模块时解析它。不过，如果 addcnt 是由另一个共享模块定义的，那么就需要通过 GOT) Tj
T*
(进行间接访问。在这里，编译器选择采用最通用的解决方案，为所有的引用使用 GOT。) Tj
T*
() Tj
T*
(2.PIC 函数调用) Tj
T*
() Tj
T*
() Tj
T*
(假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。正常的方法是为该引用生成一条重定位记录，然后动态链接器在) Tj
T*
(程序加载的时候再解析它。不过，这种方法并不是 PIC，因为它需要链接器修改调用模块的代码段，GNU 编译系统使用了一种很有趣的技术来解决这个问题，称为延迟绑定（lazy) Tj
T*
(binding），将过程地址的绑定推迟到第一次调用该过程时。) Tj
T*
() Tj
T*
(使用延迟绑定的动机是对于一个像 libc.so 这样的共享库输出的成百上千个函数中，一个典型的应用程序只会使用其中很少的一部分。把函数地址的解析推迟到它实际被调用的地方，能避免动态) Tj
T*
(链接器在加载时进行成百上千个其实并不需要的重定位。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接的内存引用。) Tj
T*
() Tj
T*
(延迟绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是：GOT 和过程链接表（Procedure Linkage) Tj
T*
(Table，PLT）。如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的 GOT 和 PLT。GOT 是数据段的一部分，而 PLT 是代码段的一部分。) Tj
T*
() Tj
T*
(图 7-19 展示的是 PLT 和 GOT 如何协作在运行时解析函数的地址。首先，让我们检查一下这两个表的内容。) Tj
T*
() Tj
T*
(* 过程链接表（PLT）。PLT 是一个数组，其中每个条目是 16 字节代码。PLT\\[0\\] 是一个特殊条目，它跳转到动态链接器中。每个被可执行程序调用的库函数都有它自己的) Tj
T*
(PLT 条目。每个条目都负责调用一个具体的函数。PLT\\[1\\]（图中未显示）调用系统启动函数（\\\\libc\\start\\main），它初始化执行环境，调用 main) Tj
T*
(函数并处理其返回值从 PLT\\[2\\] 开始的条目调用用户代码调用的函数。在我们的例子中，PLT\\[2\\] 调用 addvec，PLT\\[3\\]（图中未显示）调用 printf。) Tj
T*
(* 全局偏移量表（GOT）。正如我们看到的，GOT 是一个数组，其中每个条目是 8 字节地址。和 PLT 联合使用时，GOTfO\\] 和 GOT\\[1\\]) Tj
T*
(包含动态链接器在解析函数地址时会使用的信息。GOT\\[2\\] 是动态链接器在 ld-linux.so) Tj
T*
(模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的 PLT 条目。例如，GOT\\[4\\] 和 PLT\\[2\\] 对应于) Tj
T*
(addvec。初始时，每个 GOT 条目都指向对应 PLT 条目的第二条指令。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 7-19 用 PLT 和 GOT 调用外部函数。在第一次调用 addvec 时，动态链接器解析它的地址) Tj
T*
() Tj
T*
(图 7-19a 展示了 GOT 和 PLT 如何协同工作，在 addvec 被第一次调用时，延迟解析它的运行时地址：) Tj
T*
() Tj
T*
(* 第 1 步。不直接调用 addvec，程序调用进入 PLT\\[2\\]，这是 addvec 的 PLT 条目。) Tj
T*
(* 第 2 步。第一条 PLT 指令通过 GOT\\[4\\] 进行间接跳转。因为每个 GOT 条目初始时都指向它对应的 PLT 条目的第二条指令，这个间接跳转只是简单地把控制传送回) Tj
T*
(PLT\\[2\\] 中的下一条指令。) Tj
T*
(* 第 3 步。在把 addvec 的 ID（0x1）压入栈中之后，PLT\\[2\\] 跳转到 PLT\\[0\\]。) Tj
T*
(* 第 4 步。PLT\\[0\\] 通过 GOT\\[1\\] 间接地把动态链接器的一个参数压入栈中，然后通过 GOT\\[2\\] 间接跳转进动态链接器中。动态链接器使用两个栈条目来确定) Tj
T*
ET
endstream
endobj
417 0 obj
<< /Length 2740 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(addvec 的运行时位置，用这个地址重写 GOT\\[4\\]，再把控制传递给 addvec。) Tj
T*
() Tj
T*
(图 7-19b 给出的是后续再调用 addvec 时的控制流：) Tj
T*
() Tj
T*
(* 第 1 步。和前面一样，控制传递到 PLT\\[2\\]。) Tj
T*
(* 第 2 步。不过这次通过 GOT\\[4\\] 的间接跳转会将控制直接转移到 addvec。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.13 库打桩机制) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.13 库打桩机制) Tj
T*
() Tj
T*
() Tj
T*
(Linux 链接器支持一个很强大的技术，称为库打桩（library interpositioning），它允许你截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，你可以) Tj
T*
(追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出值，或者甚至把它替换成一个完全不同的实现。) Tj
T*
() Tj
T*
(下面是它的基本思想：给定一个需要打桩的目标函数，创建一个包装函数，它的原型与目标函数完全一样。使用某种特殊的打桩机制，你就可以欺骗系统调用包装函数而不是目标函数了。包装函数通常会执) Tj
T*
(行它自己的逻辑，然后调用目标函数，再将目标函数的返回值传递给调用者。) Tj
T*
() Tj
T*
(打桩可以发生在编译时、链接时或当程序被加载和执行的运行时。要研究这些不同的机制，我们以图 7-20a 中的示例程序作为运行例子。它调用 C 标准库（libc.so）中的) Tj
T*
(malloc 和 free 函数。对 malloc 的调用从堆中分配一个 32 字节的块，并返回指向该块的指针。对 free 的调用把块还回到堆，供后续的 malloc) Tj
T*
(调用使用。我们的目标是用打桩来追踪程序运行时对 malloc 和 free 的调用。) Tj
T*
() Tj
T*
(7.13.1 编译时打桩) Tj
T*
() Tj
T*
() Tj
T*
(图 7-20 展示了如何使用 C 预处理器在编译时打桩。mymalloc.c 中的包装函数（图 7-20c）调用目标函数，打印追踪记录，并返回。本地的 malloc.h 头文件（图) Tj
T*
(7-20b）指示预处理器用对相应包装函数的调用替换掉对目标函数的调用。) Tj
T*
() Tj
T*
(    #include <stdio.h>) Tj
T*
(    #include <malloc.h>) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int *p = malloc\(32\);) Tj
T*
(        free\(p\);) Tj
T*
(        return\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> a\\\) 示例程序 int.c) Tj
T*
() Tj
T*
(    #define malloc\(size\) mymalloc\(size\)) Tj
T*
(    #define free\(ptr\) myfree\(ptr\)) Tj
T*
() Tj
T*
ET
endstream
endobj
418 0 obj
<< /Length 1601 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    void *mymalloc\(size_t size\);) Tj
T*
(    void myfree\(void *ptr\);) Tj
T*
() Tj
T*
(> b\\\) 本地 malloc.h 文件) Tj
T*
() Tj
T*
(    #ifdef COMPILETIME) Tj
T*
(    #include <stdio.h>) Tj
T*
(    #include <malloc.h>) Tj
T*
() Tj
T*
(    /* malloc wrapper function */) Tj
T*
(    void *mymalloc\(size_t size\)) Tj
T*
(    {) Tj
T*
(        void *ptr = malloc\(size\);) Tj
T*
(        printf\("malloc\(%d\)=%p\\n",) Tj
T*
(               \(int\)size, ptr\);) Tj
T*
(        return ptr;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* free wrapper function */) Tj
T*
(    void myfree\(void *ptr\)) Tj
T*
(    {) Tj
T*
(        free\(ptr\);) Tj
T*
(        printf\("free\(%p\)\\n", ptr\);) Tj
T*
(    }) Tj
T*
(    #endif) Tj
T*
() Tj
T*
(> c\\\) mymalloc.c 中的包装函数) Tj
T*
(>) Tj
T*
(> 图 7-20 用 C 预处理进行编译时打桩) Tj
T*
() Tj
T*
(像下面这样编译和链接这个程序：) Tj
T*
() Tj
T*
(    linux> gcc -DCOMPILETIME -c mymalloc.c) Tj
T*
(    linux> gcc -I. -o intc int.c mymalloc.o) Tj
T*
() Tj
T*
(运行这个程序会得到如下的追踪信息：) Tj
T*
() Tj
T*
(    linux> ./intc) Tj
T*
(    malloc\(32\)=0x9ee010) Tj
T*
(    free\(0x9ee010\)) Tj
T*
() Tj
T*
(7.13.2 链接时打桩) Tj
T*
() Tj
T*
() Tj
T*
(Linux 静态链接器支持用 --wrap f 标志进行链接时打桩。这个标志告诉链接器，把对符号 f 的引用解析成 wrap\\f（前缀是两个下划线），还要把对符号) Tj
T*
(\\\\real\\f（前缀是两个下划线）的引用解析为 f。图 7-21 给出我们示例程序的包装函数。) Tj
T*
ET
endstream
endobj
419 0 obj
<< /Length 1601 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(    #ifdef LINKTIME) Tj
T*
(    #include <stdio.h>) Tj
T*
() Tj
T*
(    void *__real_malloc\(size_t size\);) Tj
T*
(    void __real_free\(void *ptr\);) Tj
T*
() Tj
T*
(    /* malloc wrapper function */) Tj
T*
(    void *__wrap_malloc\(size_t size\)) Tj
T*
(    {) Tj
T*
(        void *ptr = __real_malloc\(size\); /* Call libc malloc */) Tj
T*
(        printf\("malloc\(%d\) = %p\\n", \(int\)size, ptr\);) Tj
T*
(        return ptr;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* free wrapper function */) Tj
T*
(    void __wrap_free\(void *ptr\)) Tj
T*
(    {) Tj
T*
(        __real_free\(ptr\); /* Call libc free */) Tj
T*
(        printf\("free\(%p\)\\n", ptr\);) Tj
T*
(    }) Tj
T*
(    #endif) Tj
T*
() Tj
T*
(> 图 7-21 用 --wrap 标志进行链接时打桩) Tj
T*
() Tj
T*
(用下述方法把这些源文件编译成可重定位目标文件：) Tj
T*
() Tj
T*
(    linux> gcc -DLINKTIME -c mymalloc.c) Tj
T*
(    linux> gcc -c int.c) Tj
T*
() Tj
T*
(然后把目标文件链接成可执行文件：) Tj
T*
() Tj
T*
(    linux> gcc -Wl,--wrap,malloc -Wl,--wrap,free -o intl int.o mymalloc.o) Tj
T*
() Tj
T*
(-Wl,option 标志把 option 传递给链接器。option 中的每个逗号都要替换为一个空格。所以 -Wl,--wrap,malloc 就把 --wrap malloc) Tj
T*
(传递给链接器，以类似的方式传递 -Wl,--wrap,free。) Tj
T*
() Tj
T*
(运行该程序会得到如下追踪信息：) Tj
T*
() Tj
T*
(    linux> ./intl) Tj
T*
(    malloc\(32\) = 0x18cf010) Tj
T*
(    free\(0x18cf010\)) Tj
T*
() Tj
T*
(7.13.3 运行时打桩) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
420 0 obj
<< /Length 2339 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(编译时打桩需要能够访问程序的源代码，链接时打桩需要能够访问程序的可重定位对象文件。不过，有一种机制能够在运行时打桩，它只需要能够访问可执行目标文件。这个很厉害的机制基于动态链接器的) Tj
T*
(LD\\_PRELOAD 环境变量。) Tj
T*
() Tj
T*
(如果 LD\\PRELOAD 环境变量被设置为一个共享库路径名的列表（以空格或分号分隔），那么当你加载和执行一个程序，需要解析未定义的引用时，动态链接器（LD-) Tj
T*
(LINUX.SO）会先搜索 LD\\PRELOAD 库，然后才搜索任何其他的库。有了这个机制，当你加载和执行任意可执行文件时，可以对任何共享库中的任何函数打桩，包括 libc.so。) Tj
T*
() Tj
T*
(图 7-22 展示了 malloc 和 free 的包装函数。每个包装函数中，对 dlsym 的调用返回指向目标 libc) Tj
T*
(函数的指针。然后包装函数调用目标函数，打印追踪记录，再返回。) Tj
T*
() Tj
T*
(    #ifdef RUNTIME) Tj
T*
(    #define _GNU_SOURCE) Tj
T*
(    #include <stdio.h>) Tj
T*
(    #include <stdlib.h>) Tj
T*
(    #include <dlfcn.h>) Tj
T*
() Tj
T*
(    /* malloc wrapper function */) Tj
T*
(    void *malloc\(size_t size\)) Tj
T*
(    {) Tj
T*
(        void *\(*mallocp\)\(size_t size\);) Tj
T*
(        char *error;) Tj
T*
() Tj
T*
(        mallocp = dlsym\(RTLD_NEXT, "malloc"\); /* Get address of libc   malloc */) Tj
T*
(        if \(\(error = dlerror\(\)\) != NULL\) {) Tj
T*
(            fputs\(error, stderr\);) Tj
T*
(            exit\(1\);) Tj
T*
(        }) Tj
T*
(        char *ptr = mallocp\(size\); /* Call libc malloc */) Tj
T*
(        printf\("malloc\(%d\) = %p\\n", \(int\)size, ptr\);) Tj
T*
(        return ptr;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* free wrapper function */) Tj
T*
(    void free\(void *ptr\)) Tj
T*
(    {) Tj
T*
(        void \(*freep\)\(void *\) = NULL;) Tj
T*
(        char *error;) Tj
T*
() Tj
T*
(        if \(!ptr\)) Tj
T*
(        return;) Tj
T*
() Tj
T*
(        freep = dlsym\(RTLD_NEXT, "free"\); /* Get address of libc free */) Tj
T*
(        if \(\(error = dlerror\(\)\) != NULL\) {) Tj
T*
(            fputs\(error, stderr\);) Tj
T*
(            exit\(1\);) Tj
T*
(        }) Tj
T*
(        freep\(ptr\); /* Call libc free */) Tj
T*
ET
endstream
endobj
421 0 obj
<< /Length 1723 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        printf\("free\(%p\)\\n", ptr\);) Tj
T*
(    }) Tj
T*
(    #endif) Tj
T*
() Tj
T*
(> 图 7-22 用 LD\\_PRELOAD 进行运行时打桩) Tj
T*
() Tj
T*
(下面是如何构建包含这些包装函数的共享库的方法：) Tj
T*
() Tj
T*
(    linux> gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl) Tj
T*
() Tj
T*
(这是如何编译主程序：) Tj
T*
() Tj
T*
(    linux> gcc -o intr int.c) Tj
T*
() Tj
T*
(下面是如何从 bash shell 中运行这个程序：) Tj
T*
() Tj
T*
(    linux> LD_PRELOAD="./mymalloc.so" ./intr) Tj
T*
(    malloc\(32\) = 0x1bf7010) Tj
T*
(    free\(0x1bf7010\)) Tj
T*
() Tj
T*
(下面是如何在 csh 或 tcsh 中运行这个程序：) Tj
T*
() Tj
T*
(    linux> \(setenv LD_PRELOAD "./mymalloc.so"; ./intr; unsetenv LD_PRELOAD\)) Tj
T*
(    malloc\(32\) = 0x2157010) Tj
T*
(    free\(0x2157010\)) Tj
T*
() Tj
T*
(请注意，你可以用 LD\\_PRELOAD 对任何可执行程序的库函数调用打桩！) Tj
T*
() Tj
T*
(    linux> LD_PRELOAD="./mymalloc.so" /usr/bin/uptime) Tj
T*
(    malloc\(568\) = 0x21bb010) Tj
T*
(    free\(0x21bb010\)) Tj
T*
(    malloc\(15\) = 0x21bb010) Tj
T*
(    malloc\(568\) = 0x21bb030) Tj
T*
(    malloc\(2255\) = 0x21bb270) Tj
T*
(    free\(0x21bb030\)) Tj
T*
(    malloc\(20\) = 0x21bb030) Tj
T*
(    malloc\(20\) = 0x21bb050) Tj
T*
(    malloc\(20\) = 0x21bb070) Tj
T*
(    malloc\(20\) = 0x21bb090) Tj
T*
(    malloc\(20\) = 0x21bb0b0) Tj
T*
(    malloc\(384\) = 0x21bb0d0) Tj
T*
(    20:47:36 up 85 days, 6:04, 1 user, load average: 0.10, 0.04, 0.05) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.14 处理目标文件的工具) Tj
T*
ET
endstream
endobj
422 0 obj
<< /Length 3720 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(================================================================================) Tj
T*
() Tj
T*
(7.14 处理目标文件的工具) Tj
T*
() Tj
T*
() Tj
T*
(7.14 处理目标文件的工具) Tj
T*
() Tj
T*
(在 Linux 系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地，GNU binutils 包尤其有帮助，而且可以运行在每个 Linux 平台上。) Tj
T*
() Tj
T*
(* AR：创建静态库，插入、删除、列出和提取成员。) Tj
T*
(* STRINGS：列出一个目标文件中所有可打印的字符串。) Tj
T*
(* STRIP：从目标文件中删除符号表信息。) Tj
T*
(* NM：列出一个目标文件的符号表中定义的符号。) Tj
T*
(* SIZE：列出目标文件中节的名字和大小。) Tj
T*
(* READELF：显示一个目标文件的完整结构，包括 ELF 头中编码的所有信息。包含 SIZE 和 NM 的功能。) Tj
T*
(* OBJDUMP：所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编 .text 节中的二进制指令。) Tj
T*
() Tj
T*
(Linux 系统为操作共享库还提供了 LDD 程序：) Tj
T*
() Tj
T*
(* LDD：列出一个可执行文件在运行时所需要的共享库。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(7.15 小结) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(7.15 小结) Tj
T*
() Tj
T*
() Tj
T*
(链接可以在编译时由静态编译器来完成，也可以在加载时和运行时由动态链接器来完成。链接器处理称为目标文件的二进制文件，它有 3 种不同的形式：可重定位的、可执行的和共享的。可重定位的目) Tj
T*
(标文件由静态链接器合并成一个可执行的目标文件，它可以加载到内存中并执行。共享目标文件（共享库）是在运行时由动态链接器链接和加载的，或者隐含地在调用程序被加载和开始执行时，或者根据需) Tj
T*
(要在程序调用 dlopen 库的函数时。) Tj
T*
() Tj
T*
(链接器的两个主要任务是符号解析和重定位，符号解析将目标文件中的每个全局符号都绑定到亠个唯一的定义，而重定位确定每个符号的最终内存地址，并修改对那些目标的引用。) Tj
T*
() Tj
T*
(静态链接器是由像 GCC 这样的编译驱动程序调用的。它们将多个可重定位目标文件合并成一个单独的可执行目标文件。多个目标文件可以定义相同的符号，而链接器用来悄悄地解析这些多重定义的规) Tj
T*
(则可能在用户程序中引入微妙的错误。) Tj
T*
() Tj
T*
(多个目标文件可以被连接到一个单独的静态库中。链接器用库来解析其他目标模块中的符号引用。许多链接器通过从左到右的顺序扫描来解析符号引用，这是另一个引起令人迷惑的链接时错误的来源。) Tj
T*
() Tj
T*
(加载器将可执行文件的内容映射到内存，并运行这个程序。链接器还可能生成部分链接的可执行目标文件，这样的文件中有对定义在共享库中的例程和数据的未解析的引用。在加载时，加载器将部分链接的) Tj
T*
(可执行文件映射到内存，然后调用动态链接器，它通过加载共享库和重定位程序中的引用来完成链接任务。) Tj
T*
() Tj
T*
(被编译为位置无关代码的共享库可以加载到任何地方，也可以在运行时被多个进程共享。为了加载、链接和访问共享库的函数和数据，应用程序也可以在运行时使用动态链接器。) Tj
T*
() Tj
T*
(参考文献说明) Tj
T*
ET
endstream
endobj
423 0 obj
<< /Length 2129 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
() Tj
T*
(在计算机系统文献中并没有很好地记录链接。因为链接是处在编译器、计算机体系结构和操作系统的交叉点上，它要求理解代码生成、机器语言编程、程序实例化和虚拟内存。它没有恰好落在某个通常的计) Tj
T*
(算机系统领域中，因此这些领域的经典文献并没有很好地描述它。然而，Levine 的专著提供了有关这个主题的很好的一般性参考资料【69】。【54】描述了 ELF 和 DWARF（对) Tj
T*
(.debug 和 .line 节内容的规范）的原始 IA32 规范。【36】描述了对 ELF 文件格式的 x86-64 扩展。x86-64) Tj
T*
(应用二进制接口（ABI）描述了编译、链接和运行 X86-64 程序的惯例，其中包括重定位和位置无关代码的规则【77】。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(家庭作业) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(家庭作业) Tj
T*
() Tj
T*
() Tj
T*
(练习题 7.6) Tj
T*
() Tj
T*
() Tj
T*
(这道题是关于图 7-5 的 m.o 模块和下面的 swap.c 函数版本的，该函数计算自己被调用的次数：) Tj
T*
() Tj
T*
(    extern int buf[];) Tj
T*
() Tj
T*
(    int *bufp0 = &buf[0];) Tj
T*
(    static int *bufp1;) Tj
T*
() Tj
T*
(    static void incr\(\)) Tj
T*
(    {) Tj
T*
(        static int count=0;) Tj
T*
() Tj
T*
(        count++;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    void swap\(\)) Tj
T*
(    {) Tj
T*
(        int temp;) Tj
T*
() Tj
T*
(        incr\(\);) Tj
T*
(        bufp1 = &buf[1];) Tj
T*
(        temp = *bufp0;) Tj
T*
(        *bufp0 = *bufp1;) Tj
T*
(        *bufp1 = temp;) Tj
T*
(    }) Tj
T*
() Tj
T*
(对于每个 swap.o 中定义和引用的符号，请指出它是否在模块 swap.o 的 .symtab 节中有符号表条目。如果是这样，请指出定义该符号的模块（swap.o 或) Tj
T*
(m.o）、符号类型（局部、全局或外部）以及它在模块中所处的节（.text、.data 或 .bss）。) Tj
T*
() Tj
T*
ET
endstream
endobj
424 0 obj
<< /Length 1901 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(| 符号 | swap.o .symtab 条目？ | 符号类型 | 定义符号的模块 | 节 |) Tj
T*
(| :--- | :--- | :--- | :--- | :--- |) Tj
T*
(| buf |  |  |  |  |) Tj
T*
(| bufp0 |  |  |  |  |) Tj
T*
(| bufp1 |  |  |  |  |) Tj
T*
(| swap |  |  |  |  |) Tj
T*
(| temp |  |  |  |  |) Tj
T*
(| incr |  |  |  |  |) Tj
T*
(| count |  |  |  |  |) Tj
T*
() Tj
T*
(练习题 7.7) Tj
T*
() Tj
T*
() Tj
T*
(不改变任何变量名字，修改 7.6.1 节中的 bar5.c，使得 foo5.c 输出 x 和 y 的正确值（也就是整数 15213 和 15212 的十六进制表示）。) Tj
T*
() Tj
T*
(练习题 7.8) Tj
T*
() Tj
T*
() Tj
T*
(在此题中，REF\\\(x,i\\\) → DEF\\\(x,k\\\) 表示链接器将任意对模块 i 中符号 x 的引用与模块 k 中符号 x) Tj
T*
(的定义相关联。在下面每个例子中，用这种符号来说明链接器是如何解析在每个模块中有多重定义的引用的。如果出现链接时错误（规则 1），写“错误”。如果链接器从定义中任意选择一个（规则) Tj
T*
(3），那么写“未知”。) Tj
T*
() Tj
T*
(A.) Tj
T*
() Tj
T*
(\\\(a\\\) REF\\\(main.1\\\) → DEF\\\(\\\\\\\\.\\\\\\\)) Tj
T*
() Tj
T*
(\\\(b\\\) REF\\\(main.2\\\) → DEF\\\(\\\\\\\\.\\\\\\\)) Tj
T*
() Tj
T*
(    /* Module 1 */    |     /* Module 2 */) Tj
T*
(    int main\(\)        |     static int main=1[) Tj
T*
(    {                 |     int p2\(\)) Tj
T*
(    }                 |     {) Tj
T*
(                      |     }) Tj
T*
() Tj
T*
(B.) Tj
T*
() Tj
T*
(\\\(a\\\) REF\\\(x.1\\\) → DEF\\\(\\\\\\\\.\\\\\\\)) Tj
T*
() Tj
T*
(\\\(b\\\) REF\\\(x.2\\\) → DEF\\\(\\\\\\\\.\\\\\\\)) Tj
T*
() Tj
T*
(    /* Module 1 */    |     /* Module 2 */) Tj
T*
(    int x;            |     double x;) Tj
T*
(    void main\(\)       |     int p2\(\)) Tj
T*
(    {                 |     {) Tj
T*
(    }                 |     }) Tj
T*
() Tj
T*
ET
endstream
endobj
425 0 obj
<< /Length 1603 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(C.) Tj
T*
() Tj
T*
(\\\(a\\\) REF\\\(x.1\\\) → DEF\\\(\\\\\\\\.\\\\\\\)) Tj
T*
() Tj
T*
(\\\(b\\\) REF\\\(x.2\\\) → DEF\\\(\\\\\\\\.\\\\\\\)) Tj
T*
() Tj
T*
(    /* Module 1 */    |     /* Module 2 */) Tj
T*
(    int x=1;          |     double x=1.0;) Tj
T*
(    void main\(\)       |     int p2\(\)) Tj
T*
(    {                 |     {) Tj
T*
(    }                 |     }) Tj
T*
() Tj
T*
(练习题 7.9) Tj
T*
() Tj
T*
() Tj
T*
(考虑下面的程序，它由两个目标模块组成：) Tj
T*
() Tj
T*
(    /* foo6.c */) Tj
T*
(    void p2\(void\);) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        p2\(\);) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* bar6.c */) Tj
T*
(    #include <stdio.h>) Tj
T*
(    char main;) Tj
T*
(    void p2\(\)) Tj
T*
(    {) Tj
T*
(        printf\("0x%x\\n", main\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(当在 x86-64Linux 系统中编译和执行这个程序时，即使函数 p2 不初始化变量 main，它也能打印字符串 “0x48\\n” 并正常终止。你能解释这一点吗？) Tj
T*
() Tj
T*
(练习题 7.10) Tj
T*
() Tj
T*
() Tj
T*
(a 和 b 表示当前路径中的目标模块或静态库，而 a → b 表示 a 依赖于 b，也就是说 a 引用了一个 b) Tj
T*
(定义的符号。对于下面的每个场景，给出使得静态链接器能够解析所有符号引用的最小的命令行（即含有最少数量的目标文件和库参数的命令）。) Tj
T*
() Tj
T*
(A. p.o → libx.a → p.o) Tj
T*
() Tj
T*
(B. p.o → libx.a → liby.a 和 liby.a → libx.a) Tj
T*
() Tj
T*
ET
endstream
endobj
426 0 obj
<< /Length 1861 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(C. p.o → libx.a → liby.a → libz.a 和 liby.a → libx.a → libz.a) Tj
T*
() Tj
T*
(练习题 7.11) Tj
T*
() Tj
T*
() Tj
T*
(图 7-14 中的程序头部表明数据段占用了内存中 0x230 个字节。然而，其中只有开始的 0x228 字节来自可执行文件的节。是什么引起了这种差异？) Tj
T*
() Tj
T*
(练习题 7.12) Tj
T*
() Tj
T*
() Tj
T*
(考虑目标文件 m.o 中对函数 swap 的调用（作业题 7.6）。) Tj
T*
() Tj
T*
(      9: e8 00 00 00 00      callq e <main+0xe>     swap\(\)) Tj
T*
() Tj
T*
(具有如下重定位条目：) Tj
T*
() Tj
T*
(    r.offset = 0xa) Tj
T*
(    r.symbol = swap) Tj
T*
(    r.type   = R_X86_64_PC32) Tj
T*
(    r.addend = -4) Tj
T*
() Tj
T*
(A. 假设链接器将 m.o 中的 .text 重定位到地址 0x4004e0，把 swap 重定位到地址 0x4004f8。那么 callq 指令中对 swap) Tj
T*
(的重定位引用的值应该是什么？) Tj
T*
() Tj
T*
(B. 假设链接器将 m.o 中的 .text 重定位到地址 0x4004d0，把 swap 重定位到地址 0x400500。那么 callq 指令中对 swap) Tj
T*
(的重定位引用的值应该是什么？) Tj
T*
() Tj
T*
(练习题 7.13) Tj
T*
() Tj
T*
() Tj
T*
(完成下面的任务将帮助你更熟悉处理目标文件的各种工具。) Tj
T*
() Tj
T*
(A. 在你的系统上，lib.c 和 libm.a 的版本中包含多少目标文件？) Tj
T*
() Tj
T*
(B. gcc -Og 产生的可执行代码与 gcc -Og -g 产生的不同吗？) Tj
T*
() Tj
T*
(C. 在你的系统上，GCC 驱动程序使用的是什么共享库？) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(第 8 章：异常控制流) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(第 8 章：异常控制流) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
427 0 obj
<< /Length 5179 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(从给处理器加电开始，直到你断电为止，程序计数器假设一个值的序列) Tj
T*
() Tj
T*
($$) Tj
T*
(a0, a1, \\cdots, a_{n-1}) Tj
T*
($$) Tj
T*
() Tj
T*
(其中，每个 $$ak$$ 是某个相应的指令 $$Ik$$ 的地址。每次从 $$ak$$ 到 $$a{k+1}$$ 的过渡称为控制转移（control) Tj
T*
(transfer）。这样的控制转移序列叫做处理器的控制流（flow of control 或 control flow）。) Tj
T*
() Tj
T*
(最简单的一种控制流是一个“平滑的”序列，其中每个$$Ik$$和$$I{k+1}$$在内存中都是相邻的。这种平滑流的突变（也就是$$I{k+1}$$与$$Ik$$不相邻）通常是由诸如) Tj
T*
(跳转、调用和返回这样一些熟悉的程序指令造成的。这样一些指令都是必要的机制，使得程序能够对由程序变量表示的内部程序状态中的变化做出反应。) Tj
T*
() Tj
T*
(但是系统也必须能够对系统状态的变化做出反应，这些系统状态不是被内部程序变量捕获的，而且也不一定要和程序的执行相关。比如，一个硬件定时器定期产生信号，这个事件必须得到处理。包到达网络) Tj
T*
(适配器后，必须存放在内存中。程序向磁盘请求数据，然后休眠，直到被通知说数据已就绪。当子进程终止时，创造这些子进程的父进程必须得到通知。) Tj
T*
() Tj
T*
(现代系统通过使控制流发生突变来对这些情况做出反应。一般而言，我们把这些突变称为异常控制流（Exceptional Control Flow，ECF）。异常控制流发生在计算机系统的各) Tj
T*
(个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。在应用层，一个进程可以发送信号到) Tj
T*
(另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。—个程序可以通过回避通常的栈规则，并执行到其他函数中任意位置的非本地跳转来对错误做出反应。) Tj
T*
() Tj
T*
(作为程序员，理解 ECF 很重要，这有很多原因：) Tj
T*
() Tj
T*
(* 理解 ECF 将帮助你理解重要的系统概念。ECF 是操作系统用来实现 I/O、进程和虚拟内存的基本机制。在能够真正理解这些重要概念之前，你必须理解 ECF。) Tj
T*
(* 理解 ECF 将帮助你理解应用程序是如何与操作系统交互的。应用程序通过使用一个叫做陷阱（trap）或者系统调用（system call）的 ECF 形式，向操作系统请求服务。比) Tj
T*
(如，向磁盘写数据、从网络读取数据、创建一个新进程，以及终止当前进程，都是通过应用程序调用系统调用来实现的。理解基本的系统调用机制将帮助你理解这些服务是如何提供给应用的。) Tj
T*
(* 理解 ECF 将帮助你编写有趣的新应用程序。操作系统为应用程序提供了强大的 ECF) Tj
T*
(机制，用来创建新进程、等待进程终止、通知其他进程系统中的异常事件，以及检测和响应这些事件。如果理解了这些 ECF 机制，那么你就能用它们来编写诸如 Unix shell 和 Web) Tj
T*
(服务器之类的有趣程序了。) Tj
T*
(* 理解 ECF 将帮助你理解并发。ECF) Tj
T*
(是计算机系统中实现并发的基本机制。在运行中的并发的例子有：中断应用程序执行的异常处理程序，在时间上重叠执行的进程和线程，以及中断应用程序执行的信号处理程序。理解 ECF) Tj
T*
(是理解并发的第一步。我们会在第 12 章中更详细地研究并发。) Tj
T*
(* 理解 ECF 将帮助你理解软件异常如何工作。像 C++ 和 Java 这样的语言通过 try、catch 以及 throw) Tj
T*
(语句来提供软件异常机制。软件异常允许程序进行非本地跳转（即违反通常的调用/返回栈规则的跳转）来响应错误情况。非本地跳转是一种应用层 ECF，在 C 中是通过 setjmp 和) Tj
T*
(longjmp 函数提供的。理解这些低级函数将帮助你理解高级软件异常如何得以实现。) Tj
T*
() Tj
T*
(对系统的学习，到目前为止你已经了解了应用是如何与硬件交互的。本章的重要性在于你将开始学习应用是如何与操作系统交互的。有趣的是，这些交互都是围绕着 ECF) Tj
T*
(的。我们将描述存在于一个计算机系统中所有层次上的各种形式的 ECF。从异常开始，异常位于硬件和操作系统交界的部分。我们还会讨论系统调用，它们是为应用程序提供到操作系统的入口点的异常) Tj
T*
(。然后，我们会提升抽象的层次，描述进程和信号，它们位于应用和操作系统的交界之处。最后讨论非本地跳转，这是 ECF 的一种应用层形式。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(8.1 异常) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(8.1 异常) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
428 0 obj
<< /Length 4296 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。因为它们有一部分是由硬件实现的，所以具体细节将随系统的不同而有所不同。然而，对于每个系统而言，基本的思想都是相) Tj
T*
(同的。在这一节中我们的目的是让你对异常和异常处理有一个一般性的了解，并且向你揭示现代计算机系统的一个经常令人感到迷惑的方面。) Tj
T*
() Tj
T*
(异常（exception）就是控制流中的突变，用来响应处理器状态中的某些变化。图 8-1 展示了基本的思想。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 8-1 异常的剖析。处理器状态中的变化（事件）触发从应用程序到异常处理程序的突发的控制转移（异常）。在异常处理程序完成处理后，它将控制返回给被中断的程序或者终止) Tj
T*
() Tj
T*
(在图中，当处理器状态中发生一个重要的变化时，处理器正在执行某个当前指令 $$I_{curr}$$ 。在处理器中，状态被编码为不同的位和信号。状态变化称为事件（event）.) Tj
T*
(事件可能和当前指令的执行直接相关。比如，发生虚拟内存缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个) Tj
T*
(I/O 请求完成。) Tj
T*
() Tj
T*
(在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表（exception) Tj
T*
(table）的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序（exception) Tj
T*
(handler））.当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下 3 种情况中的一种：) Tj
T*
() Tj
T*
(1. 处理程序将控制返回给当前指令 $$I_{curr}$$ ，即当事件发生时正在执行的指令。) Tj
T*
(2. 处理程序将控制返回给 $$I_{next}$$ ，如果没有发生异常将会执行的下一条指令。) Tj
T*
(3. 处理程序终止被中断的程序。) Tj
T*
() Tj
T*
(8.1.2 节将讲述关于这些可能性的更多内容。) Tj
T*
() Tj
T*
(旁注 - 硬件异常与软件异常) Tj
T*
() Tj
T*
() Tj
T*
(C++ 和 Java 的程序员会注意到术语 “异常” 也用来描述由 C++ 和 Java 以 catch、throw 和 try 语句形式提供的应用级) Tj
T*
(ECF。如果想严格清晰，我们必须区别 “硬件” 和“软件” 异常，但这通常是不必要的，因为从上下文中就能够很清楚地知道是哪种含义。) Tj
T*
() Tj
T*
(8.1.1 异常处理) Tj
T*
() Tj
T*
() Tj
T*
(异常可能会难以理解，因为处理异常需要硬件和软件紧密合作。很容易搞混哪个部分执行哪个任务。让我们更详细地来看看硬件和软件的分工吧。) Tj
T*
() Tj
T*
(系统中可能的每种类型的异常都分配了一个唯一的非负整数的异常号（exception number）。其中一些号码是由处理器的设计者分配的，其他号码是由操作系统内核（操作系统常驻内存的) Tj
T*
(部分）的设计者分配的。前者的示例包括被零除、缺页、内存访问违例、断点以及算术运算溢出。后者的示例包括系统调用和来自外部 I/O 设备的信号。) Tj
T*
() Tj
T*
(在系统启动时（当计算机重启或者加电时），操作系统分配和初始化一张称为异常表的跳转表，使得表目 k 包含异常 k 的处理程序的地址。图 8-2 展示了异常表的格式。) Tj
T*
() Tj
T*
([Image: &#x56FE; 8-2 &#x5F02;&#x5E38;&#x8868;&#x3002;&#x5F02;&#x5E38;&#x8868;&#x662F;&#x4E) Tj
T*
(00;&#x5F20;&#x8DF3;&#x8F6C;&#x8868;&#xFF0C;&#x5176;&#x4E2D;&#x8868;&#x76EE; k) Tj
T*
(&#x5305;&#x542B;&#x5F02;&#x5E38; k) Tj
T*
(&#x7684;&#x5904;&#x7406;&#x7A0B;&#x5E8F;&#x4EE3;&#x7801;&#x7684;&#x5730;&#x5740;]) Tj
T*
() Tj
T*
(在运行时（当系统在执行某个程序时），处理器检测到发生了一个事件，并且确定了相应的异常号 k。随后，处理器触发异常，方法是执行间接过程调用，通过异常表的表目) Tj
T*
(k，转到相应的处理程序。图 8-3) Tj
T*
ET
endstream
endobj
429 0 obj
<< /Length 3773 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(展示了处理器如何使用异常表来形成适当的异常处理程序的地址。异常号是到异常表中的索引，异常表的起始地址放在一个叫做异常表基址寄存器（exception table base) Tj
T*
(register）的特殊 CPU 寄存器里。) Tj
T*
() Tj
T*
([Image: &#x56FE; 8-3 &#x751F;&#x6210;&#x5F02;&#x5E38;&#x5904;&#x7406;&#x7A0B;&#x5E8F;&#x76) Tj
T*
(84;&#x5730;&#x5740;&#x3002;&#x5F02;&#x5E38;&#x53F7;&#x662F;&#x5230;&#x5F02;&#x5E38;&#x8868) Tj
T*
(;&#x4E2D;&#x7684;&#x7D22;&#x5F15;]) Tj
T*
() Tj
T*
(异常类似于过程调用，但是有一些重要的不同之处：) Tj
T*
() Tj
T*
(* 过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条指令（如果事件不发生，将会在) Tj
T*
(当前指令后执行的指令）。) Tj
T*
(* 处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始执行被中断的程序会需要这些状态。比如，x86-64 系统会将包含当前条件码的 EFLAGS) Tj
T*
(寄存器和其他内容压入栈中。) Tj
T*
(* 如果控制从用户程序转移到内核，所有这些项目都被压到内核栈中，而不是压到用户栈中。) Tj
T*
(* 异常处理程序运行在内核模式下（见 8.2.4 节），这意味着它们对所有的系统资源都有完全的访问权限。) Tj
T*
() Tj
T*
(一旦硬件触发了异常，剩下的工作就是由异常处理程序在软件中完成。在处理程序处理完事件之后，它通过执行一条特殊的“从中断返回”指令，可选地返回到被中断的程序，该指令将适当的状态弹回到处) Tj
T*
(理器的控制和数据寄存器中，如果异常中断的是一个用户程序，就将状态恢复为用户模式（见 8.2.4 节），然后将控制返回给被中断的程序。) Tj
T*
() Tj
T*
(8.1.2 异常的类别) Tj
T*
() Tj
T*
() Tj
T*
(异常可以分为四类：中断（interrupt），陷阱（trap）、故障（fault）和终止（abort）。图 8-4 中的表对这些类别的属性做了小结。) Tj
T*
() Tj
T*
(| 类别 | 原因 | 异步/同步 | 返回行为 |) Tj
T*
(| :---: | :--- | :---: | :--- |) Tj
T*
(| 中断 | 来自 I/O 设备的信号 | 异步 | 总是返回到下一条指令 |) Tj
T*
(| 陷阱 | 有意的异常 | 同步 | 总是返回到下一条指令 |) Tj
T*
(| 故障 | 潜在可恢复的错误 | 同步 | 可能返回到当前指令 |) Tj
T*
(| 终止 | 不可恢复的错误 | 同步 | 不会返回 |) Tj
T*
() Tj
T*
(> 图 8-4 异常的类别。异步异常是由处理器外部的 I/O 设备中的事件产生的。同步异常是执行一条指令的直接产物) Tj
T*
() Tj
T*
(1. 中断) Tj
T*
() Tj
T*
() Tj
T*
(中断是异步发生的，是来自处理器外部的 I/O) Tj
T*
(设备的信号的结果。硬件中断不是由任何一条专门的指令造成的，从这个意义上来说它是异步的。硬件中断的异常处理程序常常称为中断处理程序（interrupt handler）。) Tj
T*
() Tj
T*
(图 8-5 概述了一个中断的处理。I/O) Tj
T*
(设备，例如网络适配器、磁盘控制器和定时器芯片，通过向处理器芯片上的一个引脚发信号，并将异常号放到系统总线上，来触发中断，这个异常号标识了引起中断的设备。) Tj
T*
() Tj
T*
([Image: &#x56FE; 8-5 &#x4E2D;&#x65AD;&#x5904;&#x7406;&#x3002;&#x4E2D;&#x65AD;&#x5904;&#x74) Tj
T*
(06;&#x7A0B;&#x5E8F;&#x5C06;&#x63A7;&#x5236;&#x8FD4;&#x56DE;&#x7ED9;&#x5E94;&#x7528;&#x7A0B) Tj
T*
(;&#x5E8F;&#x63A7;&#x5236;&#x6D41;&#x4E2D;&#x7684;&#x4E0B;&#x4E00;&#x6761;&#x6307;&#x4EE4;]) Tj
T*
() Tj
T*
ET
endstream
endobj
430 0 obj
<< /Length 4550 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(在当前指令完成执行之后，处理器注意到中断引脚的电压变高了，就从系统总线读取异常号，然后调用适当的中断处理程序。当处理程序返回时，它就将控制返回给下一条指令（也即如果没有发生中断，在) Tj
T*
(控制流中会在当前指令之后的那条指令）。结果是程序继续执行，就好像没有发生过中断一样。) Tj
T*
() Tj
T*
(剩下的异常类型（陷阱、故障和终止）是同步发生的，是执行当前指令的结果。我们把这类指令叫做故障指令（faulting instruction）。) Tj
T*
() Tj
T*
(2. 陷阱和系统调用) Tj
T*
() Tj
T*
() Tj
T*
(陷阱是有意的异常，是执行一条指令的结果。就像中断处理程序一样，陷阱处理程序将控制返回到下一条指令。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。) Tj
T*
() Tj
T*
(用户程序经常需要向内核请求服务，比如读一个文件（read）、创建一个新的进程（fork），加载一个新的程序（execve），或者终止当前进程（exit）。为了允许对这些内核服务的受) Tj
T*
(控的访问，处理器提供了一条特殊的 “syscall n” 指令，当用户程序想要请求服务 n 时，可以执行这条指令。执行 syscall) Tj
T*
(指令会导致一个到异常处理程序的陷阱，这个处理程序解析参数，并调用适当的内核程序。图 8-6 概述了一个系统调用的处理。) Tj
T*
() Tj
T*
([Image: &#x56FE; 8-6 &#x9677;&#x9631;&#x5904;&#x7406;&#x3002;&#x9677;&#x9631;&#x5904;&#x74) Tj
T*
(06;&#x7A0B;&#x5E8F;&#x5C06;&#x63A7;&#x5236;&#x8FD4;&#x56DE;&#x7ED9;&#x5E94;&#x7528;&#x7A0B) Tj
T*
(;&#x5E8F;&#x63A7;&#x5236;&#x6D41;&#x4E2D;&#x7684;&#x4E0B;&#x4E00;&#x6761;&#x6307;&#x4EE4;]) Tj
T*
() Tj
T*
(从程序员的角度来看，系统调用和普通的函数调用是一样的。然而，它们的实现非常不同。普通的函数运行在用户模式中，用户模式限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的) Tj
T*
(栈。系统调用运行在内核模式中，内核模式允许系统调用执行特权指令，并访问定义在内核中的栈。8.2.4 节会更详细地讨论用户模式和内核模式。) Tj
T*
() Tj
T*
(3. 故障) Tj
T*
() Tj
T*
() Tj
T*
(故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否) Tj
T*
(则，处理程序返回到内核中的 abort 例程，abort 例程会终止引起故障的应用程序。图 8-7 概述了一个故障的处理。) Tj
T*
() Tj
T*
([Image: &#x56FE; 8-7 &#x6545;&#x969C;&#x5904;&#x7406;&#x3002;&#x6839;&#x636E;&#x6545;&#x96) Tj
T*
(9C;&#x662F;&#x5426;&#x80FD;&#x591F;&#x88AB;&#x4FEE;&#x590D;&#xFF0C;&#x6545;&#x969C;&#x5904) Tj
T*
(;&#x7406;&#x7A0B;&#x5E8F;&#x8981;&#x4E48;&#x91CD;&#x65B0;&#x6267;&#x884C;&#x5F15;&#x8D77;&) Tj
T*
(#x6545;&#x969C;&#x7684;&#x6307;&#x4EE4;&#xFF0C;&#x8981;&#x4E48;&#x7EC8;&#x6B62;]) Tj
T*
() Tj
T*
(一个经典的故障示例是缺页异常，当指令引用一个虚拟地址，而与该地址相对应的物理页面不在内存中，因此必须从磁盘中取出时，就会发生故障。就像我们将在第 9) Tj
T*
(章中看到的那样，一个页面就是虚拟内存的一个连续的块（典型的是) Tj
T*
(4KB）。缺页处理程序从磁盘加载适当的页面，然后将控制返回给引起故障的指令。当指令再次执行时，相应的物理页面已经驻留在内存中了，指令就可以没有故障地运行完成了。) Tj
T*
() Tj
T*
(4. 终止) Tj
T*
() Tj
T*
() Tj
T*
(终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如 DRAM 或者 SRAM 位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。如图 8-8) Tj
T*
(所示，处理程序将控制返回给一个 abort 例程，该例程会终止这个应用程序。) Tj
T*
() Tj
T*
([Image: &#x56FE; 8-8 &#x7EC8;&#x6B62;&#x5904;&#x7406;&#x3002;&#x7EC8;&#x6B62;&#x5904;&#x74) Tj
T*
(06;&#x7A0B;&#x5E8F;&#x5C06;&#x63A7;&#x5236;&#x4F20;&#x9012;&#x7ED9;&#x4E00;&#x4E2A;&#x5185) Tj
T*
(;&#x6838; abort &#x4F8B;&#x7A0B;&#xFF0C;&#x8BE5;&#x4F8B;&#x7A0B;&#x4F1A;&#x7EC8;&#x6B62;&#) Tj
T*
(x8FD9;&#x4E2A;&#x5E94;&#x7528;&#x7A0B;&#x5E8F;]) Tj
T*
ET
endstream
endobj
431 0 obj
<< /Length 3256 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(8.1.3 Linux/x86-64 系统中的异常) Tj
T*
() Tj
T*
() Tj
T*
(为了使描述更具体，让我们来看看为 x86-64 系统定义的一些异常。有高达 256 种不同的异常类型【50】。0 ∼ 31 的号码对应的是由 Intel) Tj
T*
(架构师定义的异常，因此对任何 x86-64 系统都是一样的。32 ∼ 255 的号码对应的是操作系统定义的中断和陷阱。图 8-9 展示了一些示例。) Tj
T*
() Tj
T*
(| 异常号 | 描述 | 异常类别 |) Tj
T*
(| :--- | :--- | :--- |) Tj
T*
(| 0 | 除法错误 | 故障 |) Tj
T*
(| 13 | 一般保护故障 | 故障 |) Tj
T*
(| 14 | 缺页 | 故障 |) Tj
T*
(| 18 | 机器检查 | 终止 |) Tj
T*
(| 32 ~ 255 | 操作系统定义的异常 | 中断或陷阱 |) Tj
T*
() Tj
T*
(> 图 8-9 x86-64 系统中的异常示例) Tj
T*
() Tj
T*
(1. Linux/x86-64 故障和终止) Tj
T*
() Tj
T*
() Tj
T*
(除法错误。当应用试图除以零时，或者当一个除法指令的结果对于目标操作数来说太大了的时候，就会发生除法错误（异常 0）。Unix) Tj
T*
(不会试图从除法错误中恢复，而是选择终止程序。Linuxshell 通常会把除法错误报告为“浮点异常（Floating exception）”。) Tj
T*
() Tj
T*
(一般保护故障。许多原因都会导致不为人知的一般保护故障（异常 13），通常是因为一个程序引用了一个未定义的虚拟内存区域，或者因为程序试图写一个只读的文本段。Linux) Tj
T*
(不会尝试恢复这类故障。Linux shell 通常会把这种一般保护故障报告为“段故障（Segmentation fault）”。) Tj
T*
() Tj
T*
(缺页（异常 14）是会重新执行产生故障的指令的一个异常示例。处理程序将适当的磁盘上虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条产生故障的指令。我们将在第 9) Tj
T*
(章中看到缺页是如何工作的细节。) Tj
T*
() Tj
T*
(机器检查。机器检查（异常 18）是在导致故障的指令执行中检测到致命的硬件错误时发生的。机器检查处理程序从不返回控制给应用程序。) Tj
T*
() Tj
T*
(2. Linux/86-64 系统调用) Tj
T*
() Tj
T*
() Tj
T*
(Linux 提供几百种系统调用，当应用程序想要请求内核服务时可以使用，包括读文件、写文件或是创建一个新进程。图 8-10 给出了一些常见的 Linux) Tj
T*
(系统调用。每个系统调用都有一个唯一的整数号，对应于一个到内核中跳转表的偏移量。（注意：这个跳转表和异常表不一样。）) Tj
T*
() Tj
T*
(| 编号 | 名字 | 描述 | 编号 | 名字 | 描述 |) Tj
T*
(| ---: | :---: | :--- | :---: | :---: | :--- |) Tj
T*
(| 0 | read | 读文件 | 33 | pause | 挂起进程直到信号到达 |) Tj
T*
(| 1 | write | 写文件 | 37 | alarm | 调度告警信号的传送 |) Tj
T*
(| 2 | open | 打开文件 | 39 | getpid | 获得进程ID |) Tj
T*
(| 3 | close | 关闭文件 | 57 | fork | 创建进程 |) Tj
T*
(| 4 | stat | 获得文件信息 | 59 | execve | 执行一个程序 |) Tj
T*
(| 9 | mmap | 将内存页映射到文件 | 60 | \\_exit | 终止进程 |) Tj
T*
(| 12 | brk | 重置堆顶 | 61 | wait4 | 等待一个进程终止 |) Tj
T*
ET
endstream
endobj
432 0 obj
<< /Length 3204 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(| 32 | dup2 | 复制文件描述符 | 62 | kill | 发送信号到一个进程 |) Tj
T*
() Tj
T*
(> 图 8-10 Linux x86-64 系统中常用的系统调用示例) Tj
T*
() Tj
T*
(C 程序用 syscall 函数可以直接调用任何系统调用。然而，实际中几乎没必要这么做。对于大多数系统调用，标准 C 库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适) Tj
T*
(当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。在本书中，我们将系统调用和与它们相关联的包装函数都称为系统级函数，这两个术语可以互换地使用。) Tj
T*
() Tj
T*
(在 X86-64 系统上，系统调用是通过一条称为 syscall 的陷阱指令来提供的。研究程序能够如何使用这条指令来直接调用 Linux 系统调用是很有趣的。所有到 Linux) Tj
T*
(系统调用的参数都是通过通用寄存器而不是栈传递的。按照惯例，寄存器 ％rax 包含系统调用号，寄存器 %rdi、%rsi、%rdx、%r10、%r8  和 ％r9 包含最多 6) Tj
T*
(个参数。第一个参数在  ％rdi 中，第二个在 ％rsi 中，以此类推。从系统调用返回时，寄存器 %rcx 和 ％r11 都会被破坏，％rax 包含返回值。-4095 到 -1) Tj
T*
(之间的负数返回值表明发生了错误，对应于负的 errno。) Tj
T*
() Tj
T*
(例如，考虑大家熟悉的 hello 程序的下面这个版本，用系统级函数 write（见 10.4 节）来写，而不是用 printf：) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        write\(1, "hello, world\\n", 13\);) Tj
T*
(        _exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(write 函数的第一个参数将输出发送到 stdout。第二个参数是要写的字节序列，而第三个参数是要写的字节数。) Tj
T*
() Tj
T*
(图 8-11 给出的是 hello 程序的汇编语言版本，直接使用 syscall 指令来调用 write 和 exit 系统调用。第 9 ∼ 13 行调用 write) Tj
T*
(函数。首先，第 9 行将系统调用 write 的编号存放在 ％rax 中，第 10 ∼ 12 行设置参数列表。然后第 13 行使用 syscall 指令来调用系统调用。类似地，第) Tj
T*
(14 ∼ 16 行调用 \\_exit 系统调用。) Tj
T*
() Tj
T*
(    .section .data) Tj
T*
(    string:) Tj
T*
(      .ascii "hello, world\\n") Tj
T*
(    string_end:) Tj
T*
(      .equ len, string_end - string) Tj
T*
(    .section .text) Tj
T*
(    .globl main) Tj
T*
(    main:) Tj
T*
(      # First, call write\(1, "hello, world\\n", 13\)) Tj
T*
(      movq $1, %rax                 # write is system call 1) Tj
T*
(      movq $1, %rdi                 # Arg1: stdout has descriptor 1) Tj
T*
(      movq $string, %rsi            # Arg2: hello world string) Tj
T*
(      movq $len, %rdx               # Arg3: string length) Tj
T*
(      syscall                       # Make the system call) Tj
T*
() Tj
T*
(      # Next, call _exit\(0\)) Tj
T*
(      movq $60, %rax                # _exit is system call 60) Tj
T*
(      movq $0, %rdi                 # Arg1: exit status is 0) Tj
T*
(      syscall                       # Make the system call) Tj
T*
() Tj
T*
ET
endstream
endobj
433 0 obj
<< /Length 4597 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(> 图 8-11 直接用 Linux 系统调用来实现 hello 程序) Tj
T*
() Tj
T*
(旁注 - 关于术语的注释) Tj
T*
() Tj
T*
() Tj
T*
(各种异常类型的术语根据系统的不同而有所不同。处理器 ISA 规范通常会区分异步“中断”和同步“异常”，但是并没有提供描述这些非常相似的概念的概括性的术语。为了避免不断地提到“异常和) Tj
T*
(中断”以及“异常或者中断”，我们用单词“异常”作为通用的术语，而且只有在必要时才区别异步异常（中断）和同步异常（陷阱、故障和终止）。正如我们提到过的，对于每个系统而言，基本的概念都) Tj
T*
(是相同的，但是你应该意识到一些制造厂商的手册会用“异常" 仅仅表示同步事件引起的控制流的改变。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(8.2 进程) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(8.2 进程) Tj
T*
() Tj
T*
() Tj
T*
(异常是允许操作系统内核提供进程（process）概念的基本构造块，进程是计算机科学中最深刻、最成功的概念之一。) Tj
T*
() Tj
T*
(在现代系统上运行一个程序时，我们会得到一个假象，就好像我们的程序是系统中当前运行的唯一的程序一样。我们的程序好像是独占地使用处理器和内存。处理器就好像是无间断地一条接一条地执行我们) Tj
T*
(程序中的指令。最后，我们程序中的代码和数据好像是系统内存中唯一的对象。这些假象都是通过进程的概念提供给我们的。) Tj
T*
() Tj
T*
(进程的经典定义就是一个执行中程序的实例。系统中的每个程序都运行在某个进程的上下文（context）中。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在内存中的程序的代码和) Tj
T*
(数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。) Tj
T*
() Tj
T*
(每次用户通过向 shell 输入一个可执行目标文件的名字，运行程序时，shell) Tj
T*
(就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。) Tj
T*
() Tj
T*
(关于操作系统如何实现进程的细节的讨论超出了本书的范围。反之，我们将关注进程提供给应用程序的关键抽象：) Tj
T*
() Tj
T*
(* 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。) Tj
T*
(* 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。让我们更深入地看看这些抽象。) Tj
T*
() Tj
T*
(8.2.1 逻辑控制流) Tj
T*
() Tj
T*
() Tj
T*
(即使在系统中通常有许多其他程序在运行，像它在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器（PC）的值，这些值唯一地对应于包含在程序的可执行目标文件中的) Tj
T*
(指令，或是包含在运行时动态链接到程序的共享对象中的指令。这个 PC 值的序列叫做逻辑控制流，或者简称逻辑流。) Tj
T*
() Tj
T*
(考虑一个运行着三个进程的系统，如图 8-12 所示。处理器的一个物理控制流被分成了三个逻辑流，每个进程一个。图 8) Tj
T*
(一每个竖直的条表示一个进程的逻辑流的一部分。在这个例子中，三个逻辑流的执行是交错的。进程 A 运行了一会儿，然后是进程 B 开始运行到完成。然后，进程 C 运行了一会儿，进程 A) Tj
T*
(接着运行直到完成。最后，进程 C 可以运行到结束了。) Tj
T*
() Tj
T*
(图 8-12 的关键点在于进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被抢占（preempted）（暂时挂起），然后轮到其他进程。对于一个运行在这些进程之一的上下文中的) Tj
T*
(程序，它看上去就像是在独占地使用处理器。唯一的反面例证是，如果我们精确地测量每条指令使用的时间，会发现在程序中一些指令的执行之间，CPU) Tj
T*
(好像会周期性地停顿。然而，每次处理器停顿，它随后会继续执行我们的程序，并不改变程序内存位置或寄存器的内容。) Tj
T*
ET
endstream
endobj
434 0 obj
<< /Length 2765 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 8-12 逻辑控制流。进程为每个程序提供了一种假象，好像程序在独占地使用处理器。每个竖直的条表示一个进程的逻辑控制流的一部分) Tj
T*
() Tj
T*
(8.2.2 并发流) Tj
T*
() Tj
T*
() Tj
T*
(计算机系统中逻辑流有许多不同的形式。异常处理程序、进程、信号处理程序、线程和 Java 进程都是逻辑流的例子。) Tj
T*
() Tj
T*
(一个逻辑流的执行在时间上与另一个流重叠，称为并发流（concurrent flow），这两个流被称为并发地运行。更准确地说，流 X 和 Y 互相并发，当且仅当 X 在 Y) Tj
T*
(开始之后和 Y 结束之前开始，或者 Y 在 X 开始之后和 X 结束之前开始。例如，图 8-12 中，进程 A 和 B 并发地运行，A 和 C 也一样。另一方面，B 和 C) Tj
T*
(没有并发地运行，因为 B 的最后一条指令在 C 的第一条指令之前执行。) Tj
T*
() Tj
T*
(多个流并发地执行的一般现象被称为并发（concurrency）。一个进程和其他进程轮流运行的概念称为多任务（multitasking）o) Tj
T*
(一个进程执行它的控制流的一部分的每一时间段叫做时间片（time slice）。因此，多任务也叫做时间分片（timeslicing）。例如，图 8-12 中，进程 A) Tj
T*
(的流由两个时间片组成。) Tj
T*
() Tj
T*
(注意，并发流的思想与流运行的处理器核数或者计算机数无关。如果两个流在时间上重叠，那么它们就是并发的，即使它们是运行在同一个处理器上。不过，有时我们会发现确认并行流是很有帮助的，它是) Tj
T*
(并发流的一个真子集。如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为并行流（parallel flow），它们并行地运行（running in) Tj
T*
(parallel），且并行地执行（parallel execution）。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(练习题 8.1) Tj
T*
() Tj
T*
() Tj
T*
(考虑三个具有下述起始和结束时间的进程：) Tj
T*
() Tj
T*
(| 进程 | 起始时间 | 结束时间 |) Tj
T*
(| :---: | :---: | :---: |) Tj
T*
(| A | 0 | 2 |) Tj
T*
(| B | 1 | 4 |) Tj
T*
(| C | 3 | 5 |) Tj
T*
() Tj
T*
(对于每对进程，指出它们是否是并发地运行：) Tj
T*
() Tj
T*
(| 进程对 | 并发的？ |) Tj
T*
(| :---: | :---: |) Tj
T*
(| AB |  |) Tj
T*
(| AC |  |) Tj
T*
(| BC |  |) Tj
T*
() Tj
T*
(进程 A 和 B 是互相并发的，就像 B 和 C 一样，因为它们各自的执行是重叠的，也就是一个进程在另一个进程结束前开始。进程 A 和 C 不是并发的，因为它们的执行没有重叠；A) Tj
T*
(在 C 开始之前就结束了。) Tj
T*
() Tj
T*
ET
endstream
endobj
435 0 obj
<< /Length 5382 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(8.2.3 私有地址空间) Tj
T*
() Tj
T*
() Tj
T*
(进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。在一台 n 位地址的机器上，地址空间是$$2^n$$个可能地址的集合，0，1，⋯，$$\\small 2^n -1$$) Tj
T*
(。进程为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。) Tj
T*
() Tj
T*
(尽管和每个私有地址空间相关联的内存的内容一般是不同的，但是每个这样的空间都有相同的通用结构。比如，图 8-13 展示了一个 x86-64 Linux 进程的地址空间的组织结构。) Tj
T*
() Tj
T*
([Image: &#x56FE; 8-13 &#x8FDB;&#x7A0B;&#x5730;&#x5740;&#x7A7A;&#x95F4;]) Tj
T*
() Tj
T*
(地址空间底部是保留给用户程序的，包括通常的代码、数据、堆和栈段。代码段总是从地址 0x400000) Tj
T*
(开始。地址空间顶部保留给内核（操作系统常驻内存的部分）。地址空间的这个部分包含内核在代表进程执行指令时（比如当应用程序执行系统调用时）使用的代码、数据和栈。) Tj
T*
() Tj
T*
(8.2.4 用户模式和内核模式) Tj
T*
() Tj
T*
() Tj
T*
(为了使操作系统内核提供一个无懈可击的进程抽象，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。) Tj
T*
() Tj
T*
(处理器通常是用某个控制寄存器中的一个模式位（mode bit）来提供这种功能的，该寄存器描述了进程当前享有的特权。当设置了模式位时，进程就运行在内核模式中（有时叫做超级用户模式）。) Tj
T*
(一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。) Tj
T*
() Tj
T*
(没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令（privileged instruction），比如停止处理器、改变模式位，或者发起一个 I/O) Tj
T*
(操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。) Tj
T*
() Tj
T*
(运行应用程序代码的进程初始时是在用户模式中的。进程从用户模式变为内核模式的唯一方法是通过诸如中断、故障或者陷入系统调用这样的异常。当异常发生时，控制传递到异常处理程序，处理器将模式) Tj
T*
(从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核模式改回到用户模式。) Tj
T*
() Tj
T*
(Linux 提供了一种聪明的机制，叫做 /proc 文件系统，它允许用户模式进程访问内核数据结构的内容。/proc) Tj
T*
(文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构。比如，你可以使用 / proc 文件系统找出一般的系统属性，比如 CPU) Tj
T*
(类型（/proc/cpuinfo），或者某个特殊的进程使用的内存段（/proc/&lt;process-id&gt;/maps）。2.6 版本的 Linux 内核引入 /sys) Tj
T*
(文件系统，它输岀关于系统总线和设备的额外的低层信息。) Tj
T*
() Tj
T*
(8.2.5 上下文切换) Tj
T*
() Tj
T*
() Tj
T*
(操作系统内核使用一种称为上下文切换（context switch）的较高层形式的异常控制流来实现多任务。上下文切换机制是建立在 8.1 节中已经讨论过的那些较低层异常机制之上的。) Tj
T*
() Tj
T*
(内核为每个进程维持一个上下文（context）。上下文就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、) Tj
T*
(状态寄存器、内核栈和各种内核数据结构，比如描述地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。) Tj
T*
() Tj
T*
(在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这种决策就叫做调度（scheduling），是由内核中称为调度器（scheduler）的代码处理的) Tj
T*
(。当内核选择一个新的进程运行时，我们说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程，上下文切换) Tj
T*
(1）保存当前进程的上下文，2）恢复某个先前被抢占的进程被保存的上下文，3）将控制传递给这个新恢复的进程。) Tj
T*
() Tj
T*
(当内核代表用户执行系统调用时，可能会发生上下文切换。如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程。比如，如果一个 read) Tj
T*
(系统调用需要访问磁盘，内核可以选择执行上下文切换，运行另外一个进程，而不是等待数据从磁盘到达。另一个示例是 sleep) Tj
T*
ET
endstream
endobj
436 0 obj
<< /Length 3524 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(系统调用，它显式地请求让调用进程休眠。一般而言，即使系统调用没有阻塞，内核也可以决定执行上下文切换，而不是将控制返回给调用进程。) Tj
T*
() Tj
T*
(中断也可能引发上下文切换。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每 1 毫秒或每 10) Tj
T*
(毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。) Tj
T*
() Tj
T*
(图 8-14 展示了一对进程 A 和 B 之间上下文切换的示例。在这个例子中，进程 A 初始运行在用户模式中，直到它通过执行系统调用 read) Tj
T*
(陷入到内核。内核中的陷阱处理程序请求来自磁盘控制器的 DMA 传输，并且安排在磁盘控制器完成从磁盘到内存的数据传输后，磁盘中断处理器。) Tj
T*
() Tj
T*
([Image: &#x56FE; 8-14) Tj
T*
(&#x8FDB;&#x7A0B;&#x4E0A;&#x4E0B;&#x6587;&#x5207;&#x6362;&#x7684;&#x5256;&#x6790;]) Tj
T*
() Tj
T*
(磁盘取数据要用一段相对较长的时间（数量级为几十毫秒），所以内核执行从进程 A 到进程 B 的上下文切换，而不是在这个间歇时间内等待，什么都不做。注意在切换之前，内核正代表进程 A) Tj
T*
(在用户模式下执行指令（即没有单独的内核进程）。在切换的第一部分中，内核代表进程 A 在内核模式下执行指令。然后在某一时刻，它开始代表进程) Tj
T*
(B（仍然是内核模式下）执行指令。在切换之后，内核代表进程 B 在用户模式下执行指令。) Tj
T*
() Tj
T*
(随后，进程 B 在用户模式下运行一会儿，直到磁盘发出一个中断信号，表示数据已经从磁盘传送到了内存。内核判定进程 B 已经运行了足够长的时间，就执行一个从进程 B 到进程 A) Tj
T*
(的上下文切换，将控制返回给进程 A 中紧随在系统调用 read 之后的那条指令。进程 A 继续运行，直到下一次异常发生，依此类推。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(8.3 系统调用错误处理) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(8.3 系统调用错误处理) Tj
T*
() Tj
T*
() Tj
T*
(当 Unix 系统级函数遇到错误时，它们通常会返回 —1，并设置全局整数变量 errno) Tj
T*
(来表示什么出错了。程序员应该总是检査错误，但是不幸的是，许多人都忽略了错误检查，因为它使代码变得臃肿，而且难以读懂。比如，下面是我们调用 Unix fork 函数时会如何检査错误：) Tj
T*
() Tj
T*
(    if \(\(pid = fork\(\)\) < 0\) {) Tj
T*
(        fprintf\(stderr, "fork error: %s\\n", strerror\(errno\)\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(strerror 函数返回一个文本串，描述了和某个 errno 值相关联的错误。通过定义下面的错误报告函数，我们能够在某种程度上简化这个代码：) Tj
T*
() Tj
T*
(    void unix_error\(char *msg\) /* Unix-style error */) Tj
T*
(    {) Tj
T*
(        fprintf\(stderr, "%s: %s\\n", msg, strerror\(errno\)\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(给定这个函数，我们对 fork 的调用从 4 行缩减到 2 行：) Tj
T*
() Tj
T*
(    if \(\(pid = fork\(\)\) < 0\)) Tj
T*
(        unix_error\("fork error"\);) Tj
T*
ET
endstream
endobj
437 0 obj
<< /Length 2418 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(通过使用错误处理包装函数，我们可以更进一步地简化代码，Stevens 在【110】中首先提出了这种方法。对于一个给定的基本函数 foo，我们定义一个具有相同参数的包装函数) Tj
T*
(Foo，但是第一个字母大写了。包装函数调用基本函数，检査错误，如果有任何问题就终止。比如，下面是 fork 函数的错误处理包装函数：) Tj
T*
() Tj
T*
(    pid_t Fork\(void\)) Tj
T*
(    {) Tj
T*
(        pid_t pid;) Tj
T*
() Tj
T*
(        if \(\(pid = fork\(\)\) < 0\)) Tj
T*
(            unix_error\("Fork error"\);) Tj
T*
(        return pid;) Tj
T*
(    }) Tj
T*
() Tj
T*
(给定这个包装函数，我们对 fork 的调用就缩减为 1 行：) Tj
T*
() Tj
T*
(    pid = Fork\(\);) Tj
T*
() Tj
T*
(我们将在本书剩余的部分中都使用错误处理包装函数。它们能够保持代码示例简洁，而又不会给你错误的假象，认为允许忽略错误检査。注意，当在本书中谈到系统级函数时，我们总是用它们的小写字母的) Tj
T*
(基本名字来引用它们，而不是用它们大写的包装函数名来引用。) Tj
T*
() Tj
T*
(关于 Unix 错误处理以及本书中使用的错误处理包装函数的讨论，请参见附录 A。包装函数定义在一个叫做 csapp.c 的文件中，它们的原型定义在一个叫做 csapp.h) Tj
T*
(的头文件中；可以从 CS：APP 网站上在线地得到这些代码。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(8.4 进程控制) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(8.4 进程控制) Tj
T*
() Tj
T*
() Tj
T*
(Unix 提供了大量从 C 程序中操作进程的系统调用。这一节将描述这些重要的函数，并举例说明如何使用它们。) Tj
T*
() Tj
T*
(8.4.1 获取进程 ID) Tj
T*
() Tj
T*
() Tj
T*
(每个进程都有一个唯一的正数（非零）进程 ID（PID）。getpid 函数返回调用进程的 PID。getppid 函数返回它的父进程的 PID（创建调用进程的进程）。) Tj
T*
() Tj
T*
(    #include <sys/types.h>) Tj
T*
(    #include <unistd.h>) Tj
T*
() Tj
T*
(    pid_t getpid\(void\);) Tj
T*
(    pid_t getppid\(void\);) Tj
T*
() Tj
T*
(    // 返回：调用者或其父进程的 PID。) Tj
T*
() Tj
T*
ET
endstream
endobj
438 0 obj
<< /Length 3033 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(getpid 和 getppid 函数返回一个类型为 pid\\_t 的整数值，在 Linux 系统上它在 types.h 中被定义为 int。) Tj
T*
() Tj
T*
(8.4.2 创建和终止进程) Tj
T*
() Tj
T*
() Tj
T*
(从程序员的角度，我们可以认为进程总是处于下面三种状态之一：) Tj
T*
() Tj
T*
( \\\\运行。\\\\*进程要么在 CPU 上 执行，要么在等待被执行且最终会被内核调度。) Tj
T*
( \\\\停止。\\\\*进程的执行被挂起（suspended），且不会被调度。当收到 SIGSTOP、SIGTSTP、SIGTTIN 或者 SIGTTOU) Tj
T*
( 信号时，进程就停止，并且保持停止直到它收到一个 SIGCONT 信号，在这个时刻，进程再次开始运行。（信号是一种软件中断的形式，将在 8.5 节中详细描述。）) Tj
T*
( \\\\终止。\\\\*进程永远地停止了。进程会因为三种原因终止：) Tj
T*
(  * 1）收到一个信号，该信号的默认行为是终止进程；) Tj
T*
(  * 2）从主程序返回；) Tj
T*
(  * 3）调用 exit 函数。) Tj
T*
() Tj
T*
(    #include <stdlib.h>) Tj
T*
() Tj
T*
(    void exit\(int status\);) Tj
T*
() Tj
T*
(    // 该函数不返回。) Tj
T*
() Tj
T*
(exit 函数以 status 退出状态来终止进程（另一种设置退出状态的方法是从主程序中返回一个整数值）。) Tj
T*
() Tj
T*
(父进程通过调用 fork 函数创建一个新的运行的子进程。) Tj
T*
() Tj
T*
(    #include <sys/types.h>) Tj
T*
(    #include <unistd.h>) Tj
T*
() Tj
T*
(    pid_t fork\(void\);) Tj
T*
() Tj
T*
(    // 返回：子进程返回 0，父进程返回子进程的 PID，如果出错，则为 -1。) Tj
T*
() Tj
T*
(新创建的子进程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描) Tj
T*
(述符相同的副本，这就意味着当父进程调用 fork 时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的 PID。) Tj
T*
() Tj
T*
(fork 函数是有趣的（也常常令人迷惑），因为它只被调用一次，却会返回两次：一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork 返回子进程的) Tj
T*
(PID。在子进程中，fork 返回 0。因为子进程的 PID 总是为非零，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。) Tj
T*
() Tj
T*
(图 8-15 展示了一个使用 fork 创建子进程的父进程的示例。当 fork 调用在第 6 行返回时，在父进程和子进程中 x 的值都为 1。子进程在第 8 行加一并输出它的 x) Tj
T*
(的副本。相似地，父进程在第 13 行减一并输出它的 x 的副本。) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        pid_t pid;) Tj
T*
(        int x = 1;) Tj
T*
() Tj
T*
ET
endstream
endobj
439 0 obj
<< /Length 4565 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        pid = Fork\(\);) Tj
T*
(        if \(pid == 0\) { /* Child */) Tj
T*
(            printf\("child : x=%d\\n", ++x\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Parent */) Tj
T*
(        printf\("parent: x=%d\\n", --x\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-15 使用 fork 创建一个新进程) Tj
T*
() Tj
T*
(当在 Unix 系统上运行这个程序时，我们得到下面的结果：) Tj
T*
() Tj
T*
(    linux> ./fork) Tj
T*
(    parent：x=0) Tj
T*
(    child ：x=2) Tj
T*
() Tj
T*
(这个简单的例子有一些微妙的方面。) Tj
T*
() Tj
T*
(* 调用一次，返回两次。fork) Tj
T*
(函数被父进程调用一次，但是却返回两次。一次是返回到父进程，一次是返回到新创建的子进程。对于只创建一个子进程的程序来说，这还是相当简单直接的。但是具有多个 fork) Tj
T*
(实例的程序可能就会令人迷惑，需要仔细地推敲了。) Tj
T*
(* 并发执行。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。在我们的系统上运行这个程序时，父进程先完成它的 printf) Tj
T*
(语句，然后是子进程。然而，在另一个系统上可能正好相反。一般而言，作为程序员，我们决不能对不同进程中指令的交替执行做任何假设。) Tj
T*
(* 相同但是独立的地址空间。如果能够在 fork 函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、) Tj
T*
(相同的堆、相同的全局变量值，以及相同的代码。因此，在我们的示例程序中，当 fork 函数在第 6 行返回时，本地变量 x 在父进程和子进程中都为) Tj
T*
(1。然而，因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。后面，父进程和子进程对 x) Tj
T*
(所做的任何改变都是独立的，不会反映在另一个进程的内存中。这就是为什么当父进程和子进程调用它们各自的 printf 语句时，它们中的变量 x 会有不同的值。) Tj
T*
(* 共享文件。当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用 fork 时，stdout) Tj
T*
(文件是打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。) Tj
T*
() Tj
T*
(如果你是第一次学习 fork 函数，画进程图通常会有所帮助，进程图是刻画程序语句的偏序的一种简单的前趋图。每个顶点 a 对应于一条程序语句的执行。有向边 a → b 表示语句 a) Tj
T*
(发生在语句 b 之前。边上可以标记出一些信息，例如一个变量的当前值。对应于 printf 语句的顶点可以标记上 printf 的输出。每张图从一个顶点开始，对应于调用 main) Tj
T*
(的父进程。这个顶点没有入边，并且只有一个出边。每个进程的顶点序列结束于一个对应于 exit 调用的顶点。这个顶点只有一条入边，没有出边。例如，图 8-16 展示了图 8-15) Tj
T*
(中示例程序的进程图。初始时，父进程将变量 x 设置为 1。父进程调用 fork，创建一个子进程，它在自己的私有地址空间中与父进程并发执行。) Tj
T*
() Tj
T*
([Image: 图 8-16   图 8-15 中示例程序的进程图]) Tj
T*
() Tj
T*
(对于运行在单处理器上的程序，对应进程图中所有顶点的拓扑排序（topological sort）表示程序中语句的一个可行的全序排列。下面是一个理解拓扑排序概念的简单方法：给定进程图中) Tj
T*
(顶点的一个排列，把顶点序列从左到右写成一行，然后画出每条有向边。排列是一个拓扑排序，当且仅当画出的每条边的方向都是从左往右的。因此，在图 8-15 的示例程序中，父进程和子进程的) Tj
T*
(printf 语句可以以任意先后顺序执行，因为每种顺序都对应于图顶点的某种拓扑排序。) Tj
T*
() Tj
T*
(进程图特别有助于理解带有嵌套 fork 调用的程序。例如，图 8-17 中的程序源码中两次调用了 fork。对应的进程图可帮助我们看清这个程序运行了四个进程，每个都调用了—次) Tj
T*
(printf，这些 printf 可以以任意顺序执行。) Tj
T*
ET
endstream
endobj
440 0 obj
<< /Length 1956 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
([Image: 图 8-17 嵌套 fork 的进程图]) Tj
T*
() Tj
T*
(练习题 8.2) Tj
T*
() Tj
T*
() Tj
T*
(考虑下面的程序：) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int x = 1;) Tj
T*
() Tj
T*
(        if \(Fork\(\) == 0\)) Tj
T*
(            printf\("p1: x=%d\\n", ++x\);) Tj
T*
(        printf\("p2: x=%d\\n", --x\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(A. 子进程的输出是什么？) Tj
T*
() Tj
T*
(B. 父进程的输出是什么？) Tj
T*
() Tj
T*
(在图 8-15 的示例程序中，父子进程执行无关的指令集合。然而，在这个程序中，父子进程执行的指令集合是相关的，这是有可能的，因为父子进程有相同的代码段。这会是一个概念上的障碍，所以) Tj
T*
(请确认你理解了本题的答案。图 8-47 给出了进程图。) Tj
T*
() Tj
T*
([Image: 图 8-47 练习题 8.2 的进程图]) Tj
T*
() Tj
T*
(A. 这里的关键点是子进程执行了两个 printf 语句。在 fork 返回之后，它执行第 6 行的 printf. 然后它从 if 语句中出来，执行第 7 行的 printf) Tj
T*
(语句。下面是子进程产生的输出：) Tj
T*
() Tj
T*
(    p1: x=2) Tj
T*
(    p2: x=1) Tj
T*
() Tj
T*
(B. 父进程只执行第 7 行的 printf：) Tj
T*
() Tj
T*
(    p2: x=0) Tj
T*
() Tj
T*
(8.4.3 回收子进程) Tj
T*
() Tj
T*
() Tj
T*
(当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除。相反，进程被保持在一种已终止的状态中，直到被它的父进程回收（reaped）。当父进程回收已终止的子进程时，内核将子进程) Tj
T*
(的退出状态传递给父进程，然后抛弃已终止的进程，从此时开始，该进程就不存在了。一个终止了但还未被回收的进程称为僵死进程（zombie）。) Tj
T*
() Tj
T*
(旁注 - 为什么已终止的子进程被称为僵死进程) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
441 0 obj
<< /Length 3579 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(在民间传说中，僵尸是活着的尸体，一种半生半死的实体。僵死进程已经终止了，而内核仍保留着它的某些状态直到父进程回收它为止，从这个意义上说它们是类似的。) Tj
T*
() Tj
T*
(如果一个父进程终止了，内核会安排 init 进程成为它的孤儿进程的养父。init 进程的 PID 为) Tj
T*
(1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。如果父进程没有回收它的僵死子进程就终止了，那么内核会安排 init 进程去回收它们。不过，长时间运行的程序，比如) Tj
T*
(shell 或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然消耗系统的内存资源。) Tj
T*
() Tj
T*
(一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止。) Tj
T*
() Tj
T*
(    #include <sys/types.h>) Tj
T*
(    #include <sys/wait.h>) Tj
T*
() Tj
T*
(    pid_t waitpid\(pid_t pid, int *statusp, int options\);) Tj
T*
() Tj
T*
(    // 返回：如果成功，则为子进程的 PID，如果 WNOHANG，则为 0，如果其他错误，则为 -1。) Tj
T*
() Tj
T*
(waitpid 函数有点复杂。默认情况下（当 options=0 时），waitpid 挂起调用进程的执行，直到它的等待集合（wait) Tj
T*
(set）中的一个子进程终止。如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么 waitpid 就立即返回。在这两种情况中，waitpid 返回导致 waitpid) Tj
T*
(返回的已终止子进程的 PID。此时，已终止的子进程已经被回收，内核会从系统中删除掉它的所有痕迹。) Tj
T*
() Tj
T*
(1. 判定等待集合的成员) Tj
T*
() Tj
T*
() Tj
T*
(等待集合的成员是由参数 pid 来确定的：) Tj
T*
() Tj
T*
(* 如果 Pid>0，那么等待集合就是一个单独的子进程，它的进程 ID 等于 pid。) Tj
T*
(* 如果 Pid=-1，那么等待集合就是由父进程所有的子进程组成的。) Tj
T*
() Tj
T*
(waitpid 函数还支持其他类型的等待集合，包括 Unix 进程组，对此我们将不做讨论。) Tj
T*
() Tj
T*
(2. 修改默认行为) Tj
T*
() Tj
T*
() Tj
T*
(可以通过将 options 设置为常量 WNOHANG，WUNTRACED 和 WCONTINUED 的各种组合来修改默认行为：) Tj
T*
() Tj
T*
(* WNOHANG：如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为) Tj
T*
(0）。默认的行为是挂起调用进程，直到有子进程终止。在等待子进程终止的同时，如果还想做些有用的工作，这个选项会有用。) Tj
T*
(* WUNTRACED：挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止，返回的 PID 为导致返回的已终止或被停止子进程的) Tj
T*
(PID。默认的行为是只返回已终止的子进程。当你想要检査已终止和被停止的子进程时，这个选项会有用。) Tj
T*
(* WCONTINUED：挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到 SIGCONT 信号重新开始执行。（8.5 节会解释这些信号。）) Tj
T*
() Tj
T*
(可以用或运算把这些选项组合起来。例如：) Tj
T*
() Tj
T*
(* WNOHANG | WUNTRACED：立即返回，如果等待集合中的子进程都没有被停止或终止，则返回值为 0；如果有一个停止或终止，则返回值为该子进程的 PID。) Tj
T*
() Tj
T*
(3. 检查已回收子进程的退出状态) Tj
T*
() Tj
T*
ET
endstream
endobj
442 0 obj
<< /Length 2789 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(如果 statusp 参数是非空的，那么 waitpid 就会在 status 中放上关于导致返回的子进程的状态信息，status 是 statusp 指向的值。wait.h) Tj
T*
(头文件定义了解释 status 参数的几个宏：) Tj
T*
() Tj
T*
(* WIFEXITED\(status\)：如果于进程通过调用 exit 或者一个返回（return）正常终止，就返回真。) Tj
T*
(* WEXITSTATUS\(status\)：返回一令正常终止的子进程的退出状态。只有在 WIFEXITED\(\) 返回为真时，才会定义这个状态。) Tj
T*
(* WIFSIGNALED\(status\)：如果子进程是因为一个未被捕获的信号终止的，. 那么就返回真。) Tj
T*
(* WTERMSIG\(status\)：返回导致子进程终止的信号的编号。只有在 WIFSIGNALED\(\) 返回为真时，才定义这个状态。) Tj
T*
(* WIFSTOPPED\(status\)：如果引起返回的子进程当前是停止的，那么就返回真。) Tj
T*
(* WSTOPSIG\(status\)：返回引起子进程停止的信号的编号。只有在 WIFSTOPPED\(\) 返回为真时，才定义这个状态。) Tj
T*
(* WIFCONTINUED\(status\)：如果子进程收到 SIGCONT 信号重新启动，则返回真。) Tj
T*
() Tj
T*
(4. 错误条件) Tj
T*
() Tj
T*
() Tj
T*
(如果调用进程没有子进程，那么 waitpid 返回 -1，并且设置 errno 为 ECHILD。如果 waitpid 函数被一个信号中断，那么它返回 -1，并设置 errno 为) Tj
T*
(EINTR。) Tj
T*
() Tj
T*
(旁注 - 和 Unix 函数相关的常量) Tj
T*
() Tj
T*
() Tj
T*
(像 WNOHANG 和 WUNTRACED 这样的常量是由系统头文件定义的。例如，WNOHANG 和 WUNTRACED 是由 wait.h 头文件（间接）定义的：) Tj
T*
() Tj
T*
(    /* Bits in the third argument to 'waitpid'. */) Tj
T*
(    #define WNOHANG    1   /* Don’t block waiting. */) Tj
T*
(    #define WUNTRACED  2   /* Report status of stopped children. */) Tj
T*
() Tj
T*
(为了使用这些常量，必须在代码中包含 wait.h 头文件：) Tj
T*
() Tj
T*
(    #include <sys/wait.h>) Tj
T*
() Tj
T*
(每个 Unix 函数的 man 页列出了无论何时你在代码中使用那个函数都要包含的头文件。同时，为了检查诸如 ECHILD 和 EINTR 之类的返回代码，你必须包含) Tj
T*
(errno.h。为了简化代码示例，我们包含了一个称为 csapp.h 的头文件，它包括了本书中使用的所有函数的头文件。csapp.h 头文件可以从 CS：APP 网站在线获得。) Tj
T*
() Tj
T*
(练习题 8.3) Tj
T*
() Tj
T*
() Tj
T*
(列出下面程序所有可能的输出序列：) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        if \(Fork\(\) == 0\) {) Tj
T*
(            printf\("a"\); fflush\(stdout\);) Tj
T*
(        }) Tj
T*
(        else {) Tj
T*
(            printf\("b"\); fflush\(stdout\);) Tj
T*
ET
endstream
endobj
443 0 obj
<< /Length 1974 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            waitpid\(-1, NULL, 0\);) Tj
T*
(        }) Tj
T*
(        printf\("c"\); fflush\(stdout\);) Tj
T*
(        exit\(0\);) Tj
T*
(     }) Tj
T*
() Tj
T*
(我们知道序列 acbc、abcc 和 bacc 是可能的，因为它们对应有进程图的拓扑排序（图 8-48）。而像 bcac 和 cbca) Tj
T*
(这样的序列不对应有任何拓扑排序，因此它们是不可行的。) Tj
T*
() Tj
T*
([Image: 图 8-48 练习题 8.3 的进程图]) Tj
T*
() Tj
T*
(5. wait 函数) Tj
T*
() Tj
T*
() Tj
T*
(wait 函数是 waitpid 函数的简单版本：) Tj
T*
() Tj
T*
(    #include <sys/types.h>) Tj
T*
(    #include <sys/wait.h>) Tj
T*
() Tj
T*
(    pid_t wait\(int *statusp\);) Tj
T*
(    // 返回：如果成功，则为子进程的 PID，如果出错，则为 -1。) Tj
T*
() Tj
T*
(调用 wait\(\\&status\) 等价于调用 waitpid\(-1, \\&status, 0\)。) Tj
T*
() Tj
T*
(6. 使用 waitpid 的示例) Tj
T*
() Tj
T*
() Tj
T*
(因为 waitpid 函数有些复杂，看几个例子会有所帮助。图 8-18 展示了一个程序，它使用 waitpid，不按照特定的顺序等待它的所有 N 个子进程终止。在第 11) Tj
T*
(行，父进程创建 N 个子进程，在第 12 行，每个子进程以一个唯一的退出状态退出。在我们继续讲解之前，请确认你已经理解为什么每个子进程会执行第 12 行，而父进程不会。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    #define N 2) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int status, i;) Tj
T*
(        pid_t pid;) Tj
T*
() Tj
T*
(        /* Parent creates N children */) Tj
T*
(        for \(i = 0; i < N; i++\)) Tj
T*
(            if \(\(pid = Fork\(\)\) == 0\) /* Child */) Tj
T*
(                exit\(100+i\);) Tj
T*
() Tj
T*
(        /* Parent reaps N children in no particular order */) Tj
T*
(        while \(\(pid = waitpid\(-1, &status, 0\)\) > 0\) {) Tj
T*
(            if \(WIFEXITED\(status\)\)) Tj
T*
ET
endstream
endobj
444 0 obj
<< /Length 3036 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(                printf\("child %d terminated normally with exit status=%d\\n",) Tj
T*
(                       pid, WEXITSTATUS\(status\)\);) Tj
T*
(            else) Tj
T*
(                printf\("child %d terminated abnormally\\n", pid\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* The only normal termination is if there are no more children */) Tj
T*
(        if \(errno != ECHILD\)) Tj
T*
(            unix_error\("waitpid error"\);) Tj
T*
() Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-18 使用 waitpid 函数不按照特定的顺序回收僵死子进程) Tj
T*
() Tj
T*
(在第 15 行，父进程用 waitpid 作为 while 循环的测试条件，等待它所有的子进程终止。因为第一个参数是 -1，所以对 waitpid) Tj
T*
(的调用会阻塞，直到任意一个子进程终止。在每个子进程终止时，对 waitpid 的调用会返回，返回值为该子进程的非零的 PID。第 16) Tj
T*
(行检查子进程的退出状态。如果子进程是正常终止的——在此是以调用 exit 函数终止的——那么父进程就提取出退出状态，把它输出到 stdout 上。) Tj
T*
() Tj
T*
(当回收了所有的子进程之后，再调用 waitpid 就返回 -1，并且设置 errno 为 ECHILD。第 24 行检查 waitpid) Tj
T*
(函数是正常终止的，否则就输出一个错误消息。在我们的 Linux 系统上运行这个程序时，它产生如下输出：) Tj
T*
() Tj
T*
(    linux> ./waitpid1) Tj
T*
(    child 22966 terminated normally with exit status=100) Tj
T*
(    child 22967 terminated normally with exit status=101) Tj
T*
() Tj
T*
(注意，程序不会按照特定的顺序回收子进程。子进程回收的顺序是这台特定的计算机系统的属性。在另一个系统上，甚至在同一个系统上再执行一次，两个子进程都可能以相反的顺序被回收。这是非确定性) Tj
T*
(行为的一个示例，这种非确定性行为使得对并发进行推理非常困难。两种可能的结果都同样是正确的，作为一个程序员，你绝不可以假设总是会出现某一个结果，无论多么不可能出现另一个结果。唯一正确) Tj
T*
(的假设是每一个可能的结果都同样可能出现。) Tj
T*
() Tj
T*
(图 8-19 展示了一个简单的改变，它消除了这种不确定性，按照父进程创建子进程的相同顺序来回收这些子进程。在第 11 行中，父进程按照顺序存储了它的子进程的) Tj
T*
(PID，然后通过用适当的 PID 作为第一个参数来调用 waitpid，按照同样的顺序来等待每个子进程。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    #define N 2) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int status, i;) Tj
T*
(        pid_t pid[N], retpid;) Tj
T*
() Tj
T*
(        /* Parent creates N children */) Tj
T*
(        for \(i = 0; i < N; i++\)) Tj
T*
(            if \(\(pid[i] = Fork\(\)\) == 0\) /* Child */) Tj
T*
(                exit\(100+i\);) Tj
T*
() Tj
T*
ET
endstream
endobj
445 0 obj
<< /Length 1616 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        /* Parent reaps N children in order */) Tj
T*
(        i = 0;) Tj
T*
(        while \(\(retpid = waitpid\(pid[i++], &status, 0\)\) > 0\) {) Tj
T*
(            if \(WIFEXITED\(status\)\)) Tj
T*
(                printf\("child %d terminated normally with exit status=%d\\n",) Tj
T*
(                       retpid, WEXITSTATUS\(status\)\);) Tj
T*
(        else) Tj
T*
(            printf\("child %d terminated abnormally\\n", retpid\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* The only normal termination is if there are no more children */) Tj
T*
(        if \(errno != ECHILD\)) Tj
T*
(            unix_error\("waitpid error"\);) Tj
T*
() Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-19 使用 waitpid 按照创建子进程的顺序来回收这些僵死子进程) Tj
T*
() Tj
T*
(练习题 8.4) Tj
T*
() Tj
T*
() Tj
T*
(考虑下面的程序：) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int status;) Tj
T*
(        pid_t pid;) Tj
T*
() Tj
T*
(        printf\("Hello\\n"\);) Tj
T*
(        pid = Fork\(\);) Tj
T*
(        printf\("%d\\n", !pid\);) Tj
T*
(        if \(pid != 0\) {) Tj
T*
(            if \(waitpid\(-1, &status, 0\) > 0\) {) Tj
T*
(                if \(WIFEXITED\(status\) != 0\)) Tj
T*
(                    printf\("%d\\n", WEXITSTATUS\(status\)\);) Tj
T*
(            }) Tj
T*
(        }) Tj
T*
(        printf\("Bye\\n"\);) Tj
T*
(        exit\(2\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(A. 这个程序会产生多少输出行？) Tj
T*
() Tj
T*
(B. 这些输出行的一种可能的顺序是什么？) Tj
T*
() Tj
T*
ET
endstream
endobj
446 0 obj
<< /Length 1908 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(A. 只简单地计算进程图（图 8-49）中 printf 顶点的个数就能确定输出行数。在这里，有 6 个这样的顶点，因此程序会打印 6 行输出。) Tj
T*
() Tj
T*
(B. 任何对应有进程图的拓扑排序的输出序列都是可能的。例如：Hello、1、0、Bye、2、Bye 是可能的。) Tj
T*
() Tj
T*
([Image: 图 8-49 练习题 8.4 的进程图]) Tj
T*
() Tj
T*
(8.4.4 让进程休眠) Tj
T*
() Tj
T*
() Tj
T*
(sleep函数将一个进程挂起一段指定的时间。) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
(    unsigned int sleep\(unsigned int secs\);) Tj
T*
() Tj
T*
(    // 返回：还要休眠的秒数。) Tj
T*
() Tj
T*
(如果请求的时间量已经到了，sleep 返回 0，否则返回还剩下的要休眠的秒数。后一种情况是可能的，如果因为 sleep 函数被一个信号中断而过早地返回。我们将在 8.5) Tj
T*
(节中详细讨论信号。) Tj
T*
() Tj
T*
(我们会发现另一个很有用的函数是 pause 函数，该函数让调用函数休眠，直到该进程收到一个信号。) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
(    int pause\(void\);) Tj
T*
() Tj
T*
(    // 总是返回 -1。) Tj
T*
() Tj
T*
(练习题 8.5) Tj
T*
() Tj
T*
() Tj
T*
(编写一个 sleep 的包装函数，叫做 snooze，带有下面的接口：) Tj
T*
() Tj
T*
(    unsigned int snooze\(unsigned int secs\);) Tj
T*
() Tj
T*
(snooze 函数和 sleep 函数的行为完全一样，除了它会打印出一条消息来描述进程实际休眠了多长时间：) Tj
T*
() Tj
T*
(    Slept for 4 of 5 secs.) Tj
T*
() Tj
T*
(    unsigned int snooze\(unsigned int secs\) {) Tj
T*
(        unsigned int rc = sleep\(secs\);) Tj
T*
() Tj
T*
(        printf\("Slept for %d of %d secs.\\n", secs - rc, secs\);) Tj
T*
(        return rc;) Tj
T*
(    }) Tj
T*
() Tj
T*
(8.4.5 加载并运行程序) Tj
T*
() Tj
T*
ET
endstream
endobj
447 0 obj
<< /Length 2859 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(execve 函数在当前进程的上下文中加载并运行一个新程序。) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
(    int execve\(const char *filename, const char *argv[],) Tj
T*
(               const char *envp[]\);) Tj
T*
() Tj
T*
(    // 如果成功，则不返回，如果错误，则返回 -1。) Tj
T*
() Tj
T*
(execve 函数加载并运行可执行目标文件 filename，且带参数列表 argv 和环境变量列表 envp。只有当出现错误时，例如找不到 filename，execve) Tj
T*
(才会返回到调用程序。所以，与 fork—次调用返回两次不同，execve 调用一次并从不返回。) Tj
T*
() Tj
T*
(参数列表是用图 8-20 中的数据结构表示的。argv 变量指向一个以 null 结尾的指针数组，其中每个指针都指向一个参数字符串。按照惯例，argv\\[0]) Tj
T*
(是可执行目标文件的名字。) Tj
T*
() Tj
T*
([Image: 图 8-20 参数列表的组织结构]) Tj
T*
() Tj
T*
(环境变量的列表是由一个类似的数据结构表示的，如图 8-21 所示。envp 变量指向一个以 null 结尾的指针数组，其中每个指针指向一个环境变量字符串，每个串都是形如) Tj
T*
(“name=value” 的名字—值对。) Tj
T*
() Tj
T*
([Image: 图 8-21 环境变量列表的组织结构]) Tj
T*
() Tj
T*
(在 execve 加载了 filename 之后，它调用 7.9 节中描述的启动代码。启动代码设置栈，并将控制传递给新程序的主函数，该主函数有如下形式的原型) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv, char **envp\);) Tj
T*
() Tj
T*
(或者等价的) Tj
T*
() Tj
T*
(    int main\(int argc, char *argv[], char *envp[]\);) Tj
T*
() Tj
T*
(当 main 开始执行时，用户栈的组织结构如图 8-22 所示。让我们从栈底（高地址）往栈顶（低地址）依次看一看。首先是参数和环境字符串。栈往上紧随其后的是以 null) Tj
T*
(结尾的指针数组，其中每个指针都指向栈中的一个环境变量字符串。全局变量 environ 指向这些指针中的第一个 envp\\[0]o 紧随环境变量数组之后的是以 null 结尾的) Tj
T*
(argv\\[] 数组，其中每个元素都指向栈中的一个参数字符串。在栈的顶部是系统启动函数 libc\\start\\main（见 7.9 节）的栈帧。) Tj
T*
() Tj
T*
([Image: 图 8-22 一个新程序开始时，用户栈的典型组织结构]) Tj
T*
() Tj
T*
(main 函数有 3 个参数：) Tj
T*
() Tj
T*
(1. argc，它给出 argv\\[ ] 数组中非空指针的数量；) Tj
T*
(2. argv，指向 argv\\[ ] 数组中的第一个条目；) Tj
T*
(3. envp，指向 envp\\[ ] 数组中的第一个条目。) Tj
T*
() Tj
T*
(Linux 提供了几个函数来操作环境数组：) Tj
T*
() Tj
T*
(    #include <stdlib.h>) Tj
T*
(    char *getenv\(const char *name\);) Tj
T*
ET
endstream
endobj
448 0 obj
<< /Length 2456 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(    // 返回：若存在则为指向 name 的指针，若无匹配的，则为 NULL。) Tj
T*
() Tj
T*
(getenv 函数在环境数组中搜索字符串 “name=value”。如果找到了，它就返回一个指向 value 的指针，否则它就返回 NULL。) Tj
T*
() Tj
T*
(    #include <stdlib.h>) Tj
T*
() Tj
T*
(    int setenv\(const char *name, const char *newvalue, int overwrite\);) Tj
T*
(    // 返回：若成功则为 0，若错误则为 -1。) Tj
T*
() Tj
T*
(    void unsetenv\(const char *name\);) Tj
T*
(    // 返回：无。) Tj
T*
() Tj
T*
(如果环境数组包含一个形如 “name=oldva1ue” 的字符串，那么 unsetenv 会删除它，而 setenv 会用 newvalue 代替 oldvalue，但是只有在) Tj
T*
(overwirte 非零时才会这样。如果 name 不存在，那么 setenv 就把 “name=newvalue” 添加到数组中。) Tj
T*
() Tj
T*
(旁注 - 程序与进程) Tj
T*
() Tj
T*
() Tj
T*
(这是一个适当的地方，停下来，确认一下你理解了程序和进程之间的区别。程序是一堆代码和数据；程序可以作为目标文件存在于磁盘上，或者作为段存在于地址空间中。进程是执行中程序的一个具体的实) Tj
T*
(例；程序总是运行在某个进程的上下文中。如果你想要理解 fork 和 execve 函数，理解这个差异是很重要的。fork) Tj
T*
(函数在新的子进程中运行相同的程序，新的子进程是父进程的一个复制品。execve) Tj
T*
(函数在当前进程的上下文中加载并运行一个新的程序。它会覆盖当前进程的地址空间，但并没有创建一个新进程。新的程序仍然有相同的 PID，并且继承了调用 execve) Tj
T*
(函数时已打开的所有文件描述符。) Tj
T*
() Tj
T*
(练习题 8.6) Tj
T*
() Tj
T*
() Tj
T*
(编写一个叫做 myecho 的程序，打印出它的命令行参数和环境变量。) Tj
T*
() Tj
T*
(    linux> ./myecho arg1 arg2) Tj
T*
(    Command-ine arguments:) Tj
T*
(        argv[ 0]: myecho) Tj
T*
(        argv[ 1]: arg1) Tj
T*
(        argv[ 2]: arg2) Tj
T*
(    Environment variables:) Tj
T*
(        envp[ 0]: PWD=/usr0/droh/ics/code/ecf) Tj
T*
(        envp[ 1]: TERM=emacs) Tj
T*
(        .) Tj
T*
(        .) Tj
T*
(        .) Tj
T*
(        envp[25]: USER=droh) Tj
T*
(        envp[26]: SHELL=/usr/local/bin/tcsh) Tj
T*
(        envp[27]: HOME=/usr0/droh) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
ET
endstream
endobj
449 0 obj
<< /Length 1968 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(    int main\(int argc, char *argv[], char *envp[]\)) Tj
T*
(    {) Tj
T*
(        int i;) Tj
T*
() Tj
T*
(        printf\("Command-line arguments:\\n"\);) Tj
T*
(        for \(i = 0; argv[i] != NULL; i++\)) Tj
T*
(            printf\(" argv[%2d]: %s\\n", i, argv[i]\);) Tj
T*
() Tj
T*
(        printf\("\\n"\);) Tj
T*
(        printf\("Environment variables:\\n"\);) Tj
T*
(        for \(i = 0; envp[i] != NULL; i++\)) Tj
T*
(            printf\(" envp[%2d]: %s\\n", i, envp[i]\);) Tj
T*
() Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(8.4.6 利用 fork 和 execve 运行程序) Tj
T*
() Tj
T*
() Tj
T*
(像 Unix shell 和 Web 服务器这样的程序大量使用了 fork 和 execve 函数。shell 是一个交互型的应用级程序，它代表用户运行其他程序。最早的 shell) Tj
T*
(是 sh 程序，后面出现了—些变种，比如 csh、tcsh、ksh 和 bash。shell) Tj
T*
(执行一系列的读/求值（read/evaluate）步骤，然后终止。读步骤读取来自用户的一个命令行。求值步骤解析命令行，并代表用户运行程序。) Tj
T*
() Tj
T*
(图 8-23 展示了一个简单 shell 的 main 例程。shell 打印一个命令行提示符，等待用户在 stdin 上 输入命令行，然后对这个命令行求值。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    #define MAXARGS 128) Tj
T*
() Tj
T*
(    /* Function prototypes */) Tj
T*
(    void eval\(char *cmdline\);) Tj
T*
(    int parseline\(char *buf, char **argv\);) Tj
T*
(    int builtin_command\(char **argv\);) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        char cmdline[MAXLINE]; /* Command line */) Tj
T*
() Tj
T*
(        while \(1\) {) Tj
T*
(            /* Read */) Tj
T*
(            printf\("> "\);) Tj
T*
(            Fgets\(cmdline, MAXLINE, stdin\);) Tj
T*
(            if \(feof\(stdin\)\)) Tj
T*
(                exit\(0\);) Tj
T*
() Tj
T*
(            /* Evaluate */) Tj
T*
ET
endstream
endobj
450 0 obj
<< /Length 2231 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            eval\(cmdline\);) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-23 一个简单的 shell 程序的 main 例程) Tj
T*
() Tj
T*
(图 8-24 展示了对命令行求值的代码。它的首要任务是调用 parseline 函数（见图 8-25），这个函数解析了以空格分隔的命令行参数，并构造最终会传递给 execve 的) Tj
T*
(argv 向量。第一个参数被假设为要么是一个内置的 shell 命令名，马上就会解释这个命令，要么是一个可执行目标文件，会在一个新的子进程的上下文中加载并运行这个文件。) Tj
T*
() Tj
T*
(    /* eval - Evaluate a command line */) Tj
T*
(    void eval\(char *cmdline\)) Tj
T*
(    {) Tj
T*
(        char *argv[MAXARGS]; /* Argument list execve\(\) */) Tj
T*
(        char buf[MAXLINE];   /* Holds modified command line */) Tj
T*
(        int bg;              /* Should the job run in bg or fg? */) Tj
T*
(        pid_t pid;           /* Process id */) Tj
T*
() Tj
T*
(        strcpy\(buf, cmdline\);) Tj
T*
(        bg = parseline\(buf, argv\);) Tj
T*
(        if \(argv[0] == NULL\)) Tj
T*
(            return;   /* Ignore empty lines */) Tj
T*
() Tj
T*
(        if \(!builtin_command\(argv\)\) {) Tj
T*
(            if \(\(pid = Fork\(\)\) == 0\) {   /* Child runs user job */) Tj
T*
(                if \(execve\(argv[0], argv, environ\) < 0\) {) Tj
T*
(                    printf\("%s: Command not found.\\n", argv[0]\);) Tj
T*
(                    exit\(0\);) Tj
T*
(                }) Tj
T*
(            }) Tj
T*
() Tj
T*
(            /* Parent waits for foreground job to terminate */) Tj
T*
(            if \(!bg\) {) Tj
T*
(                int status;) Tj
T*
(                if \(waitpid\(pid, &status, 0\) < 0\)) Tj
T*
(                    unix_error\("waitfg: waitpid error"\);) Tj
T*
(                }) Tj
T*
(            else) Tj
T*
(                printf\("%d %s", pid, cmdline\);) Tj
T*
(        }) Tj
T*
(        return;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* If first arg is a builtin command, run it and return true */) Tj
T*
(    int builtin_command\(char **argv\)) Tj
T*
(    {) Tj
T*
(        if \(!strcmp\(argv[0], "quit"\)\) /* quit command */) Tj
T*
ET
endstream
endobj
451 0 obj
<< /Length 2154 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            exit\(0\);) Tj
T*
(        if \(!strcmp\(argv[0], "&"\)\)    /* Ignore singleton & */) Tj
T*
(            return 1;) Tj
T*
(        return 0;                     /* Not a builtin command */) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-24 eval 对 shell 命令行求值) Tj
T*
() Tj
T*
(    /* parseline - Parse the command line and build the argv array */) Tj
T*
(    int parseline\(char *buf, char **argv\)) Tj
T*
(    {) Tj
T*
(        char *delim;         /* Points to first space delimiter */) Tj
T*
(        int argc;            /* Number of args */) Tj
T*
(        int bg;              /* Background job? */) Tj
T*
() Tj
T*
(        buf[strlen\(buf\)-1] = ' ';  /* Replace trailing '\\n' with space */) Tj
T*
(        while \(*buf && \(*buf == ' '\)\) /* Ignore leading spaces */) Tj
T*
(            buf++;) Tj
T*
() Tj
T*
(        /* Build the argv list */) Tj
T*
(        argc = 0;) Tj
T*
(        while \(\(delim = strchr\(buf, ' '\)\)\) {) Tj
T*
(            argv[argc++] = buf;) Tj
T*
(            *delim = '\\0';) Tj
T*
(            buf = delim + 1;) Tj
T*
(            while \(*buf && \(*buf == ' '\)\) /* Ignore spaces */) Tj
T*
(                buf++;) Tj
T*
(        }) Tj
T*
(        argv[argc] = NULL;) Tj
T*
() Tj
T*
(        if \(argc == 0\) /* Ignore blank line */) Tj
T*
(            return 1;) Tj
T*
() Tj
T*
(        /* Should the job run in the background? */) Tj
T*
(        if \(\(bg = \(*argv[argc-1] == '&'\)\) != 0\)) Tj
T*
(            argv[--argc] = NULL;) Tj
T*
() Tj
T*
(        return bg;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-25 parseline 解析 shell 的一个输入行) Tj
T*
() Tj
T*
(如果最后一个参数是一个 “&” 字符，那么 parseline 返回 1，表示应该在后台执行该程序（shell 不会等待它完成）。否则，它返回) Tj
T*
(0，表示应该在前台执行这个程序（shell 会等待它完成）。) Tj
T*
() Tj
T*
(在解析了命令行之后，eval 函数调用 builtin\\_command 函数，该函数检查第一个命令行参数是否是一个内置的 shell 命令。如果是，它就立即解释这个命令，并返回值) Tj
T*
ET
endstream
endobj
452 0 obj
<< /Length 4133 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(1。否则返回 0。简单的 shell 只有一个内置命令—— quit 命令，该命令会终止 shell。实际使用的 shell 有大量的命令，比如 pwd、jobs 和 fg。) Tj
T*
() Tj
T*
(如果 builtin\\_cornnand 返回 0，那么 shell 创建一个子进程，并在子进程中执行所请求的程序。如果用户要求在后台运行该程序，那么 shell) Tj
T*
(返回到循环的顶部，等待下一个命令行。否则，shell 使用 waitpid 函数等待作业终止。当作业终止时，shell 就开始下一轮迭代。) Tj
T*
() Tj
T*
(注意，这个简单的 shell 是有缺陷的，因为它并不回收它的后台子进程。修改这个缺陷就要求使用信号，我们将在下一节中讲述信号。) Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(8.5 信号) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(8.5 信号) Tj
T*
() Tj
T*
() Tj
T*
(到目前为止对异常控制流的学习中，我们已经看到了硬件和软件是如何合作以提供基本的低层异常机制的。我们也看到了操作系统如何利用异常来支持进程上下文切换的异常控制流形式。在本节中，我们将) Tj
T*
(研究一种更高层的软件形式的异常，称为 Linux 信号，它允许进程和内核中断其他进程。) Tj
T*
() Tj
T*
(一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。比如，图 8-26 展示了 Linux 系统上支持的 30 种不同类型的信号。) Tj
T*
() Tj
T*
(每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。比如，如果一个进程) Tj
T*
(试图除以 0，那么内核就发送给它一个 SIGFPE 信号（号码 8）。如果一个进程执行一条非法指令，那么内核就发送给它一个 SIGILL 信号（号码) Tj
T*
(4）。如果进程进行非法内存引用，内核就发送给它一个 SIGSEGV 信号（号码 11）。其他信号对应于内核或者其他用户进程中较高层的软件事件。比如，如果当进程在前台运行时，你键入) Tj
T*
(Ctrl+C（也就是同时按下 Ctrl 键和 C 键），那么内核就会发送一个 SIGINT 信号（号码 2）给这个前台进程组中的每个进程。一个进程可以通过向另一个进程发送一个) Tj
T*
(SIGKILL 信号（号码 9）强制终止它。当一个子进程终止或者停止时，内核会发送一个 SIGCHLD 信号（号码 17）给父进程。) Tj
T*
() Tj
T*
(| 序号 | 名称 | 默认行为 | 相应事件 |) Tj
T*
(| :--- | :--- | :--- | :--- |) Tj
T*
(| 1 | SIGHUP | 终止 | 终端线挂断 |) Tj
T*
(| 2 | SIGINT | 终止 | 来自键盘的中断 |) Tj
T*
(| 3 | SIGQUIT | 终止 | 来自键盘的退出 |) Tj
T*
(| 4 | SIGILL | 终止 | 非法指令 |) Tj
T*
(| 5 | SIGTRAP | 终止并转储内存$$^①$$ | 跟踪陷阱 |) Tj
T*
(| 6 | SIGABRT | 终止并转储内存$$^①$$  | 来自 abort 函数的终止信号 |) Tj
T*
(| 7 | SIGBUS | 终止 | 总线错误 |) Tj
T*
(| 8 | SIGFPE | 终止并转储内存$$^①$$ | 浮点异常 |) Tj
T*
(| 9 | SIGKILL | 终止$$^②$$ | 杀死程序 |) Tj
T*
(| 10 | SIGUSR1 | 终止 | 用户定义的信号 1 |) Tj
T*
(| 11 | SIGSEGV | 终止并转储内存$$^①$$ | 无效的内存引用（段故障） |) Tj
T*
(| 12 | SIGUSR2 | 终止 | 用户定义的信号 2 |) Tj
T*
(| 13 | SIGPIPE | 终止 | 向一个没有读用户的管道做写操作 |) Tj
T*
(| 14 | SIGALRM | 终止 | 来自 alarm 函数的定时器信号 |) Tj
T*
(| 15 | SIGTERM | 终止 | 软件终止信号 |) Tj
T*
(| 16 | SIGSTKFLT | 终止 | 协处理器上的栈故障 |) Tj
T*
(| 17 | SIGCHLD | 忽略 | 一个子进程停止或者终止 |) Tj
T*
(| 18 | SIGCONT | 忽略 | 继续进程如果该进程停止 |) Tj
T*
(| 19 | SIGSTOP | 停止直到下一个SIGCONT$$^②$$ | 不是来自终端的停止信号 |) Tj
T*
ET
endstream
endobj
453 0 obj
<< /Length 3398 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(| 20 | SIGTSTP | 停止直到下一个SIGCONT | 来自终端的停止信号 |) Tj
T*
(| 21 | SIGTTIN | 停止直到下一个SIGCONT | 后台进程从终端读 |) Tj
T*
(| 22 | SIGTTOU | 停止直到下一个SIGCONT | 后台进程向终端写 |) Tj
T*
(| 23 | SIGURG | 忽略 | 套接字上的紧急情况 |) Tj
T*
(| 24 | SIGXCPU | 终止 | CPU 时间限制超出 |) Tj
T*
(| 25 | SIGXFSZ | 终止 | 文件大小限制超出 |) Tj
T*
(| 26 | SIGVTALRM | 终止 | 虚拟定时器期满 |) Tj
T*
(| 27 | SIGPROF | 终止 | 剖析定时器期满 |) Tj
T*
(| 28 | SIGWINCH | 忽略 | 窗口大小变化 |) Tj
T*
(| 29 | SIGIO | 终止 | 在某个描述符上可执行 I/O 操作 |) Tj
T*
(| 30 | SIGPWR | 终止 | 电源故障 |) Tj
T*
() Tj
T*
(> 图 8-26 Linux 信号) Tj
T*
() Tj
T*
(* ① 多年前，主存是用一种称为磁芯存储器（core memory）的技术来实现的。“转储内存”（dumping) Tj
T*
(core）是一个历史术语，意思是把代码和数据内存段的映像写到磁盘上。) Tj
T*
(* ② 这个信号既不能被捕获，也不能被忽略。) Tj
T*
() Tj
T*
(（来源：man 7 signal。数据来自 Linux Foundation。）) Tj
T*
() Tj
T*
(8.5.1 信号术语) Tj
T*
() Tj
T*
() Tj
T*
(传送一个信号到目的进程是由两个不同步骤组成的：) Tj
T*
() Tj
T*
(* 发送信号。内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两种原因：) Tj
T*
() Tj
T*
(  * 1）内核检测到一个系统事件，比如除零错误或者子进程终止。) Tj
T*
(  * 2）一个进程调用了 kill 函数（在下一节中讨论），显式地要求内核发送一个信号给目的进程。) Tj
T*
() Tj
T*
(  一个进程可以发送信号给它自己。) Tj
T*
() Tj
T*
(* 接收信号。当目的进程被内核强迫以某种方式对信号的发送做出反应时，它就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序（signal) Tj
T*
(handler）的用户层函数捕获这个信号。图 8-27 给出了信号处理程序捕获信号的基本思想。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 8-27 信号处理。接收到信号会触发控制转移到信号处理程序。在信号处理程序完成处理之后，它将控制返回给被中断的程序) Tj
T*
() Tj
T*
(一个发出而没有被接收的信号叫做待处理信号（pending signal）。在任何时刻，一种类型至多只会有一个待处理信号。如果一个进程有一个类型为上的待处理信号，那么任何接下来发送到) Tj
T*
(这个进程的类型为左的信号都不会排队等待；它们只是被简单地丢弃。一个进程可以有选择性地阻塞接收某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取) Tj
T*
(消对这种信号的阻塞。) Tj
T*
() Tj
T*
(一个待处理信号最多只能被接收一次。内核为每个进程在 pending 位向量中维护着待处理信号的集合，而在✦ blocked 位向量✦中维护着被阻塞的信号集合。只要传送了一个类型为) Tj
T*
(k 的信号，内核就会设置 pending 中的第 k 位，而只要接收了一个类型为 k 的信号，内核就会清除 pending 中的第 k 位。) Tj
T*
() Tj
T*
ET
endstream
endobj
454 0 obj
<< /Length 2104 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(✦ blocked 位向量✦：也称为信号掩码（signal mask）。) Tj
T*
() Tj
T*
(8.5.2 发送信号) Tj
T*
() Tj
T*
() Tj
T*
(Unix 系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组（process group）这个概念的。) Tj
T*
() Tj
T*
(1. 进程组) Tj
T*
() Tj
T*
() Tj
T*
(每个进程都只属于一个进程组，进程组是由一个正整数进程组 ID 来标识的。getpgrp 函数返回当前进程的进程组 ID：) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
(    pid_t getpgrp\(void\);) Tj
T*
() Tj
T*
(    // 返回：调用进程的进程组 ID。) Tj
T*
() Tj
T*
(默认地，一个子进程和它的父进程同属于一个进程组。一个进程可以通过使用 setpgid 函数来改变自己或者其他进程的进程组：) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
(    int setpgid\(pid_t pid, pid_t pgid\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为o，若错误则为 -1。) Tj
T*
() Tj
T*
(setpgid 函数将进程 pid 的进程组改为 pgid。如果 pid 是 0，那么就使用当前进程的 PID。如果 pgid 是 0，那么就用 pid 指定的进程的 PID) Tj
T*
(作为进程组 ID。例如，如果进程 15213 是调用进程，那么) Tj
T*
() Tj
T*
(    setpgid\(0, 0\);) Tj
T*
() Tj
T*
(会创建一个新的进程组，其进程组 ID 是 15213，并且把进程 15213 加入到这个新的进程组中。) Tj
T*
() Tj
T*
(2. 用 /bin/kill 程序发送信号) Tj
T*
() Tj
T*
() Tj
T*
(/bin/kill 程序可以向另外的进程发送任意的信号。比如，命令) Tj
T*
() Tj
T*
(    linux> /bin/kill -9 15213) Tj
T*
() Tj
T*
(发送信号 9（SIGKILL）给进程 15213。一个为负的 PID 会导致信号被发送到进程组 PID 中的每个进程。比如，命令) Tj
T*
() Tj
T*
(    linux> /bin/kill -9 -15213) Tj
T*
() Tj
T*
(发送一个 SIGKILL 信号给进程组 15213 中的每个进程。注意，在此我们使用完整路径 /bin/kill，因为有些 Unix shell 有自己内置的 kill 命令。) Tj
T*
() Tj
T*
(3. 从键盘发送信号) Tj
T*
() Tj
T*
ET
endstream
endobj
455 0 obj
<< /Length 2650 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(Unix shell 使用作业（job）这个抽象概念来表示为对一条命令行求值而创建的进程。在任何时刻，至多只有一个前台作业和 0 个或多个后台作业。比如，键入) Tj
T*
() Tj
T*
(    linux> ls | sort) Tj
T*
() Tj
T*
(会创建一个由两个进程组成的前台作业，这两个进程是通过 Unix 管道连接起来的：一个进程运行 ls 程序，另一个运行 sort 程序。shell) Tj
T*
(为每个作业创建一个独立的进程组。进程组 ID 通常取自作业中父进程中的一个。比如，图 8-28 展示了有一个前台作业和两个后台作业的 shell。前台作业中的父进程 PID 为) Tj
T*
(20，进程组 ID 也为 20。父进程创建两个子进程，每个也都是进程组 20 的成员。) Tj
T*
() Tj
T*
([Image: &#x56FE; 8-28 &#x524D;&#x53F0;&#x548C;&#x540E;&#x53F0;&#x8FDB;&#x7A0B;&#x7EC4;]) Tj
T*
() Tj
T*
(在键盘上输入 Ctrl+C 会导致内核发送一个 SIGINT 信号到前台进程组中的每个进程。默认情况下，结果是终止前台作业。类似地，输入 Ctrl+Z 会发送一个 SIGTSTP) Tj
T*
(信号到前台进程组中的每个进程。默认情况下，结果是停止（挂起）前台作业。) Tj
T*
() Tj
T*
(4. 用 kill 函数发送信号) Tj
T*
() Tj
T*
() Tj
T*
(进程通过调用 kill 函数发送信号给其他进程（包括它们自己）。) Tj
T*
() Tj
T*
(    #include <sys/types.h>) Tj
T*
(    #include <signal.h>) Tj
T*
() Tj
T*
(    int kill\(pid_t pid, int sig\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为 0，若错误则为 -1。) Tj
T*
() Tj
T*
(如果 pid 大于零，那么 kill 函数发送信号号码 sig 给进程 pid。如果 pid 等于零，那么 kill 发送信号 sig) Tj
T*
(给调用进程所在进程组中的每个进程，包括调用进程自己。如果 pid 小于零，kill 发送信号 sig 给进程组 \\|pid\\|（pid 的绝对值）中的每个进程。图 8-29) Tj
T*
(展示了一个示例，父进程用 kill 函数发送 SIGKILL 信号给它的子进程。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        pid_t pid;) Tj
T*
() Tj
T*
(        /* Child sleeps until SIGKILL signal received, then dies */) Tj
T*
(        if \(\(pid = Fork\(\)\) == 0\) {) Tj
T*
(            Pause\(\); /* Wait for a signal to arrive */) Tj
T*
(            printf\("control should never reach here!\\n"\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Parent sends a SIGKILL signal to a child */) Tj
T*
(        Kill\(pid, SIGKILL\);) Tj
T*
(        exit\(0\);) Tj
T*
ET
endstream
endobj
456 0 obj
<< /Length 2817 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    }) Tj
T*
() Tj
T*
(> 图 8-29 使用 kill 函数发送信号给子进程) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(5. 用 alarm 函数发送信号) Tj
T*
() Tj
T*
() Tj
T*
(进程可以通过调用 alarm 函数向它自己发送 SIGALRM 信号。) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
(    unsigned int alarm\(unsigned int secs\);) Tj
T*
() Tj
T*
(    // 返回：前一次闹钟剩余的秒数，若以前没有设定闹钟，则为0。) Tj
T*
() Tj
T*
(alarm 函数安排内核在 secs 秒后发送一个 SIGALRM 信号给调用进程。如果 secs 是零，那么不会调度安排新的闹钟（alarm）。在任何情况下，对 alarm) Tj
T*
(的调用都将取消任何待处理的（pending）闹钟，并且返回任何待处理的闹钟在被发送前还剩下的秒数（如果这次对 alarm) Tj
T*
(的调用没有取消它的话）；如果没有任何待处理的闹钟，就返回零。) Tj
T*
() Tj
T*
(8.5.3 接收信号) Tj
T*
() Tj
T*
() Tj
T*
(当内核把进程 p 从内核模式切换到用户模式时（例如，从系统调用返回或是完成了一次上下文切换），它会检查进程 p 的未被阻塞的待处理信号的集合（pending) Tj
T*
(&~blocked）。如果这个集合为空（通常情况下），那么内核将控制传递到 p 的逻辑控制流中的下一条指令（$$\\small) Tj
T*
(I{next}$$）。然而，如果集合是非空的，那么内核选择集合中的某个信号 k （通常是最小的 k），并且强制 p 接收信号) Tj
T*
(k。收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回 p 的逻辑控制流中的下一条指令（$$\\small) Tj
T*
(I{next}$$）。每个信号类型都有一个预定义的默认行为，是下面中的一种：) Tj
T*
() Tj
T*
(* 进程终止。) Tj
T*
(* 进程终止并转储内存。) Tj
T*
(* 进程停止（挂起）直到被 SIGCONT 信号重启。) Tj
T*
(* 进程忽略该信号。) Tj
T*
() Tj
T*
(图 8-26 展示了与每个信号类型相关联的默认行为。比如，收到 SIGKILL 的默认行为就是终止接收进程。另外，接收到 SIGCHLD) Tj
T*
(的默认行为就是忽略这个信号。进程可以通过使用 signal 函数修改和信号相关联的默认行为。唯一的例外是 SIGSTOP 和 SIGKILL，它们的默认行为是不能修改的。) Tj
T*
() Tj
T*
(    #include <signal.h>) Tj
T*
(    typedef void \(*sighandler_t\)\(int\);) Tj
T*
() Tj
T*
(    sighandler_t signal\(int signum, sighandler_t handler\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为指向前次处理程序的指针，若出错则为 SIG_ERR（不设置 errno）。) Tj
T*
() Tj
T*
(signal 函数可以通过下列三种方法之一来改变和信号 signum 相关联的行为：) Tj
T*
() Tj
T*
ET
endstream
endobj
457 0 obj
<< /Length 3082 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(* 如果 handler 是 SIG\\_IGN，那么忽略类型为 signum 的信号。) Tj
T*
(* 如果 handler 是 SIG\\_DFL，那么类型为 signum 的信号行为恢复为默认行为。) Tj
T*
(* 否则，handler 就是用户定义的函数的地址，这个函数被称为信号处理程序，只要进程接收到一个类型为 signum 的信号，就会调用这个程序。通过把处理程序的地址传递到) Tj
T*
(signal 函数从而改变默认行为，这叫做设置信号处理程序（installing the handler）。调用信号处理程序被称为捕获信号。执行信号处理程序被称为处理信号。) Tj
T*
() Tj
T*
(当一个进程捕获了一个类型为 k 的信号时，会调用为信号 k 设置的处理程序，一个整数参数被设置为 k。这个参数允许同一个处理函数捕获不同类型的信号。) Tj
T*
() Tj
T*
(当处理程序执行它的 return 语句时，控制（通常）传递回控制流中进程被信号接收中断位置处的指令。我们说“通常”是因为在某些系统中，被中断的系统调用会立即返回一个错误。) Tj
T*
() Tj
T*
(图 8-30 展示了一个程序，它捕获用户在键盘上输入 Ctrl+C 时发送的 SIGINT 信号。SIGINT) Tj
T*
(的默认行为是立即终止该进程。在这个示例中，我们将默认行为修改为捕获信号，输出一条消息，然后终止该进程。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void sigint_handler\(int sig\) /* SIGINT handler */) Tj
T*
(    {) Tj
T*
(        printf\("Caught SIGINT!\\n"\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        /* Install the SIGINT handler */) Tj
T*
(        if \(signal\(SIGINT, sigint_handler\) == SIG_ERR\)) Tj
T*
(        unix_error\("signal error"\);) Tj
T*
() Tj
T*
(        pause\(\); /* Wait for the receipt of a signal */) Tj
T*
() Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-30 一个用信号处理程序捕获 SIGINT 信号的程序) Tj
T*
() Tj
T*
(信号处理程序可以被其他信号处理程序中断，如图 8-31 所示。在这个例子中，主程序捕获到信号 s，该信号会中断主程序，将控制转移到处理程序 S。S 在运行时，程序捕获信号) Tj
T*
(t≠s，该信号会中断 S，控制转移到处理程序 T。当 T 返回时，S 从它被中断的地方继续执行。最后，S 返回，控制传送回主程序，主程序从它被中断的地方继续执行。) Tj
T*
() Tj
T*
([Image: &#x56FE; 8-31 &#x4FE1;&#x53F7;&#x5904;&#x7406;&#x7A0B;&#x5E8F;&#x53EF;&#x4EE5;&#x8) Tj
T*
(8AB;&#x5176;&#x4ED6;&#x4FE1;&#x53F7;&#x5904;&#x7406;&#x7A0B;&#x5E8F;&#x4E2D;&#x65AD;]) Tj
T*
() Tj
T*
(练习题 8.7) Tj
T*
() Tj
T*
() Tj
T*
(编写一个叫做 snooze 的程序，它有一个命令行参数，用这个参数调用练习题 8.5 中的 snooze 函数，然后终止。编写程序，使得用户可以通过在键盘上输入 Ctrl+C 中断) Tj
T*
(snooze 函数。比如：) Tj
T*
() Tj
T*
(    linux> ./snooze 5) Tj
T*
ET
endstream
endobj
458 0 obj
<< /Length 2127 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    CTRL+C                     // User hits Crtl+C after 3 seconds) Tj
T*
(    Slept for 3 of 5 secs.) Tj
T*
(    linux>) Tj
T*
() Tj
T*
(只要休眠进程收到一个未被忽略的信号，sleep 函数就会提前返回。但是，因为收到一个 SIGINT 信号的默认行为就是终止进程（图 8-26），我们必须设置一个 SIGINT) Tj
T*
(处理程序来允许 sleep 函数返回。处理程序简单地捕获 SIGNAL，并将控制返回给 sleep 函数，该函数会立即返回。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    /* SIGINT handler */) Tj
T*
(    void handler\(int sig\)) Tj
T*
(    {) Tj
T*
(        return; /* Catch the signal and return */) Tj
T*
(    }) Tj
T*
() Tj
T*
(    unsigned int snooze\(unsigned int secs\) {) Tj
T*
(        unsigned int rc = sleep\(secs\);) Tj
T*
() Tj
T*
(        printf\("Slept for %d of %d secs.\\n", secs - rc, secs\);) Tj
T*
() Tj
T*
(        return rc;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\) {) Tj
T*
() Tj
T*
(        if \(argc != 2\) {) Tj
T*
(            fprintf\(stderr, "usage: %s <secs>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        if \(signal\(SIGINT, handler\) == SIG_ERR\) /* Install SIGINT */) Tj
T*
(            unix_error\("signal error\\n"\); /* handler */) Tj
T*
(        \(void\)snooze\(atoi\(argv[1]\)\); 26 exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(8.5.4 阻塞和解除阻塞信号) Tj
T*
() Tj
T*
() Tj
T*
(Linux 提供阻塞信号的隐式和显式的机制：) Tj
T*
() Tj
T*
(* 隐式阻塞机制。内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。例如，图 8-31 中，假设程序捕获了信号 s，当前正在运行处理程序 S。如果发送给该进程另一个信号) Tj
T*
(s，那么直到处理程序 S 返回，s 会变成待处理而没有被接收。) Tj
T*
(* 显式阻塞机制。应用程序可以使用 sigprocmask 函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。) Tj
T*
() Tj
T*
(    #include <signal.h>) Tj
T*
() Tj
T*
ET
endstream
endobj
459 0 obj
<< /Length 2520 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    int sigprocmask\(int how, const sigset_t *set, sigset_t *oldset\);) Tj
T*
(    int sigemptyset\(sigset_t *set\);) Tj
T*
(    int sigfillset\(sigset_t *set\);) Tj
T*
(    int sigaddset\(sigset_t *set, int signum\);) Tj
T*
(    int sigdelset\(sigset_t *set, int signum\);) Tj
T*
(    //返回；如果成功则为 0，若出错则为 -1。) Tj
T*
() Tj
T*
(    int sigismember\(const sigset_t *set, int signum\);) Tj
T*
(    // 返回：若 signum 是 set 的成员则为 1，如果不是则为 0，若出错则为 -1。) Tj
T*
() Tj
T*
(sigprocmask 函数改变当前阻塞的信号集合（8.5.1 节中描述的 blocked 位向量）。具体的行为依赖于 how 的值：) Tj
T*
() Tj
T*
(* SIG\\_BLOCK：把 set 中的信号添加到 blocked 中（blocked=blocked \\| set）。) Tj
T*
(* SIG\\_UNBLOCK：从 blocked 中删除 set 中的信号（blocked=blocked &~set）。) Tj
T*
(* SIG\\_SETMASK：block=set。) Tj
T*
() Tj
T*
(如果 oldset 非空，那么 blocked 位向量之前的值保存在 oldset 中。) Tj
T*
() Tj
T*
(使用下述函数对 set 信号集合进行操作：sigemptyset 初始化 set 为空集合。sigfillset 函数把每个信号都添加到 set 中。sigaddset 函数把) Tj
T*
(signum 添加到 set，sigdelset 从 set 中删除 signum，如果 signum 是 set 的成员，那么 sigismember 返回 1，否则返回 0。) Tj
T*
() Tj
T*
(例如，图 8-32 展示了如何用 sigprocmask 来临时阻塞接收 SIGINT 信号。) Tj
T*
() Tj
T*
(    sigset_t mask, prev_mask;) Tj
T*
() Tj
T*
(    Sigemptyset\(&mask\);) Tj
T*
(    Sigaddset\(&mask, SIGINT\);) Tj
T*
() Tj
T*
(    /* Block SIGINT and save previous blocked set */) Tj
T*
(    Sigprocmask\(SIG_BLOCK, &mask, &prev_mask\);) Tj
T*
(    .) Tj
T*
(    .  // Code region that will not be interrupted by SIGINT) Tj
T*
(    .) Tj
T*
(    /* Restore previous blocked set, unblocking SIGINT */) Tj
T*
(    Sigprocmask\(SIG_SETMASK, &prev_mask, NULL\);) Tj
T*
() Tj
T*
(> 图 8-32 临时阻塞接收一个信号) Tj
T*
() Tj
T*
(8.5.5 编写信号处理程序) Tj
T*
() Tj
T*
() Tj
T*
(信号处理是 Linux 系统编程最棘手的一个问题。处理程序有几个属性使得它们很难推理分析：) Tj
T*
() Tj
T*
(1. 处理程序与主程序并发运行，共享同样的全局变量，因此可能与主程序和其他处理程序互相干扰；) Tj
T*
(2. 如何以及何时接收信号的规则常常有违人的直觉；) Tj
T*
(3. 不同的系统有不同的信号处理语义。) Tj
T*
ET
endstream
endobj
460 0 obj
<< /Length 3249 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(在本节中，我们将讲述这些问题，介绍编写安全、正确和可移植的信号处理程序的一些基本规则。) Tj
T*
() Tj
T*
(1. 安全的信号处理) Tj
T*
() Tj
T*
() Tj
T*
(信号处理程序很麻烦是因为它们和主程序以及其他信号处理程序并发地运行，正如我们在图 8-31) Tj
T*
(中看到的那样。如果处理程序和主程序并发地访问同样的全局数据结构，那么结果可能就不可预知，而且经常是致命的。) Tj
T*
() Tj
T*
(我们会在第 12 章详细讲述并发编程。这里我们的目标是给你一些保守的编写处理程序的原则，使得这些处理程序能安全地并发运行。如果你忽视这些原则，就可能有引入细微的并发错误的风险。如果) Tj
T*
(有这些错误，程序可能在绝大部分时候都能正确工作。然而当它出错的时候，就会错得不可预测和不可重复，这样是很难调试的。一定要防患于未然！) Tj
T*
() Tj
T*
(* G0. 处理程序要尽可能简单。避免麻烦的最好方法是保持处理程序尽可能小和简单。例如，处理程序可能只是简单地设置全局标志并立即返回；所有与接收信号相关的处理都由主程序执行，它周期) Tj
T*
(性地检查（并重置）这个标志。) Tj
T*
(* G1. 在处理程序中只调用异步信号安全的函数。所谓异步信号安全的函数（或简称安全的函数）能够被信号处理程序安全地调用，原因有二：要么它是可重入的（例如只访问局部变量，见) Tj
T*
(12.7.2 节），要么它不能被信号处理程序中断。图 8-33 列出了 Linux 保证安全的系统级函数。注意，许多常见的函数（例如 printf、sprintf、malloc 和) Tj
T*
(exit）都不在此列。) Tj
T*
() Tj
T*
(|  |  |  |  |) Tj
T*
(| :--- | :--- | :--- | :--- |) Tj
T*
(| \\_Exit | fexecve | poll | sigqueue |) Tj
T*
(| \\exit | fork | posix\\trace\\_event | sigset |) Tj
T*
(| abort | fstat | pselect | sigsuspend |) Tj
T*
(| accept | fstatat | raise | sleep |) Tj
T*
(| access | fsync | read | sockatmark |) Tj
T*
(| aio\\_error | ftruncate | readlink | socket |) Tj
T*
(| aio\\_return | futimens | readlinkat | socketpair |) Tj
T*
(| aio\\_suspend | getegid | recv | stat |) Tj
T*
(| alarm | geteuid | recvfrom | symlink |) Tj
T*
(| bind | getgid | recvmsg | symlinkat |) Tj
T*
(| cfgetispeed | getgroups | rename | tcdrain |) Tj
T*
(| cfgetospeed | getpeername | renameat | tcflow |) Tj
T*
(| cfsetispeed | getpgrp | rmdir | tcflush |) Tj
T*
(| cfsetospeed | getpid | select | tcgetattr |) Tj
T*
(| chdir | getppid | sem\\_post | tcgetpgrp |) Tj
T*
(| chmod | getsockname | send | tcsendbreak |) Tj
T*
(| chown | getsockopt | sendmsg | tcsetattr |) Tj
T*
(| clock\\_gettime | getuid | sendto | tcsetpgrp |) Tj
T*
(| close | kill | setgid | time |) Tj
T*
(| connect | link | setpgid | timer\\_getoverrun |) Tj
T*
(| creat | linkat | setsid | timer\\_gettime |) Tj
T*
(| dup | listen | setsockopt | timer\\_settime |) Tj
T*
(| dup2 | lseek | setuid | times |) Tj
T*
(| execl | lstat | shutdown | umask |) Tj
T*
(| execle | mkdir | sigaction | uname |) Tj
T*
(| execv | mkdirat | sigaddset | unlink |) Tj
T*
ET
endstream
endobj
461 0 obj
<< /Length 2312 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(| execve | mkfifo | sigdelset | unlinkat |) Tj
T*
(| faccessat | mkfifoat | sigemptyset | utime |) Tj
T*
(| fchmod | mknod | sigfillset | utimensat |) Tj
T*
(| fchmodat | mknodat | sigismember | utimes |) Tj
T*
(| fchown | open | signal | wait |) Tj
T*
(| fchownat | openat | sigpause | waitpid |) Tj
T*
(| fcntl | pause | sigpending | write |) Tj
T*
(| fdatasync | pipe | sigprocmask |  |) Tj
T*
() Tj
T*
(> 图 8-33 异步信号安全的函数（来源：man 7 signal。数据来自 Linux Foundation）) Tj
T*
() Tj
T*
(信号处理程序中产生输出唯一安全的方法是使用 write 函数（见 10.1 节）。特别地，调用 printf 或 sprintf) Tj
T*
(是不安全的。为了绕开这个不幸的限制，我们开发一些安全的函数，称为 SIO（安全的 I/O）包，可以用来在信号处理程序中打印简单的消息。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    ssize_t sio_putl\(long v\);) Tj
T*
(    ssize_t sio_puts\(char s[]\);) Tj
T*
(    // 返回：如果成功则为传送的字节数，如果出错，则为 -1。) Tj
T*
() Tj
T*
(    void sio_error\(char s[]\);) Tj
T*
(    // 返回：空。) Tj
T*
() Tj
T*
(sio\\putl 和 sio\\puts 函数分别向标准输出传送一个 long 类型数和一个字符串。sio\\_error 函数打印一条错误消息并终止。) Tj
T*
() Tj
T*
(图 8-34 给出的是 SIO 包的实现，它使用了 csapp.c 中两个私有的可重入函数。第 3 行的 sio\\strlen 函数返回字符串 s 的长度。第 10 行的) Tj
T*
(sio\\ltoa 函数基于来自【61】的 itoa 函数，把 v 转换成它的基 b 字符串表示，保存在 s 中。第 17 行的 \\_exit 函数是 exit) Tj
T*
(的一个异步信号安全的变种。) Tj
T*
() Tj
T*
(    ssize_t sio_puts\(char s[]\) /* Put string */) Tj
T*
(    {) Tj
T*
(        return write\(STDOUT_FILENO, s, sio_strlen\(s\)\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    ssize_t sio_putl\(long v\) /* Put long */) Tj
T*
(    {) Tj
T*
(        char s[128];) Tj
T*
() Tj
T*
(        sio_ltoa\(v, s, 10\); /* Based on K&R itoa\(\) */) Tj
T*
(        return sio_puts\(s\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    void sio_error\(char s[]\) /* Put error message and exit */) Tj
T*
(    {) Tj
T*
(        sio_puts\(s\);) Tj
T*
(        _exit\(1\);) Tj
T*
ET
endstream
endobj
462 0 obj
<< /Length 4081 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    }) Tj
T*
() Tj
T*
(> 图 8-34 信号处理程序的 SIO（安全 I/O）包) Tj
T*
() Tj
T*
(图 8-35 给出了图 8-30 中 SIGINT 处理程序的一个安全的版本。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void sigint_handler\(int sig\) /* Safe SIGINT handler */) Tj
T*
(    {) Tj
T*
(        Sio_puts\("Caught SIGINT!\\n"\); /* Safe output */) Tj
T*
(        _exit\(0\);                     /* Safe exit */) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-35 图 8-30 的 SIGINT 处理程序的一个安全版本) Tj
T*
() Tj
T*
(* G2. 保存和恢复 errno。许多 Linux 异步信号安全的函数都会在出错返回时设置 errno。在处理程序中调用这样的函数可能会干扰主程序中其他依赖于 errno) Tj
T*
(的部分。解决方法是在进入处理程序时把 errno 保存在一个局部变量中，在处理程序返回前恢复它。注意，只有在处理程序要返回时才有此必要。如果处理程序调用 \\_exit) Tj
T*
(终止该进程，那么就不需要这样做了。) Tj
T*
(* G3. 阻塞所有的信号，保护对共享全局数据结构的访问。如果处理程序和主程序或其他处理程序共享一个全局数据结构，那么在访问（读或者写）该数据结构时，你的处理程序和主程序应该暂时阻) Tj
T*
(塞所有的信号。这条规则的原因是从主程序访问一个数据结构 d 通常需要一系列的指令，如果指令序列被访问次的处理程序中断，那么处理程序可能会发现 d) Tj
T*
(的状态不一致，得到不可预知的结果。在访问 d 时暂时阻塞信号保证了处理程序不会中断该指令序列。) Tj
T*
(* G4. 用 volatile 声明全局变量。考虑一个处理程序和一个 main 函数，它们共享一个全局变量 g。处理程序更新 g，main 周期性地读) Tj
T*
(g。对于一个优化编译器而言，main 中 g 的值看上去从来没有变化过，因此使用缓存在寄存器中 g 的副本来满足对 g 的每次引用是很安全的。如果这样，main) Tj
T*
(函数可能永远都无法看到处理程序更新过的值。) Tj
T*
() Tj
T*
(  可以用 volatile 类型限定符来定义一个变量，告诉编译器不要缓存这个变量。例如：) Tj
T*
() Tj
T*
(  volatile int g;) Tj
T*
() Tj
T*
(  volatile 限定符强迫编译器每次在代码中引用 g 时，都要从内存中读取 g 的值。一般来说，和其他所有共享数据结构一样，应该暂时阻塞信号，保护每次对全局变量的访问。) Tj
T*
() Tj
T*
(* G5. 用 sig\\atomic\\t) Tj
T*
(声明标志。在常见的处理程序设计中，处理程序会写全局标志来记录收到了信号。主程序周期性地读这个标志，响应信号，再清除该标志。对于通过这种方式来共享的标志，C 提供一种整型数据类型) Tj
T*
(sig\\atomic\\t，对它的读和写保证会是原子的（不可中断的），因为可以用一条指令来实现它们：) Tj
T*
() Tj
T*
(  volatile sigatomict flag;) Tj
T*
() Tj
T*
(  因为它们是不可中断的，所以可以安全地读和写 sig\\atomic\\t 变量，而不需要暂时阻塞信号。注意，这里对原子性的保证只适用于单个的读和写，不适用于像 flag++ 或) Tj
T*
(  flag=flag+10 这样的更新，它们可能需要多条指令。) Tj
T*
() Tj
T*
(要记住我们这里讲述的规则是保守的，也就是说它们不总是严格必需的。例如，如果你知道处理程序绝对不会修改 errno，那么就不需要保存和恢复 errno。或者如果你可以证明) Tj
T*
(printf 的实例都不会被处理程序中断，那么在处理程序中调用 printf) Tj
T*
(就是安全的。对共享全局数据结构的访问也是同样。不过，一般来说这种断言很难证明。所以我们建议你采用保守的方法，遵循这些规则，使得处理程序尽可能简单，调用安全函数，保存和恢复) Tj
T*
(errno，保护对共享数据结构的访问，并使用 volatile 和 sig\\atomic\\t。) Tj
T*
() Tj
T*
ET
endstream
endobj
463 0 obj
<< /Length 2914 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(2. 正确的信号处理) Tj
T*
() Tj
T*
() Tj
T*
(信号的一个与直觉不符的方面是未处理的信号是不排队的。因为 pending 位向量中每种类型的信号只对应有一位，所以每种类型最多只能有一个未处理的信号。因此，如果两个类型 k) Tj
T*
(的信号发送给一个目的进程，而因为目的进程当前正在执行信号 k 的处理程序，所以信号 k) Tj
T*
(被阻塞了，那么第二个信号就简单地被丢弃了；它不会排队。关键思想是如果存在一个未处理的信号就表明至少有一个信号到达了。) Tj
T*
() Tj
T*
(要了解这样会如何影响正确性，来看一个简单的应用，它本质上类似于像 shell 和 Web 服务器这样的真实程序。基本的结构是父进程创建一些子进程，这些子进程各自独立运行一段时间，然) Tj
T*
(后终止。父进程必须回收子进程以避免在系统中留下僵死进程。但是我们还希望父进程能够在子进程运行时自由地去做其他的工作。所以，我们决定用 SIGCHLD) Tj
T*
(处理程序来回收子进程，而不是显式地等待子进程终止。（回想一下，只要有一个子进程终止或者停止，内核就会发送一个 SIGCHLD 信号给父进程。）) Tj
T*
() Tj
T*
(图 8-36 展示了我们的初次尝试。父进程设置了一个 SIGCHLD 处理程序，然后创建了 3) Tj
T*
(个子进程。同时，父进程等待来自终端的一个输入行，随后处理它。这个处理被模型化为一个无限循环。当每个子进程终止时，内核通过发送一个 SIGCHLD 信号通知父进程。父进程捕获这个) Tj
T*
(SIGCHLD 信号，回收一个子进程，做一些其他的清理工作（模型化为 sleep 语句），然后返回。) Tj
T*
() Tj
T*
(    /* WARNING: This code is buggy! */) Tj
T*
() Tj
T*
(    void handler1\(int sig\)) Tj
T*
(    {) Tj
T*
(        int olderrno = errno;) Tj
T*
() Tj
T*
(        if \(\(waitpid\(-1, NULL, 0\)\) < 0\)) Tj
T*
(            sio_error\("waitpid error"\);) Tj
T*
(        Sio_puts\("Handler reaped child\\n"\);) Tj
T*
(        Sleep\(1\);) Tj
T*
(        errno = olderrno;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int i, n;) Tj
T*
(        char buf[MAXBUF];) Tj
T*
() Tj
T*
(        if \(signal\(SIGCHLD, handler1\) == SIG_ERR\)) Tj
T*
(            unix_error\("signal error"\);) Tj
T*
() Tj
T*
(        /* Parent creates children */) Tj
T*
(        for \(i = 0; i < 3; i++\) {) Tj
T*
(            if \(Fork\(\) == 0\) {) Tj
T*
(                printf\("Hello from child %d\\n", \(int\)getpid\(\)\);) Tj
T*
(                exit\(0\);) Tj
T*
(            }) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Parent waits for terminal input and then processes it */) Tj
T*
(        if \(\(n = read\(STDIN_FILENO, buf, sizeof\(buf\)\)\) < 0\)) Tj
T*
ET
endstream
endobj
464 0 obj
<< /Length 2975 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            unix_error\("read"\);) Tj
T*
() Tj
T*
(        printf\("Parent processing input\\n"\);) Tj
T*
(        while \(1\)) Tj
T*
(            ;) Tj
T*
() Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-36 signal1：这个程序是有缺陷的，因为它假设信号是排队的) Tj
T*
() Tj
T*
(图 8-36 中的 signal1 程序看起来相当简单。然而，当在 Linux 系统上运行它时，我们得到如下输出：) Tj
T*
() Tj
T*
(    linux> ./signal1) Tj
T*
(    Hello from child 14073) Tj
T*
(    Hello from child 14074) Tj
T*
(    Hello from child 14075) Tj
T*
(    Handler reaped child) Tj
T*
(    Handler reaped child) Tj
T*
(    CR) Tj
T*
(    Parent processing input) Tj
T*
() Tj
T*
(从输出中我们注意到，尽管发送了 3 个 SIGCHLD 信号给父进程，但是其中只有两个信号被接收了，因此父进程只是回收了两个子进程。如果挂起父进程，我们看到，实际上子进程) Tj
T*
(14075 没有被回收，它成了一个僵死进程（在 ps 命令的输出中由字符串 “defunct” 表明）：) Tj
T*
() Tj
T*
(    Ctrl+Z) Tj
T*
(    Suspended) Tj
T*
(    linux> ps t) Tj
T*
(      PID TTY   STAT   TIME COMMAND) Tj
T*
(      .) Tj
T*
(      .) Tj
T*
(      .) Tj
T*
(    14072 pts/3 T      0:02 ./signal1) Tj
T*
(    14075 pts/3 Z      0:00 [signal1] <defunct>) Tj
T*
(    14076 pts/3 R+     0:00 ps t) Tj
T*
() Tj
T*
(哪里出错了呢？问题就在于我们的代码没有解决信号不会排队等待这样的情况。所发生的情况是：父进程接收并捕获了第一个信号。当处理程序还在处理第一个信号时，第二个信号就传送并添加到了待处理) Tj
T*
(信号集合里。然而，因为 SIGCHLD 信号被 SIGCHLD) Tj
T*
(处理程序阻塞了，所以第二个信号就不会被接收。此后不久，就在处理程序还在处理第一个信号时，第三个信号到达了。因为已经有了一个待处理的 SIGCHLD，第三个 SIGCHLD) Tj
T*
(信号会被丢弃。一段时间之后，处理程序返回，内核注意到有一个待处理的 SIGCHLD) Tj
T*
(信号，就迫使父进程接收这个信号。父进程捕获这个信号，并第二次执行处理程序。在处理程序完成对第二个信号的处理之后，已经没有待处理的 SIGCHLD) Tj
T*
(信号了，而且也绝不会再有，因为第三个 SIGCHLD 的所有信息都已经丢失了。由此得到的重要教训是，不可以用信号来对其他进程中发生的事件计数。) Tj
T*
() Tj
T*
(为了修正这个问题，我们必须回想一下，存在一个待处理的信号只是暗示自进程最后一次收到一个信号以来，至少已经有一个这种类型的信号被发送了。所以我们必须修改 SIGCHLD) Tj
T*
(的处理程序，使得每次 SIGCHLD 处理程序被调用时，回收尽可能多的僵死子进程。图 8-37 展示了修改后的 SIGCHLD 处理程序。) Tj
T*
() Tj
T*
ET
endstream
endobj
465 0 obj
<< /Length 1524 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    void handler2\(int sig\)) Tj
T*
(    {) Tj
T*
(        int olderrno = errno;) Tj
T*
() Tj
T*
(        while \(waitpid\(-1, NULL, 0\) > 0\) {) Tj
T*
(            Sio_puts\("Handler reaped child\\n"\);) Tj
T*
(        }) Tj
T*
(        if \(errno != ECHILD\)) Tj
T*
(            Sio_error\("waitpid error"\);) Tj
T*
(        Sleep\(1\);) Tj
T*
(        errno = olderrno;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-37 signal2：图 8-36 的一个改进版本，它能够正确解决信号不会排队等待的情况) Tj
T*
() Tj
T*
(当我们在 Linux 系统上运行 signal2 时，它现在可以正确地回收所有的僵死子进程了：) Tj
T*
() Tj
T*
(    linux> ./signal2) Tj
T*
(    Hello from child 15237) Tj
T*
(    Hello from child 15238) Tj
T*
(    Hello from child 15239) Tj
T*
(    Handler reaped child) Tj
T*
(    Handler reaped child) Tj
T*
(    Handler reaped child) Tj
T*
(    CR) Tj
T*
(    Parent processing input) Tj
T*
() Tj
T*
(练习题 8.8) Tj
T*
() Tj
T*
() Tj
T*
(下面这个程序的输出是什么？) Tj
T*
() Tj
T*
(    volatile long counter = 2;) Tj
T*
() Tj
T*
(    void handler1\(int sig\)) Tj
T*
(    {) Tj
T*
(        sigset_t mask, prev_mask;) Tj
T*
() Tj
T*
(        Sigfillset\(&mask\);) Tj
T*
(        Sigprocmask\(SIG_BLOCK, &mask, &prev_mask\);  /* Block sigs */) Tj
T*
(        Sio_putl\(--counter\);) Tj
T*
(        Sigprocmask\(SIG_SETMASK, &prev_mask, NULL\); /* Restore sigs */) Tj
T*
() Tj
T*
(        _exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
ET
endstream
endobj
466 0 obj
<< /Length 2697 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        pid_t pid;) Tj
T*
(        sigset_t mask, prev_mask;) Tj
T*
() Tj
T*
(        printf\("%ld", counter\);) Tj
T*
(        fflush\(stdout\);) Tj
T*
() Tj
T*
(        signal\(SIGUSR1, handler1\);) Tj
T*
(        if \(\(pid = Fork\(\)\) == 0\) {) Tj
T*
(            while \(1\) {};) Tj
T*
(        }) Tj
T*
(        Kill\(pid, SIGUSR1\);) Tj
T*
(        Waitpid\(-1, NULL, 0\);) Tj
T*
() Tj
T*
(        Sigfillset\(&mask\);) Tj
T*
(        Sigprocmask\(SIG_BLOCK, &mask, &prev_mask\);  /* Block sigs */) Tj
T*
(        printf\("%ld", ++counter\);) Tj
T*
(        Sigprocmask\(SIG_SETMASK, &prev_mask, NULL\); /* Restore sigs */) Tj
T*
() Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(这个程序打印字符串 “213”，这是卡内基—梅隆大学 CS：APP 课程的缩写名。父进程开始时打印) Tj
T*
(“2”，然后创建子进程，子进程会陷入一个无限循环。然后父进程向子进程发送一个信号，并等待它终止。子进程捕获这个信号（中断这个无限循环），对计数器值（从初始值 2）减一，打印) Tj
T*
(“1”，然后终止。在父进程回收子进程之后，它对计数器值（从初始值 2）加一，打印 “3”，并且终止。) Tj
T*
() Tj
T*
(3. 可移植的信号处理) Tj
T*
() Tj
T*
() Tj
T*
(Unix 信号处理的另一个缺陷在于不同的系统有不同的信号处理语义。例如：) Tj
T*
() Tj
T*
(* signal 函数的语义各有不同。有些老的 Unix 系统在信号 k 被处理程序捕获之后就把对信号 k 的反应恢复到默认值。在这些系统上，每次运行之后，处理程序必须调用) Tj
T*
(signal 函数，显式地重新设置它自己。) Tj
T*
(* 系统调用可以被中断。像 read、write 和 accept 这样的系统调用潜在地会阻塞进程一段较长的时间，称为慢速系统调用。在某些较早版本的 Unix) Tj
T*
(系统中，当处理程序捕获到一个信号时，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将 errno 设置为) Tj
T*
(EINTR。在这些系统上，程序员必须包括手动重启被中断的系统调用的代码。) Tj
T*
() Tj
T*
(要解决这些问题，Posix 标准定义了 sigaction 函数，它允许用户在设置信号处理时，明确指定他们想要的信号处理语义。) Tj
T*
() Tj
T*
(    #include <signal.h>) Tj
T*
() Tj
T*
(    int sigaction\(int signum, struct sigaction *act,) Tj
T*
(                  struct sigaction *oldact\);) Tj
T*
(    // 返回：若成功则为 0，若出错则为 -1。) Tj
T*
() Tj
T*
ET
endstream
endobj
467 0 obj
<< /Length 2939 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(sigaction 函数运用并不广泛，因为它要求用户设置一个复杂结构的条目。一个更简洁的方式，最初是由 W. Richard Stevens) Tj
T*
(提出的【110】，就是定义一个包装函数，称为 Signal，它调用 sigaction。图 8-38 给出了 Signal 的定义，它的调用方式与 signal) Tj
T*
(函数的调用方式一样。) Tj
T*
() Tj
T*
(    handler_t *Signal\(int signum, handler_t *handler\)) Tj
T*
(    {) Tj
T*
(        struct sigaction action, old_action;) Tj
T*
() Tj
T*
(        action.sa_handler = handler;) Tj
T*
(        sigemptyset\(&action.sa_mask\); /* Block sigs of type being handled */) Tj
T*
(        action.sa_flags = SA_RESTART; /* Restart syscalls if possible */) Tj
T*
() Tj
T*
(        if \(sigaction\(signum, &action, &old_action\) < 0\)) Tj
T*
(            unix_error\("Signal error"\);) Tj
T*
(        return \(old_action.sa_handler\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-38 Signal：sigaction 的一个包装函数，它提供在 Posix 兼容系统上的可移植的信号处理) Tj
T*
() Tj
T*
(Signal 包装函数设置了一个信号处理程序，其信号处理语义如下：) Tj
T*
() Tj
T*
(* 只有这个处理程序当前正在处理的那种类型的信号被阻塞。) Tj
T*
(* 和所有信号实现一样，信号不会排队等待。) Tj
T*
(* 只要可能，被中断的系统调用会自动重启。) Tj
T*
(* 一旦设置了信号处理程序，它就会一直保持，直到 Signal 带着 handler 参数为 SIG\\IGN 或者 SIG\\DFL 被调用。) Tj
T*
() Tj
T*
(我们在所有的代码中实现 Signal 包装函数。) Tj
T*
() Tj
T*
(8.5.6 同步流以避免讨厌的并发错误) Tj
T*
() Tj
T*
() Tj
T*
(如何编写读写相同存储位置的并发流程序的问题，困扰着数代计算机科学家。一般而言，流可能交错的数量与指令的数量呈指数关系。这些交错中的一些会产生正确的结果，而有些则不会。基本的问题是以) Tj
T*
(某种方式同步并发流，从而得到最大的可行的交错的集合，每个可行的交错都能得到正确的结果。) Tj
T*
() Tj
T*
(并发编程是一个很深且很重要的问题，我们将在第 12 章中更详细地讨论。不过，在本章中学习的有关异常控制流的知识，可以让你感觉一下与并发相关的有趣的智力挑战。例如，考虑图 8-39) Tj
T*
(中的程序，它总结了一个典型的 Unixshell 的结构。父进程在一个全局作业列表中记录着它的当前子进程，每个作业一个条目。addjob 和 deletejob) Tj
T*
(函数分别向这个作业列表添加和从中删除作业。) Tj
T*
() Tj
T*
(    /* WARNING: This code is buggy! */) Tj
T*
(    void handler\(int sig\)) Tj
T*
(    {) Tj
T*
(        int olderrno = errno;) Tj
T*
(        sigset_t mask_all, prev_all;) Tj
T*
(        pid_t pid;) Tj
T*
() Tj
T*
(        Sigfillset\(&mask_all\);) Tj
T*
ET
endstream
endobj
468 0 obj
<< /Length 3237 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        while \(\(pid = waitpid\(-1, NULL, 0\)\) > 0\) { /* Reap a zombie child */) Tj
T*
(            Sigprocmask\(SIG_BLOCK, &mask_all, &prev_all\);) Tj
T*
(            deletejob\(pid\); /* Delete the child from the job list */) Tj
T*
(            Sigprocmask\(SIG_SETMASK, &prev_all, NULL\);) Tj
T*
(        }) Tj
T*
(        if \(errno != ECHILD\)) Tj
T*
(            Sio_error\("waitpid error"\);) Tj
T*
(        errno = olderrno;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        int pid;) Tj
T*
(        sigset_t mask_all, prev_all;) Tj
T*
() Tj
T*
(        Sigfillset\(&mask_all\);) Tj
T*
(        Signal\(SIGCHLD, handler\);) Tj
T*
(        initjobs\(\); /* Initialize the job list */) Tj
T*
() Tj
T*
(        while \(1\) {) Tj
T*
(            if \(\(pid = Fork\(\)\) == 0\) { /* Child process */) Tj
T*
(                Execve\("/bin/date", argv, NULL\);) Tj
T*
(            }) Tj
T*
(            Sigprocmask\(SIG_BLOCK, &mask_all, &prev_all\); /* Parent process */) Tj
T*
(            addjob\(pid\);  /* Add the child to the job list */) Tj
T*
(            Sigprocmask\(SIG_SETMASK, &prev_all, NULL\);) Tj
T*
(        }) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-39 一个具有细微同步错误的 shell 程序。如果子进程在父进程能够开始运行前就结束了，那么 addjob 和 deletejob 会以错误的方式被调用) Tj
T*
() Tj
T*
(当父进程创建一个新的子进程后，它就把这个子进程添加到作业列表中。当父进程在 SIGCHLD 处理程序中回收一个终止的（僵死）子进程时，它就从作业列表中删除这个子进程。) Tj
T*
() Tj
T*
(信一看，这段代码是对的。不幸的是，可能发生下面这样的事件序列：) Tj
T*
() Tj
T*
(1. 父进程执行 fork 函数，内核调度新创建的子进程运行，而不是父进程。) Tj
T*
(2. 在父进程能够再次运行之前，子进程就终止，并且变成一个僵死进程，使得内核传递一个 SIGCHLD 信号给父进程。) Tj
T*
(3. 后来，当父进程再次变成可运行但又在它执行之前，内核注意到有未处理的 SIGCHLD 信号，并通过在父进程中运行处理程序接收这个信号。) Tj
T*
(4. 信号处理程序回收终止的子进程，并调用 deletejob，这个函数什么也不做，因为父进程还没有把该子进程添加到列表中。) Tj
T*
(5. 在处理程序运行完毕后，内核运行父进程，父进程从 fork 返回，通过调用 add-job 错误地把（不存在的）子进程添加到作业列表中。) Tj
T*
() Tj
T*
(因此，对于父进程的 main 程序和信号处理流的某些交错，可能会在 addjob 之前调用) Tj
T*
(deletejob。这导致作业列表中出现一个不正确的条目，对应于一个不再存在而且永远也不会被删除的作业。另一方面，也有一些交错，事件按照正确的顺序发生。例如，如果在 fork) Tj
T*
(调用返回时，内核刚好调度父进程而不是子进程运行，那么父进程就会正确地把子进程添加到作业列表中，然后子进程终止，信号处理函数把该作业从列表中删除。) Tj
T*
() Tj
T*
ET
endstream
endobj
469 0 obj
<< /Length 2684 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(这是一个称为竞争（race）的经典同步错误的示例。在这个情况中，main 函数中调用 addjob 和处理程序中调用 deletejob 之间存在竞争。如果 addjob 赢得进展) Tj
T*
(，那么结果就是正确的。如果它没有，那么结果就是错误的。这样的错误非常难以调试，因为几乎不可能测试所有的交错。你可能运行这段代码十亿次，也没有一次错误，但是下一次测试却导致引发竞争的) Tj
T*
(交错。) Tj
T*
() Tj
T*
(图 8-40 展示了消除图 8-39 中竞争的一种方法。通过在调用 fork 之前，阻塞 SIGCHLD 信号，然后在调用 addjob) Tj
T*
(之后取消阻塞这些信号，我们保证了在子进程被添加到作业列表中之后回收该子进程。注意，子进程继承了它们父进程的被阻塞集合，所以我们必须在调用 execve) Tj
T*
(之前，小心地解除子进程中阻塞的 SIGCHLD 信号。) Tj
T*
() Tj
T*
(    void handler\(int sig\)) Tj
T*
(    {) Tj
T*
(        int olderrno = errno;) Tj
T*
(        sigset_t mask_all, prev_all;) Tj
T*
(        pid_t pid;) Tj
T*
() Tj
T*
(        Sigfillset\(&mask_all\);) Tj
T*
(        while \(\(pid = waitpid\(-1, NULL, 0\)\) > 0\) { /* Reap a zombie child */) Tj
T*
(            Sigprocmask\(SIG_BLOCK, &mask_all, &prev_all\);) Tj
T*
(            deletejob\(pid\); /* Delete the child from the job list */) Tj
T*
(            Sigprocmask\(SIG_SETMASK, &prev_all, NULL\);) Tj
T*
(        }) Tj
T*
(        if \(errno != ECHILD\)) Tj
T*
(            Sio_error\("waitpid error"\);) Tj
T*
(        errno = olderrno;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        int pid;) Tj
T*
(        sigset_t mask_all, mask_one, prev_one;) Tj
T*
() Tj
T*
(        Sigfillset\(&mask_all\);) Tj
T*
(        Sigemptyset\(&mask_one\);) Tj
T*
(        Sigaddset\(&mask_one, SIGCHLD\);) Tj
T*
(        Signal\(SIGCHLD, handler\);) Tj
T*
(        initjobs\(\); /* Initialize the job list */) Tj
T*
() Tj
T*
(        while \(1\) {) Tj
T*
(            Sigprocmask\(SIG_BLOCK, &mask_one, &prev_one\); /* Block SIGCHLD */) Tj
T*
(            if \(\(pid = Fork\(\)\) == 0\) { /* Child process */) Tj
T*
(                Sigprocmask\(SIG_SETMASK, &prev_one, NULL\); /* Unblock SIGCHLD */) Tj
T*
(                Execve\("/bin/date", argv, NULL\);) Tj
T*
(            }) Tj
T*
(            Sigprocmask\(SIG_BLOCK, &mask_all, NULL\); /* Parent process */) Tj
T*
(            addjob\(pid\); /* Add the child to the job list */) Tj
T*
(            Sigprocmask\(SIG_SETMASK, &prev_one, NULL\); /* Unblock SIGCHLD */) Tj
T*
(        }) Tj
T*
ET
endstream
endobj
470 0 obj
<< /Length 2022 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-40 用 sigprocmask 来同步进程。在这个例子中，父进程保证在相应的 deletejob 之前执行 addjob) Tj
T*
() Tj
T*
(8.5.7 显式地等待信号) Tj
T*
() Tj
T*
() Tj
T*
(有时候主程序需要显式地等待某个信号处理程序运行。例如，当 Linux shell 创建一个前台作业时，在接收下一条用户命令之前，它必须等待作业终止，被 SIGCHLD) Tj
T*
(处理程序回收。) Tj
T*
() Tj
T*
(图 8-41 给出了一个基本的思路。父进程设置 SIGINT 和 SIGCHLD 的处理程序，然后进入一个无限循环。它阻塞 SIGCHLD 信号，避免 8.5.6) Tj
T*
(节中讨论过的父进程和子进程之间的竞争。创建了子进程之后，把 pid 重置为 0，取消阻塞 SIGCHLD，然后以循环的方式等待 pid) Tj
T*
(变为非零。子进程终止后，处理程序回收它，把它非零的 PID 赋值给全局 pid 变量。这会终止循环，父进程继续其他的工作，然后开始下一次迭代。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    volatile sig_atomic_t pid;) Tj
T*
() Tj
T*
(    void sigchld_handler\(int s\)) Tj
T*
(    {) Tj
T*
(        int olderrno = errno;) Tj
T*
(        pid = waitpid\(-1, NULL, 0\);) Tj
T*
(        errno = olderrno;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    void sigint_handler\(int s\)) Tj
T*
(    {) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        sigset_t mask, prev;) Tj
T*
() Tj
T*
(        Signal\(SIGCHLD, sigchld_handler\);) Tj
T*
(        Signal\(SIGINT, sigint_handler\);) Tj
T*
(        Sigemptyset\(&mask\);) Tj
T*
(        Sigaddset\(&mask, SIGCHLD\);) Tj
T*
() Tj
T*
(        while \(1\) {) Tj
T*
(            Sigprocmask\(SIG_BLOCK, &mask, &prev\); /* Block SIGCHLD */) Tj
T*
(            if \(Fork\(\) == 0\) /* Child */) Tj
T*
(                exit\(0\);) Tj
T*
() Tj
T*
(            /* Parent */) Tj
T*
(            pid = 0;) Tj
T*
ET
endstream
endobj
471 0 obj
<< /Length 2455 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            Sigprocmask\(SIG_SETMASK, &prev, NULL\); /* Unblock SIGCHLD */) Tj
T*
() Tj
T*
(            /* Wait for SIGCHLD to be received \(wasteful\) */) Tj
T*
(            while \(!pid\)) Tj
T*
(                ;) Tj
T*
() Tj
T*
(            /* Do some work after receiving SIGCHLD */) Tj
T*
(            printf\("."\);) Tj
T*
(        }) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-41 用循环来等待信号。这段代码正确，但循环是一种浪费) Tj
T*
() Tj
T*
(当这段代码正确执行的时候，循环在浪费处理器资源。我们可能会想要修补这个问题，在循环体内插入 pause：) Tj
T*
() Tj
T*
(    while \(!pid\) /* Race! */) Tj
T*
(        pause\(\);) Tj
T*
() Tj
T*
(注意，我们仍然需要一个循环，因为收到一个或多个 SIGINT 信号，pause 会被中断。不过，这段代码有很严重的竞争条件：如果在 while 测试后和 pause 之前收到) Tj
T*
(SIGCHLD 信号，pause 会永远睡眠。) Tj
T*
() Tj
T*
(另一个选择是用 sleep 替换 pause：) Tj
T*
() Tj
T*
(    while \(!pid\) /* Too slow! */) Tj
T*
(        sleep\(1\);) Tj
T*
() Tj
T*
(当这段代码正确执行时，它太慢了。如果在 while 之后 pause 之前收到信号，程序必须等相当长的一段时间才会再次检查循环的终止条件。使用像 nanosleep) Tj
T*
(这样更高精度的休眠函数也是不可接受的，因为没有很好的方法来确定休眠的间隔。间隔太小，循环会太浪费。间隔太大，程序又会太慢。) Tj
T*
() Tj
T*
(合适的解决方法是使用 sigsuspend。) Tj
T*
() Tj
T*
(    #include <signal.h>) Tj
T*
() Tj
T*
(    int sigsuspend\(const sigset_t *mask\);) Tj
T*
() Tj
T*
(    // 返回：-1) Tj
T*
() Tj
T*
(sigsuspend 函数暂时用 mask 替换当前的阻塞集合，然后挂起该进程，直到收到一个信号，其行为要么是运行一个处理程序，要么是终止该进程。如果它的行为是终止，那么该进程不从) Tj
T*
(sigsuspend 返回就直接终止。如果它的行为是运行一个处理程序，那么 sigsuspend 从处理程序返回，恢复调用 sigsuspend 时原有的阻塞集合。) Tj
T*
() Tj
T*
(sigsuspend 函数等价于下述代码的原子的（不可中断的）版本：) Tj
T*
() Tj
T*
(    sigprocmask\(SIG_BLOCK, &mask, &prev\);) Tj
T*
(    pause\(\);) Tj
T*
(    sigprocmask\(SIG_SETMASK, &prev, NULL\);) Tj
T*
ET
endstream
endobj
472 0 obj
<< /Length 2182 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(原子属性保证对 sigprocmask（第 1 行）和 pause（第 2 行）的调用总是一起发生的，不会被中断。这样就消除了潜在的竞争，即在调用 sigprocmask) Tj
T*
(之后但在调用 pause 之前收到了一个信号。) Tj
T*
() Tj
T*
(图 8-42 展示了如何使用 sigsuspend 来替代图 8-41 中的循环。在每次调用 sigsuspend 之前，都要阻塞 SIGCHLD。sigsuspend) Tj
T*
(会暂时取消阻塞 SIGCHLD，然后休眠，直到父进程捕获信号。在返回之前，它会恢复原始的阻塞集合，又再次阻塞 SIGCHLD。如果父进程捕获一个 SIGINT) Tj
T*
(信号，那么循环测试成功，下一次迭代又再次调用 sigsuspend。如果父进程捕获一个 SIGCHLD，那么循环测试失败，会退出循环。此时，SIGCHLD) Tj
T*
(是被阻塞的，所以我们可以可选地取消阻塞 SIGCHLDO 在真实的有后台作业需要回收的 shell 中这样做可能会有用处。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    volatile sig_atomic_t pid;) Tj
T*
() Tj
T*
(    void sigchld_handler\(int s\)) Tj
T*
(    {) Tj
T*
(        int olderrno = errno;) Tj
T*
(        pid = Waitpid\(-1, NULL, 0\);) Tj
T*
(        errno = olderrno;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    void sigint_handler\(int s\)) Tj
T*
(    {) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        sigset_t mask, prev;) Tj
T*
() Tj
T*
(        Signal\(SIGCHLD, sigchld_handler\);) Tj
T*
(        Signal\(SIGINT, sigint_handler\);) Tj
T*
(        Sigemptyset\(&mask\);) Tj
T*
(        Sigaddset\(&mask, SIGCHLD\);) Tj
T*
() Tj
T*
(        while \(1\) {) Tj
T*
(            Sigprocmask\(SIG_BLOCK, &mask, &prev\); /* Block SIGCHLD */) Tj
T*
(            if \(Fork\(\) == 0\) /* Child */) Tj
T*
(                exit\(0\);) Tj
T*
() Tj
T*
(            /* Wait for SIGCHLD to be received */) Tj
T*
(            pid = 0;) Tj
T*
(            while \(!pid\)) Tj
T*
(                sigsuspend\(&prev\);) Tj
T*
() Tj
T*
(            /* Optionally unblock SIGCHLD */) Tj
T*
(            Sigprocmask\(SIG_SETMASK, &prev, NULL\);) Tj
T*
() Tj
T*
ET
endstream
endobj
473 0 obj
<< /Length 2417 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            /* Do some work after receiving SIGCHLD */) Tj
T*
(            printf\("."\);) Tj
T*
(        }) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-42 用 sigsuspend 来等待信号) Tj
T*
() Tj
T*
(sigsuspend 版本比起原来的循环版本不那么浪费，避免了引入 pause 带来的竞争，又比 sleep 更有效率。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(8.6 非本地跳转) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(8.6 非本地跳转) Tj
T*
() Tj
T*
() Tj
T*
(C 语言提供了一种用户级异常控制流形式，称为非本地跳转（non local) Tj
T*
(jump），它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用—返回序列。非本地跳转是通过 setjmp 和 longjmp 函数来提供的。) Tj
T*
() Tj
T*
(    #include <setjmp.h>) Tj
T*
(    int setjmp\(jmp_buf env\);) Tj
T*
(    int sigsetjmp\(sigjmp_buf env, int savesigs\);) Tj
T*
() Tj
T*
(    // 返回：setjmp 返回 0，longjmp 返回非零。) Tj
T*
() Tj
T*
(setjmp 函数在 env 缓冲区中保存当前调用环境，以供后面的 longjmp 使用，并返回) Tj
T*
(0。调用环境包括程序计数器、栈指针和通用目的寄存器。岀于某种超出本书描述范围的原因，setjmp 返回的值不能被赋值给变量：) Tj
T*
() Tj
T*
(    rc = setjmp\(env\);  /* Wrong! */) Tj
T*
() Tj
T*
(不过它可以安全地用在 switch 或条件语句的测试中【62】。) Tj
T*
() Tj
T*
(    #include <setjmp.h>) Tj
T*
() Tj
T*
(    void longjmp\(jmp_buf env, int retval\);) Tj
T*
(    void siglongjmp\(sigjmp_buf env, int retval\);) Tj
T*
() Tj
T*
(    // 从不返回。) Tj
T*
() Tj
T*
(longjmp 函数从 env 缓冲区中恢复调用环境，然后触发一个从最近一次初始化 env 的 setjmp 调用的返回。然后 setjmp 返回，并带有非零的返回值) Tj
T*
(retval。) Tj
T*
() Tj
T*
(第一眼看过去，setjmp 和 longjmp 之间的相互关系令人迷惑。setjmp 函数只被调用一次，但返回多次：一次是当第一次调用 setjmp，而调用环境保存在缓冲区 env) Tj
T*
(中时，一次是为每个相应的 longjmp 调用。另一方面，longjmp 函数被调用一次，但从不返回。) Tj
T*
ET
endstream
endobj
474 0 obj
<< /Length 1936 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(非本地跳转的一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。如果在一个深层嵌套的函数调用中发现了一个错误情况，我们可以使用非本地跳转直接返) Tj
T*
(回到一个普通的本地化的错误处理程序，而不是费力地解开调用栈。) Tj
T*
() Tj
T*
(图 8-43 展示了一个示例，说明这可能是如何工作的。main 函数首先调用 setjmp 以保存当前的调用环境，然后调用函数 foo，foo 依次调用函数 bar。如果 foo) Tj
T*
(或者 bar 遇到一个错误，它们立即通过一次 longjmp 调用从 setjmp 返回。setjmp 的非零返回值指明了错误类型，随后可以被解码，且在代码中的某个位置进行处理。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    jmp_buf buf;) Tj
T*
() Tj
T*
(    int error1 = 0;) Tj
T*
(    int error2 = 1;) Tj
T*
() Tj
T*
(    void foo\(void\), bar\(void\);) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        switch \(setjmp\(buf\)\) {) Tj
T*
(        case 0:) Tj
T*
(            foo\(\);) Tj
T*
(            break;) Tj
T*
(        case 1:) Tj
T*
(            printf\("Detected an error1 condition in foo\\n"\);) Tj
T*
(            break;) Tj
T*
(        case 2:) Tj
T*
(            printf\("Detected an error2 condition in foo\\n"\);) Tj
T*
(            break;) Tj
T*
(        default:) Tj
T*
(            printf\("Unknown error condition in foo\\n"\);) Tj
T*
(        }) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* Deeply nested function foo */) Tj
T*
(    void foo\(void\)) Tj
T*
(    {) Tj
T*
(        if \(error1\)) Tj
T*
(            longjmp\(buf, 1\);) Tj
T*
(        bar\(\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    void bar\(void\)) Tj
T*
(    {) Tj
T*
(        if \(error2\)) Tj
T*
(            longjmp\(buf, 2\);) Tj
T*
ET
endstream
endobj
475 0 obj
<< /Length 2514 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    }) Tj
T*
() Tj
T*
(> 图 8-43 非本地跳转的示例。本示例表明了使用非本地跳转来从深层嵌套的函数调用中的错误情况恢复，而不需要解开整个栈的基本框架) Tj
T*
() Tj
T*
(longjmp) Tj
T*
(允许它跳过所有中间调用的特性可能产生意外的后果。例如，如果中间函数调用中分配了某些数据结构，本来预期在函数结尾处释放它们，那么这些释放代码会被跳过，因而会产生内存泄漏。) Tj
T*
() Tj
T*
(非本地跳转的另一个重要应用是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。图 8-44) Tj
T*
(展示了一个简单的程序，说明了这种基本技术。当用户在键盘上键入 Ctrl+C 时，这个程序用信号和非本地跳转来实现软重启。sigsetjmp 和 siglongjmp 函数是) Tj
T*
(setjmp 和 longjmp 的可以被信号处理程序使用的版本。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    sigjmp_buf buf;) Tj
T*
() Tj
T*
(    void handler\(int sig\)) Tj
T*
(    {) Tj
T*
(        siglongjmp\(buf, 1\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        if \(!sigsetjmp\(buf, 1\)\) {) Tj
T*
(            Signal\(SIGINT, handler\);) Tj
T*
(            Sio_puts\("starting\\n"\);) Tj
T*
(        }) Tj
T*
(        else) Tj
T*
(            Sio_puts\("restarting\\n"\);) Tj
T*
() Tj
T*
(        while \(1\) {) Tj
T*
(            Sleep\(1\);) Tj
T*
(            Sio_puts\("processing...\\n"\);) Tj
T*
(        }) Tj
T*
(        exit\(0\); /* Control never reaches here */) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-44 当用户键入 Ctrl+C 时，使用非本地跳转来重启动它自身的程序) Tj
T*
() Tj
T*
(在程序第一次启动时，对 sigsetjmp 函数的初始调用保存调用环境和信号的上下文（包括待处理的和被阻塞的信号向量）。随后，主函数进入一个无限处理循环。当用户键入 Ctrl+C) Tj
T*
(时，内核发送一个 SIGINT) Tj
T*
(信号给这个进程，该进程捕获这个信号。不是从信号处理程序返回，如果是这样那么信号处理程序会将控制返回给被中断的处理循环，反之，处理程序完成一个非本地跳转，回到 main) Tj
T*
(函数的开始处。当我们在系统上运行这个程序时，得到以下输出：) Tj
T*
() Tj
T*
(    linux> ./restart) Tj
T*
(    starting) Tj
T*
(    processing...) Tj
T*
ET
endstream
endobj
476 0 obj
<< /Length 2723 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    processing...) Tj
T*
(    Ctrl+C) Tj
T*
(    restarting) Tj
T*
(    processing...) Tj
T*
(    Ctrl+C) Tj
T*
(    restarting) Tj
T*
(    processing...) Tj
T*
() Tj
T*
(关于这个程序有两件很有趣的事情。首先，为了避免竞争，必须在调用了 sigsetjmp 之后再设置处理程序。否则，就会冒在初始调用 sigsetjmp 为 siglongjmp) Tj
T*
(设置调用环境之前這行处理程序的风险。其次，你可能已经注意到了，sigsetjmp 和 siglongjmp 函数不在图 8-33 中异步信号安全的函数之列。原因是一般来说) Tj
T*
(siglongjmp 可以跳到任意代码，所以我们必须小心，只在 siglongjmp 可达的代码中调用安全的函数。在本例中，我们调用安全的 sio\\_puts 和 sleep) Tj
T*
(函数。不安全的 exit 函数是不可达的。) Tj
T*
() Tj
T*
(旁注 - C++ 和 Java 中的软件异常) Tj
T*
() Tj
T*
() Tj
T*
(C++ 和 Java 提供的异常机制是较高层次的，是 C 语言的 setjmp 和 longjmp 函数的更加结构化的版本。你可以把 try 语句中的 catch 子句看做类似于) Tj
T*
(setjmp 函数。相似地，throw 语句就类似于 longjmp 函数。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(8.7 操作进程的工具) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(8.7 操作进程的工具) Tj
T*
() Tj
T*
() Tj
T*
(Linux 系统提供了大量的监控和操作进程的有用工具。) Tj
T*
() Tj
T*
(* STRACE：打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用 -static) Tj
T*
(编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。) Tj
T*
(* PS：列出当前系统中的进程（包括僵死进程）。) Tj
T*
(* TOP：打印出关于当前进程资源使用的信息。) Tj
T*
(* PMAP：显示进程的内存映射。) Tj
T*
(* /proc：一个虚拟文件系统，以 ASCII 文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入 “cat/proc/loadavg”，可以看到你的) Tj
T*
(Linux 系统上当前的平均负载。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(8.8 小结) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(8.8 小结) Tj
T*
() Tj
T*
() Tj
T*
(异常控制流（ECF）发生在计算机系统的各个层次，是计算机系统中提供并发的基本机制。) Tj
T*
ET
endstream
endobj
477 0 obj
<< /Length 3071 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(在硬件层，异常是由处理器中的事件触发的控制流中的突变。控制流传递给一个软件处理程序，该处理程序进行一些处理，然后返回控制给被中断的控制流。) Tj
T*
() Tj
T*
(有四种不同类型的异常：中断、故障、终止和陷阱。当一个外部 I/O 设备（例如定时器芯片或者磁盘控制器）设置了处理器芯片上的中断管脚时，（对于任意指令）中断会异步地发生。控制返回到故) Tj
T*
(障指令后面的那条指令。一条指令的执行可能导致故障和终止同步发生。故障处理程序会重新启动故障指令，而终止处理程序从不将控制返回给被中断的流。最后，陷阱就像是用来实现向应用提供到操作系) Tj
T*
(统代码的受控的人口点的系统调用的函数调用。) Tj
T*
() Tj
T*
(在操作系统层，内核用 ECF 提供进程的基本概念。进程提供给应用两个重要的抽象：) Tj
T*
() Tj
T*
(1. 逻辑控制流，它提供给每个程序一个假象，好像它是在独占地使用处理器；) Tj
T*
(2. 私有地址空间，它提供给每个程序一个假象，好像它是在独占地使用主存。) Tj
T*
() Tj
T*
(在操作系统和应用程序之间的接口处，应用程序可以创建子进程，等待它们的子进程停止或者终止，运行新的程序，以及捕获来自其他进程的信号。信号处理的语义是微妙的，并且随系统不同而不同。然而) Tj
T*
(，在与 Posix 兼容的系统上存在着一些机制，允许程序清楚地指定期望的信号处理语义。) Tj
T*
() Tj
T*
(最后，在应用层，C 程序可以使用非本地跳转来规避正常的调用/返回栈规则，并且直接从一个函数分支到另一个函数。) Tj
T*
() Tj
T*
(参考文献说明) Tj
T*
() Tj
T*
() Tj
T*
(Kerrisk 是 Linux 环境编程的完全参考手册【62】。Intel ISA 规范包含对 Intel 处理器上的异常和中断的详细讨论【50】。操作系统教科书口) Tj
T*
(【102，106，113】包括关于异常、进程和信号的其他信息。W. Richard Stevens) Tj
T*
(的【111】是一本有价值的和可读性很高的经典著作，是关于如何在应用程序中处理进程和信号的。Bovet 和 Cesati【11】给出了一个关于 Linux) Tj
T*
(内核的非常清晰的描述，包括进程和信号实现的细节。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(家庭作业) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(家庭作业) Tj
T*
() Tj
T*
() Tj
T*
(练习题 8.9) Tj
T*
() Tj
T*
() Tj
T*
(考虑四个具有如下开始和结束时间的进程：) Tj
T*
() Tj
T*
(| 进程 | 开始时间 | 结束时间 |) Tj
T*
(| :---: | :---: | :---: |) Tj
T*
(| A | 5 | 7 |) Tj
T*
(| B | 2 | 4 |) Tj
T*
(| C | 3 | 6 |) Tj
T*
(| D | 1 | 8 |) Tj
T*
() Tj
T*
(对于每对进程，指明它们是否是并发地运行的：) Tj
T*
ET
endstream
endobj
478 0 obj
<< /Length 1190 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(| 进程对 | 并发地？ |) Tj
T*
(| :---: | :---: |) Tj
T*
(| AB |  |) Tj
T*
(| AC |  |) Tj
T*
(| AD |  |) Tj
T*
(| BC |  |) Tj
T*
(| BD |  |) Tj
T*
(| CD |  |) Tj
T*
() Tj
T*
(练习题 8.10) Tj
T*
() Tj
T*
() Tj
T*
(在这一章里，我们介绍了一些具有不寻常的调用和返回行为的函数：setjmp、longjmp、execve 和 fork。找到下列行为中和每个函数相匹配的一种：) Tj
T*
() Tj
T*
(A. 调用一次，返回两次。) Tj
T*
() Tj
T*
(B. 调用一次，从不返回。) Tj
T*
() Tj
T*
(C. 调用一次，返回一次或者多次。) Tj
T*
() Tj
T*
(练习题 8.11) Tj
T*
() Tj
T*
() Tj
T*
(这个程序会输出多少个 “hello” 输出行？) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int i;) Tj
T*
() Tj
T*
(        for \(i = 0; i < 2; i++\)) Tj
T*
(            Fork\(\);) Tj
T*
(        printf\("hello"\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(练习题 8.12) Tj
T*
() Tj
T*
() Tj
T*
(这个程序会输出多少个 “hello” 输出行？) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void doit\(\)) Tj
T*
ET
endstream
endobj
479 0 obj
<< /Length 1097 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    {) Tj
T*
(        Fork\(\);) Tj
T*
(        Fork\(\);) Tj
T*
(        printf\("hello\\n"\);) Tj
T*
(        return;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        doit \(\);) Tj
T*
(        printf\("hello\\n"\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(练习题 8.13) Tj
T*
() Tj
T*
() Tj
T*
(下面程序的一种可能的输出是什么？) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int x = 3;) Tj
T*
() Tj
T*
(        if \(Fork\(\) != 0\)) Tj
T*
(            print! \("x=%d\\n", ++x\);) Tj
T*
() Tj
T*
(        printf\("x=%d\\n", --x\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(练习题 8.14) Tj
T*
() Tj
T*
() Tj
T*
(这个程序会输出多少个 “hello” 输出行？) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void doit\(\)) Tj
T*
(    {) Tj
T*
(        if \(Fork\(\) == 0\) {) Tj
T*
(            Fork\(\);) Tj
T*
(            printf\("hello\\n"\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
ET
endstream
endobj
480 0 obj
<< /Length 1058 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        return;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        doit\(\);) Tj
T*
(        printf\("hello\\n"\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(练习题 8.15) Tj
T*
() Tj
T*
() Tj
T*
(这个程序会输出多少个 “hello” 输出行？) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void doit\(\)) Tj
T*
(    {) Tj
T*
(        if \(Fork\(\) == 0\) {) Tj
T*
(            Fork\(\);) Tj
T*
(            printf\("hello\\n"\);) Tj
T*
(            return;) Tj
T*
(        }) Tj
T*
(        return;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        doit\(\);) Tj
T*
(        printf\("hello\\n"\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(练习题 8.16) Tj
T*
() Tj
T*
() Tj
T*
(下面这个程序的输出是什么？) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    int counter = 1;) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        if \(fork\(\) == 0\) {) Tj
T*
(            counter--;) Tj
T*
ET
endstream
endobj
481 0 obj
<< /Length 1290 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            exit\(0\);) Tj
T*
(        }) Tj
T*
(        else {) Tj
T*
(            Wait\(NULL\);) Tj
T*
(            printf\("counter = %d\\n", ++counter\);) Tj
T*
(        }) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(练习题 8.17) Tj
T*
() Tj
T*
() Tj
T*
(列举练习题 8.4 中程序所有可能的输出。) Tj
T*
() Tj
T*
(练习题 8.18) Tj
T*
() Tj
T*
() Tj
T*
(考虑下面的程序：) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void end\(void\)) Tj
T*
(    {) Tj
T*
(        printf\("2"\); fflush\(stdout\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        if \(Fork\(\) == 0\)) Tj
T*
(            atexit\(end\);) Tj
T*
(        if \(Fork\(\) == 0\) {) Tj
T*
(            printf\("0"\); fflush\(stdout\);) Tj
T*
(        }) Tj
T*
(        else {) Tj
T*
(            printf\("1"\); fflush\(stdout\);) Tj
T*
(        }) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(判断下面哪个输出是可能的。注意：atexit 函数以一个指向函数的指针为输入，并将它添加到函数列表中（初始为空），当 exit 函数被调用时，会调用该列表中的函数。) Tj
T*
() Tj
T*
(A. 112002) Tj
T*
() Tj
T*
(B. 211020) Tj
T*
() Tj
T*
(C. 102120) Tj
T*
ET
endstream
endobj
482 0 obj
<< /Length 1522 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(D. 122001) Tj
T*
() Tj
T*
(E. 100212) Tj
T*
() Tj
T*
(练习题 8.19) Tj
T*
() Tj
T*
() Tj
T*
(下面的函数会打印多少行输出？用一个 n 的函数给出答案。假设$$\\small n \\geqslant 1$$。) Tj
T*
() Tj
T*
(    void foo\(int n\)) Tj
T*
(    {) Tj
T*
(        int i;) Tj
T*
() Tj
T*
(        for \(i = 0; i < n; i++\)) Tj
T*
(            Fork\(\);) Tj
T*
(        printf\("hello\\n"\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(练习题 8.20) Tj
T*
() Tj
T*
(使用 execve 编写一个叫做 myls 的程序，该程序的行为和 /bin/ls 程序的一样。你的程序应该接受相同的命令行参数，解释同样的环境变量，并产生相同的输岀。) Tj
T*
() Tj
T*
(Is 程序从 COLUMNS 环境变量中获得屏幕的宽度。如果没有设置 COLUMNS，那么 ls 会假设屏幕宽 80 列。因此，你可以通过把 COLUMNS 环境设置得小于) Tj
T*
(80，来检查你对环境变量的处理：) Tj
T*
() Tj
T*
(    linux> setenv COLUMNS 40) Tj
T*
(    linux> ./myls) Tj
T*
(    .) Tj
T*
(    . // Output is 40 columns wide) Tj
T*
(    .) Tj
T*
(    linux> unsetenv COLUMNS) Tj
T*
(    linux> ./myls) Tj
T*
(    .) Tj
T*
(    . // Output is now 80 columns wide) Tj
T*
(    .) Tj
T*
() Tj
T*
(练习题 8.21) Tj
T*
() Tj
T*
(下面的程序可能的输岀序列是什么？) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        if \(fork\(\) == 0\) {) Tj
T*
(            printf\("a"\); fflush\(stdout\);) Tj
T*
ET
endstream
endobj
483 0 obj
<< /Length 2144 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            exit\(0\);) Tj
T*
(        }) Tj
T*
(        else {) Tj
T*
(            printf\("b"\); fflush\(stdout\);) Tj
T*
(            waitpid\(-1, NULL, 0\);) Tj
T*
(        }) Tj
T*
(        printf\("c"\); fflush\(stdout\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(练习题 8.22) Tj
T*
() Tj
T*
(编写 Unix system 函数的你自己的版本) Tj
T*
() Tj
T*
(    int mysystem\(char* command\);) Tj
T*
() Tj
T*
(mysystem 函数通过调用 “/bin/sh-ccommand” 来执行 command，然后在 command 完成后返回。如果 command（通过调用 exit) Tj
T*
(函数或者执行一条 return 语句）正常退出，那么 mysystem 返回 command 退出状态。例如，如果 command 通过调用 exit\\\(8\\\) 终止，那么) Tj
T*
(mysystem 返回值 8。否则，如果 command 是异常终止的，那么 mysystem 就返回 shell 返回的状态。) Tj
T*
() Tj
T*
(练习题 8.23) Tj
T*
() Tj
T*
(你的一个同事想要使用信号来让一个父进程对发生在子进程中的事件计数。其想法是每次发生一个事件时，通过向父进程发送一个信号来通知它，并且让父进程的信号处理程序对一个全局变量) Tj
T*
(counter 加一，在子进程终止之后，父进程就可以检查这个变量。然而，当他在系统上运行图 8-45 中的测试程序时，发现当父进程调用 printf 时，counter 的值总是) Tj
T*
(2，即使子进程向父进程发送了 5 个信号也是如此。他很困惑，向你寻求帮助。你能解释这个程序有什么错误吗？) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int counter = 0;) Tj
T*
() Tj
T*
(    void handler\(int sig\)) Tj
T*
(    {) Tj
T*
(        counter++;) Tj
T*
(        sleep\(1\); /* Do some work in the handler */) Tj
T*
(        return;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int i;) Tj
T*
() Tj
T*
(        Signal\(SIGUSR2, handler\);) Tj
T*
() Tj
T*
(        if \(Fork\(\) == 0\) { /* Child */) Tj
T*
(            for \(i = 0; i < 5; i++\) {) Tj
T*
(                Kill\(getppid\(\), SIGUSR2\);) Tj
T*
ET
endstream
endobj
484 0 obj
<< /Length 2931 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(                printf\("sent SIGUSR2 to parent\\n"\);) Tj
T*
(            }) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        Wait\(NULL\);) Tj
T*
(        printf\("counter=%d\\n", counter\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 8-45 家庭作业 8.23 中引用的计数器程序) Tj
T*
() Tj
T*
(练习题 8.24) Tj
T*
() Tj
T*
(修改图 8-18 中的程序，以满足下面两个条件：) Tj
T*
() Tj
T*
(1）每个子进程在试图写一个只读文本段中的位置时会异常终止。) Tj
T*
() Tj
T*
(2）父进程打印和下面所示相同（除了 PID）的输出：) Tj
T*
() Tj
T*
(    child 12255 terminated by signal 11: Segmentation fault) Tj
T*
(    child 12254 terminated by signal 11: Segmentation fault) Tj
T*
() Tj
T*
(提示：请参考 psignal\\\(3\\\) 的 man 页。) Tj
T*
() Tj
T*
(练习题 8.25) Tj
T*
() Tj
T*
(编写 fgets 函数的一个版本，叫做 tfgets，它 5 秒钟后会超时。tfgets 函数接收和 fgets 相同的输入。如果用户在 5 秒内不键入一个输入行，tfgets) Tj
T*
(返回 NULL。否则，它返回一个指向输入行的指针。) Tj
T*
() Tj
T*
(练习题 8.26) Tj
T*
() Tj
T*
(以图 8-23 中的示例作为开始点，编写一个支持作业控制的 shell 程序。shell 必须具有以下特性：) Tj
T*
() Tj
T*
(* 用户输入的命令行由一个 name、零个或者多个参数组成，它们都由一个或者多个空格分隔开。如果 name 是一个内置命令，那么 shell) Tj
T*
(就立即处理它，并等待下一个命令行。否则，shell 就假设 name 是一个可执行文件，在一个初始的子进程（作业）的上下文中加载并运行它。作业的进程组 ID 与子进程的 PID) Tj
T*
(相同。) Tj
T*
(* 每个作业是由一个进程 ID（PID）或者一个作业 ID（JID）来标识的，它是由一个 shell 分配的任意的小正整数。JID 在命令行上用前缀 “%” 来表示。比如，“％5”) Tj
T*
(表示 JID 5，而 “5” 表示 PID 5。) Tj
T*
(* 如果命令行以 & 来结束，那么 shell 就在后台运行这个作业。否则，shell 就在前台运行这个作业。) Tj
T*
(* 输入 Ctrl+C（Ctrl+Z），使得内核发送一个 SIGINT（SIGTSTP）信号给 shell，shell 再转发给前台进程组中的每个进程。✦) Tj
T*
(* 内置命令 jobs 列出所有的后台作业。) Tj
T*
(* 内置命令 bg job 通过发送一个 SIGCONT 信号重启 job，然后在后台运行它。job 参数可以是一个 PID，也可以是一个 JID。) Tj
T*
(* 内置命令 fg job 通过发送一个 SIGCONT 信号重启 job，然后在前台运行它。) Tj
T*
(* shell 回收它所有的僵死子进程。如果任何作业因为收到一个未捕获的信号而终止，那么 shell 就输出一条消息到终端，消息中包含该作业的 PID 和对该信号的描述。) Tj
T*
() Tj
T*
ET
endstream
endobj
485 0 obj
<< /Length 1699 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(✦：注意这是对真实的 shell 工作方式的简化。真实的 shell 里，内核响应 Ctrl+C（Ctrl+Z），把) Tj
T*
(SIGINT（SIGTSTP）直接发送给终端前台进程组中的每个进程。shell 用 tcsetpgrp 函数管理这个进程组的成员，用 tcsetattr) Tj
T*
(函数管理终端的属性，这两个函数都超出了本书讲述的范围。可以参考【62】获得详细信息。) Tj
T*
() Tj
T*
(图 8-46 展示了一个 shell 会话示例。) Tj
T*
() Tj
T*
(    linux> ./shell                              # Run your shell program) Tj
T*
() Tj
T*
(    >bogus) Tj
T*
(    bogus: Command not found.                   # Execve can’t find executable) Tj
T*
() Tj
T*
(    >foo 10) Tj
T*
(    Job 5035 terminated by signal: Interrupt    # User types Ctrl+C) Tj
T*
() Tj
T*
(    >foo 100 &) Tj
T*
(    [1] 5036 foo 100 &) Tj
T*
() Tj
T*
(    >foo 200 &) Tj
T*
(    [2] 5037 foo 200 &) Tj
T*
() Tj
T*
(    >jobs) Tj
T*
(    [1] 5036 Running foo 100 &) Tj
T*
(    [2] 5037 Running foo 200 &) Tj
T*
() Tj
T*
(    >fg %1) Tj
T*
(    Job [1] 5036 stopped by signal: Stopped     # User types Ctrl+Z) Tj
T*
() Tj
T*
(    >jobs) Tj
T*
(    [1] 5036 Stopped foo 100 &) Tj
T*
(    [2] 5037 Running foo 200 &) Tj
T*
() Tj
T*
(    >bg 5035) Tj
T*
(    5035: No such process) Tj
T*
() Tj
T*
(    >bg 5036) Tj
T*
(    [1] 5036 foo 100 &) Tj
T*
() Tj
T*
(    >/bin/kill 5036) Tj
T*
(    Job 5036 terminated by signal: Terminated) Tj
T*
() Tj
T*
(    > fg %2                                     # Wait for fg job to finish) Tj
T*
() Tj
T*
(    >quit) Tj
T*
() Tj
T*
(    linux>                                      # Back to the Unix shell) Tj
T*
() Tj
T*
ET
endstream
endobj
486 0 obj
<< /Length 4738 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(> 图 8-46 家庭作业 8.26 的 shell 会话示例) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(第 9 章：虚拟内存) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(第 9 章：虚拟内存) Tj
T*
() Tj
T*
() Tj
T*
(一个系统中的进程是与其他进程共享 CPU 和主存资源的。然而，共享主存会形成一些特殊的挑战。随着对 CPU 需求的增长，进程以某种合理的平滑方式慢了下来。但是如果太多的进程需要太多) Tj
T*
(的内存，那么它们中的一些就根本无法运行。当一个程序没有空间可用时，那就是它运气不好了。内存还很容易被破坏。如果某个进程不小心写了另一个进程使用的内存，它就可能以某种完全和程序逻辑无) Tj
T*
(关的令人迷惑的方式失败。) Tj
T*
() Tj
T*
(为了更加有效地管理内存并且少出错，现代系统提供了一种对主存的抽象概念，叫做虚拟内存（VM）。虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件的完美交互，它为每个进程提供了) Tj
T*
(一个大的、一致的和私有的地址空间。通过一个很清晰的机制，虚拟内存提供了三个重要的能力：) Tj
T*
() Tj
T*
(1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。) Tj
T*
(2. 它为每个进程提供了一致的地址空间，从而简化了内存管理。) Tj
T*
(3. 它保护了每个进程的地址空间不被其他进程破坏。) Tj
T*
() Tj
T*
(虚拟内存是计算机系统最重要的概念之一。它成功的一个主要原因就是因为它是沉默地、自动地工作的，不需要应用程序员的任何干涉。既然虚拟内存在幕后工作得如此之好，为什么程序员还需要理解它呢) Tj
T*
(？有以下几个原因：) Tj
T*
() Tj
T*
(* 虚拟内存是核心的。虚拟内存遍及计算机系统的所有层面，在硬件异常、汇编器、链接器、加载器、共享对象、文件和进程的设计中扮演着重要角色。理解虚拟内存将帮助你更好地理解系统通常是如何) Tj
T*
(工作的。) Tj
T*
(* 虚拟内存是强大的。虚拟内存给予应用程序强大的能力，可以创建和销毁内存片（chunk）、将内存片映射到磁盘文件的某个部分，以及与其他进程共享内存。比如，你知道可以通过读写内存位置) Tj
T*
(读或者修改一个磁盘文件的内容吗？或者可以加载一个文件的内容到内存中，而不需要进行任何显式地复制吗？理解虚拟内存将帮助你利用它的强大功能在应用程序中添加动力。) Tj
T*
(* 虚拟内存是危险的。每次应用程序引用一个变量、间接引用一个指针，或者调用一个诸如 malloc) Tj
T*
(这样的动态分配程序时，它就会和虚拟内存发生交互。如果虚拟内存使用不当，应用将遇到复杂危险的与内存有关的错误。例如，一个带有错误指针的程序可以立即崩溃于“段错误”) Tj
T*
(或者“保护错误”，它可能在崩溃之前还默默地运行了几个小时，或者是最令人惊慌地，运行完成却产生不正确的结果。理解虚拟内存以及诸如 malloc) Tj
T*
(之类的管理虚拟内存的分配程序，可以帮助你避免这些错误。) Tj
T*
() Tj
T*
(这一章从两个角度来看虚拟内存。本章的前一部分描述虚拟内存是如何工作的。后一部分描述的是应用程序如何使用和管理虚拟内存。无可避免的事实是虚拟内存很复杂，本章很多地方都反映了这一点。好) Tj
T*
(消息就是如果你掌握这些细节，你就能够手工模拟一个小系统的虚拟内存机制，而且虚拟内存的概念将永远不再神秘。) Tj
T*
() Tj
T*
(第二部分是建立在这种理解之上的，向你展示了如何在程序中使用和管理虚拟内存。你将学会如何通过显式的内存映射和对像 malloc) Tj
T*
(程序这样的动态内存分配器的调用来管理虚拟内存。你还将了解到 C 程序中的大多数常见的与内存有关的错误，并学会如何避免它们的出现。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(9.1 物理和虚拟寻址) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(9.1 物理和虚拟寻址) Tj
T*
() Tj
T*
ET
endstream
endobj
487 0 obj
<< /Length 3405 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(计算机系统的主存被组织成一个由 M 个连续的字节大小的单元组成的数组。每字节都有一个唯一的物理地址（Physical Address，PA）。第一个字节的地址为) Tj
T*
(0，接下来的字节地址为 1，再下一个为 2，依此类推。给定这种简单的结构，CPU 访问内存的最自然的方式就是使用物理地址。我们把这种方式称为物理寻址（physical) Tj
T*
(addressing）。图 9-1 展示了一个物理寻址的示例，该示例的上下文是一条加载指令，它读取从物理地址 4 处开始的 4 字节字。当 CPU) Tj
T*
(执行这条加载指令时，会生成一个有效物理地址，通过内存总线，把它传递给主存。主存取岀从物理地址 4 处开始的 4 字节字，并将它返回给 CPU，CPU 会将它存放在一个寄存器里。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-1) Tj
T*
(&#x4E00;&#x4E2A;&#x4F7F;&#x7528;&#x7269;&#x7406;&#x5BFB;&#x5740;&#x7684;&#x7CFB;&#x7EDF;]) Tj
T*
() Tj
T*
(早期的 PC 使用物理寻址，而且诸如数字信号处理器、嵌入式微控制器以及 Cray) Tj
T*
(超级计算机这样的系统仍然继续使用这种寻址方式。然而，现代处理器使用的是一种称为虚拟寻址（virtual addressing）的寻址形式，参见图 9-2。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-2) Tj
T*
(&#x4E00;&#x4E2A;&#x4F7F;&#x7528;&#x865A;&#x62DF;&#x5BFB;&#x5740;&#x7684;&#x7CFB;&#x7EDF;]) Tj
T*
() Tj
T*
(使用虚拟寻址，CPU 通过生成一个虚拟地址（Virtual) Tj
T*
(Address，VA）来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译（address) Tj
T*
(translation）。就像异常处理一样，地址翻译需要 CPU 硬件和操作系统之间的紧密合作。CPU 芯片上叫做内存管理单元（Memory Management) Tj
T*
(Unit，MMU）的专用硬件，利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(9.2 地址空间) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(9.2 地址空间) Tj
T*
() Tj
T*
() Tj
T*
(地址空间（addressspace）是一个非负整数地址的有序集合：) Tj
T*
() Tj
T*
($$) Tj
T*
(\\{0,1,2,\\cdots\\}) Tj
T*
($$) Tj
T*
() Tj
T*
(如果地址空间中的整数是连续的，那么我们说它是一个线性地址空间（linear address) Tj
T*
(space）。为了简化讨论，我们总是假设使用的是线性地址空间。在一个带虚拟内存的系统中，CPU 从一个有 $$\\small N=2^n$$) Tj
T*
(个地址的地址空间中生成虚拟地址，这个地址空间称为虚拟地址空间（virtual addres sspace）：) Tj
T*
() Tj
T*
($$) Tj
T*
(\\{0,1,2,\\cdots,N—1\\}) Tj
T*
($$) Tj
T*
() Tj
T*
(一个地址空间的大小是由表示最大地址所需要的位数来描述的。例如，一个包含$$\\small N=2^n$$个地址的虚拟地址空间就叫做一个 n 位地址空间。现代系统通常支持 32 位或者) Tj
T*
(64 位虚拟地址空间。) Tj
T*
() Tj
T*
(一个系统还有一个物理地址空间（physical address space），对应于系统中物理内存的 M 个字节：) Tj
T*
ET
endstream
endobj
488 0 obj
<< /Length 2764 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
($$) Tj
T*
(\\{0,1,2,\\cdots,M—1\\}) Tj
T*
($$) Tj
T*
() Tj
T*
(M 不要求是 2 的幕，但是为了简化讨论，我们假设$$\\small M=2^m$$ 。) Tj
T*
() Tj
T*
(地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自) Tj
T*
(一个不同的地址空间。这就是虚拟内存的基本思想。主存中的每字节都有一个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(练习题 9.1) Tj
T*
() Tj
T*
() Tj
T*
(完成下面的表格，填写缺失的条目，并且用适当的整数取代每个问号。) Tj
T*
() Tj
T*
(利用下列单位：$$\\small\\rm K=2^{10}$$（kilo，千），$$\\small\\rm M=2^{20}$$（mega，兆，百万），$$\\small\\rm) Tj
T*
(G=2^{30}$$（giga，千兆，十亿），$$\\small\\rm T=2^{40}$$（tera，万亿），$$\\small\\rm) Tj
T*
(P=2^{50}$$（peta，千千兆），或$$\\small E = 2^{60}$$（exa，千兆兆）。) Tj
T*
() Tj
T*
(| 虚拟地址位数（n） | 虚拟地址数（N） | 最大可能的虚拟地址 |) Tj
T*
(| :---: | :--- | :--- |) Tj
T*
(| 8 |  |  |) Tj
T*
(|  | $$\\small 2^? = 64\\rm K$$  |  |) Tj
T*
(|  |  | $$\\small \\rm 2^{32}-1=? G-1$$  |) Tj
T*
(|  | $$\\small \\rm 2^? = 256 T$$ |  |) Tj
T*
(| 64 |  |  |) Tj
T*
() Tj
T*
(这道题让你对不同地址空间的大小有了些了解。曾几何时，一个 32) Tj
T*
(位地址空间看上去似乎是无法想象的大。但是，现在有些数据库和科学应用需要更大的地址空间，而且你会发现这种趋势会继续。在有生之年，你可能会抱怨个人电脑上那狭促的 64 位地址空间！) Tj
T*
() Tj
T*
(| 虚拟地址位数（n） | 虚拟地址数（N） | 最大可能的虚拟地址 |) Tj
T*
(| :---: | :--- | :--- |) Tj
T*
(| 8 | $$\\small 2^8 = 256$$ | $$\\small 2^8 -1= 255$$ |) Tj
T*
(| 16 | $$\\small 2^{16} = 64~\\rm K$$  | $$\\small 2^{16} -1= 64~\\rm K -1$$ |) Tj
T*
(| 32 | $$\\small 2^{32} = 4~\\rm G$$ | $$\\small 2^{32} -1 = 4~\\rm G -1$$ |) Tj
T*
(| 48 | $$\\small \\rm 2^{48} = 256~\\rm T$$ | $$\\small \\rm 2^{48} -1 = 256~\\rm T -1$$ |) Tj
T*
(| 64 | $$\\small \\rm 2^{64} = 16384~\\rm P$$ | $$\\small \\rm 2^{64} -1 = 16384~\\rm P-1$$ |) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(9.3 虚拟内存作为缓存的工具) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(9.3 虚拟内存作为缓存的工具) Tj
T*
ET
endstream
endobj
489 0 obj
<< /Length 4711 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
() Tj
T*
(概念上而言，虚拟内存被组织为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，作为到数组的索引。磁盘上数组的内容被缓存在主存中。和存储器层次) Tj
T*
(结构中其他缓存一样，磁盘（较低层）上的数据被分割成块，这些块作为磁盘和主存（较高层）之间的传输单元。VM 系统通过将虚拟内存分割为称为虚拟页（Virtual) Tj
T*
(Page，VP）的大小固定的块来处理这个问题。每个虚拟页的大小为 $$\\small P = 2^p$$ 字节。类似地，物理内存被分割为物理页（Physical) Tj
T*
(Page，PP），大小也为 P 字节（物理页也被称为页帧（page frame））。) Tj
T*
() Tj
T*
(在任意时刻，虚拟页面的集合都分为三个不相交的子集：) Tj
T*
() Tj
T*
(* 未分配的：VM 系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。) Tj
T*
(* 缓存的：当前已缓存在物理内存中的已分配页。) Tj
T*
(* 未缓存的：未缓存在物理内存中的已分配页。) Tj
T*
() Tj
T*
(图 9-3 的示例展示了一个有 8 个虚拟页的小虚拟内存。虚拟页 0 和 3 还没有被分配，因此在磁盘上还不存在。虚拟页 1、4 和 6 被缓存在物理内存中。页 2、5 和 7) Tj
T*
(已经被分配了，但是当前并未缓存在主存中。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-3 &#x4E00;&#x4E2A; VM &#x7CFB;&#x7EDF;&#x662F;&#x5982;&#x4F55;&#x4F7F;&) Tj
T*
(#x7528;&#x4E3B;&#x5B58;&#x4F5C;&#x4E3A;&#x7F13;&#x5B58;&#x7684;]) Tj
T*
() Tj
T*
(9.3.1 DRAM 缓存的组织结构) Tj
T*
() Tj
T*
() Tj
T*
(为了有助于清晰理解存储层次结构中不同的缓存概念，我们将使用术语 SRAM 缓存来表示位于 CPU 和主存之间的 Ll、L2 和 L3 高速缓存，并且用术语 DRAM) Tj
T*
(缓存来表示虚拟内存系统的缓存，它在主存中缓存虚拟页。) Tj
T*
() Tj
T*
(在存储层次结构中，DRAM 缓存的位置对它的组织结构有很大的影响。回想一下，DRAM 比 SRAM 要慢大约 10 倍，而磁盘要比 DRAM 慢大约 100000) Tj
T*
(多倍。因此，DRAM 缓存中的不命中比起 SRAM 缓存中的不命中要昂贵得多，这是因为 DRAM 缓存不命中要由磁盘来服务，而 SRAM 缓存不命中通常是由基于 DRAM) Tj
T*
(的主存来服务的。而且，从磁盘的一个扇区读取第一个字节的时间开销比起读这个扇区中连续的字节要慢大约 100000 倍。归根到底，DRAM) Tj
T*
(缓存的组织结构完全是由巨大的不命中开销驱动的。) Tj
T*
() Tj
T*
(因为大的不命中处罚和访问第一个字节的开销，虚拟页往往很大，通常是 4KB ~ 2MB。由于大的不命中处罚，DRAM) Tj
T*
(缓存是全相联的，即任何虚拟页都可以放置在任何的物理页中。不命中时的替换策略也很重要，因为替换错了虚拟页的处罚也非常之高。因此，与硬件对 SRAM 缓存相比，操作系统对 DRAM) Tj
T*
(缓存使用了更复杂精密的替换算法。（这些替换算法超出了我们的讨论范围）。最后，因为对磁盘的访问时间很长，DRAM 缓存总是使用写回，而不是直写。) Tj
T*
() Tj
T*
(9.3.2 页表) Tj
T*
() Tj
T*
() Tj
T*
(同任何缓存一样，虚拟内存系统必须有某种方法来判定一个虚拟页是否缓存在 DRAM) Tj
T*
(中的某个地方。如果是，系统还必须确定这个虚拟页存放在哪个物理页中。如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个牺牲页，并将虚拟页从磁盘复制到) Tj
T*
(DRAM 中，替换这个牺牲页。) Tj
T*
() Tj
T*
(这些功能是由软硬件联合提供的，包括操作系统软件、MMU（内存管理单元）中的地址翻译硬件和一个存放在物理内存中叫做页表（page) Tj
T*
(table）的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘与 DRAM 之间来回传送页。) Tj
T*
() Tj
T*
(图 9-4 展示了一个页表的基本组织结构。页表就是一个页表条目（Page Table Entry，PTE）的数组。虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个) Tj
T*
(PTE。为了我们的目的，我们将假设每个 PTE 是由一个有效位（valid bit）和一个 n 位地址字段组成的。有效位表明了该虚拟页当前是否被缓存在 DRAM) Tj
T*
ET
endstream
endobj
490 0 obj
<< /Length 2754 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(中。如果设置了有效位，那么地址字段就表示 DRAM) Tj
T*
(中相应的物理页的起始位置，这个物理页中缓存了该虚拟页。如果没有设置有效位，那么一个空地址表示这个虚拟页还未被分配。否则，这个地址就指向该虚拟页在磁盘上的起始位置。) Tj
T*
() Tj
T*
(图 9-4 中的示例展示了一个有 8 个虚拟页和 4 个物理页的系统的页表。四个虚拟页（VP 1、VP 2、VP 4 和 VP 7）当前被缓存在 DRAM 中。两个页（VP 0 和) Tj
T*
(VP 5 ）还未被分配，而剩下的页（VP 3 和 VP 6）已经被分配了，但是当前还未被缓存。图 9-4 中有一个要点要注意，因为 DRAM) Tj
T*
(缓存是全相联的，所以任意物理页都可以包含任意虚拟页。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-4 &#x9875;&#x8868;]) Tj
T*
() Tj
T*
(练习题 9.2) Tj
T*
() Tj
T*
() Tj
T*
(确定下列虚拟地址大小（n）和页大小（P）的组合所需要的 PTE 数量：) Tj
T*
() Tj
T*
(| n | $$\\small P=2^p$$  | PTE数量 |) Tj
T*
(| :---: | :---: | :---: |) Tj
T*
(| 16 | 4K |  |) Tj
T*
(| 16 | 8K |  |) Tj
T*
(| 32 | 4K |  |) Tj
T*
(| 32 | 8K |  |) Tj
T*
() Tj
T*
(因为每个虚拟页面是$$\\small P=2^p$$字节，所以在系统中总共有$$\\small 2^n/2^p =) Tj
T*
(2^{n-p}$$个可能的页面，其中每个都需要一个页表条目（PTE）。) Tj
T*
() Tj
T*
(| n | $$\\small P=2^p$$  | PTE数量 |) Tj
T*
(| :---: | :---: | :---: |) Tj
T*
(| 16 | 4 K | 16 |) Tj
T*
(| 16 | 8 K | 8 |) Tj
T*
(| 32 | 4 K | 1 M |) Tj
T*
(| 32 | 8 K | 512 K |) Tj
T*
() Tj
T*
(9.3.3 页命中) Tj
T*
() Tj
T*
() Tj
T*
(考虑一下当 CPU 想要读包含在 VP2 中的虚拟内存的一个字时会发生什么（图 9-5），VP 2 被缓存在 DRAM 中。使用我们将在 9.6) Tj
T*
(节中详细描述的一种技术，地址翻译硬件将虚拟地址作为一个索引来定位 PTE 2，并从内存中读取它。因为设置了有效位，那么地址翻译硬件就知道 VP 2 是缓存在内存中的了。所以它使用) Tj
T*
(PTE 中的物理内存地址（该地址指向 PP 1 中缓存页的起始位置），构造出这个字的物理地址。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-5 VM &#x9875;&#x547D;&#x4E2D;&#x3002;&#x5BF9; VP 2) Tj
T*
(&#x4E2D;&#x4E00;&#x4E2A;&#x5B57;&#x7684;&#x5F15;&#x7528;&#x5C31;&#x4F1A;&#x547D;&#x4E2D;]) Tj
T*
() Tj
T*
(9.3.4 缺页) Tj
T*
() Tj
T*
() Tj
T*
(在虚拟内存的习惯说法中，DRAM 缓存不命中称为缺页（page fault）。图 9-6 展示了在缺页之前我们的示例页表的状态。CPU 引用了 VP 3 中的一个字，VP 3) Tj
T*
(并未缓存在 DRAM 中。地址翻译硬件从内存中读取 PTE 3，从有效位推断出 VP 3) Tj
T*
ET
endstream
endobj
491 0 obj
<< /Length 4333 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(未被缓存，并且触发一个缺页异常。缺页异常调用内核中的缺页异常处理程序，该程序会选择一个牺牲页，在此例中就是存放在 PP 3 中的 VP 4。如果 VP 4) Tj
T*
(已经被修改了，那么内核就会将它复制回磁盘。无论哪种情况，内核都会修改 VP 4 的页表条目，反映出 VP 4 不再缓存在主存中这一事实。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-6 VM &#x7F3A;&#x9875;&#xFF08;&#x4E4B;&#x524D;&#xFF09;&#x3002;&#x5BF9;) Tj
T*
(VP3 &#x4E2D;&#x7684;&#x5B57;&#x7684;&#x5F15;&#x7528;&#x4F1A;&#x4E0D;&#x547D;&#x4E2D;&#xFF0) Tj
T*
(C;&#x4ECE;&#x800C;&#x89E6;&#x53D1;&#x4E86;&#x7F3A;&#x9875;]) Tj
T*
() Tj
T*
(接下来，内核从磁盘复制 VP 3 到内存中的 PP 3，更新 PTE) Tj
T*
(3，随后返回。当异常处理程序返回时，它会重新启动导致缺页的指令，该指令会把导致缺页的虚拟地址重发送到地址翻译硬件。但是现在，VP 3) Tj
T*
(已经缓存在主存中了，那么页命中也能由地址翻译硬件正常处理了。图 9-7 展示了在缺页之后我们的示例页表的状态。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 9-7 VM 缺页（之后）。缺页处理程序选择 VP 4 作为牺牲页，并从磁盘上用 VP 3) Tj
T*
(的副本取代它。在缺页处理程序重新启动导致缺页的指令之后，该指令将从内存中正常地读取字，而不会再产生异常) Tj
T*
() Tj
T*
(虚拟内存是在 20 世纪 60 年代早期发明的，远在 CPU - 内存之间差距的加大引发产生 SRAM 缓存之前。因此，虚拟内存系统使用了和 SRAM 缓存不同的术语，即使它们的许) Tj
T*
(多概念是相似的。在虚拟内存的习惯说法中，块被称为页。在磁盘和内存之间传送页的活动叫做交换（swapping）或者页面调度（paging）。页从磁盘换入（或者页面调入）DRAM 和从) Tj
T*
(DRAM 换出（或者页面调出）磁盘。一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的这种策略称为按需页面调度（demand) Tj
T*
(paging）。也可以采用其他的方法，例如尝试着预测不命中，在页面实际被引用之前就换入页面。然而，所有现代系统都使用的是按需页面调度的方式。) Tj
T*
() Tj
T*
(9.3.5 分配页面) Tj
T*
() Tj
T*
() Tj
T*
(图 9-8 展示了当操作系统分配一个新的虚拟内存页时对我们示例页表的影响，例如，调用 malloc 的结果。在这个示例中，VP5 的分配过程是在磁盘上创建空间并更新 PTE) Tj
T*
(5，使它指向磁盘上这个新创建的页面。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 9-8 分配一个新的虚拟页面。内核在磁盘上分配 VP 5，并且将 PTE 5 指向这个新的位置) Tj
T*
() Tj
T*
(9.3.6 又是局部性救了我们) Tj
T*
() Tj
T*
() Tj
T*
(当我们中的许多人都了解了虚拟内存的概念之后，我们的第一印象通常是它的效率应该是非常低。因为不命中处罚很大，我们担心页面调度会破坏程序性能。实际上，虚拟内存工作得相当好，这主要归功于) Tj
T*
(我们的老朋友局部性（locality）。) Tj
T*
() Tj
T*
(尽管在整个运行过程中程序引用的不同页面的总数可能超出物理内存总的大小，但是局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面（active) Tj
T*
(page）集合上工作，这个集合叫做工作集（working set）或者常驻集合（resident) Tj
T*
(set）。在初始开销，也就是将工作集页面调度到内存中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量。) Tj
T*
() Tj
T*
(只要我们的程序有好的时间局部性，虚拟内存系统就能工作得相当好。但是，当然不是所有的程序都能展现良好的时间局部性。如果工作集的大小超出了物理内存的大小，那么程序将产生一种不幸的状态，) Tj
T*
(叫做抖动（thrashing），这时页面将不断地换进换出。虽然虚拟内存通常是有效的，但是如果一个程序性能慢得像爬一样，那么聪明的程序员会考虑是不是发生了抖动。) Tj
T*
() Tj
T*
(旁注 - 统计缺页次数) Tj
T*
() Tj
T*
ET
endstream
endobj
492 0 obj
<< /Length 5042 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(你可以利用 Linux 的 getrusage 函数监测缺页的数量（以及许多其他的信息）。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(9.4 虚拟内存作为内存管理的工具) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(9.4 虚拟内存作为内存管理的工具) Tj
T*
() Tj
T*
() Tj
T*
(在上一节中，我们看到虚拟内存是如何提供一种机制，利用 DRAM 缓存来自通常更大的虚拟地址空间的页面。有趣的是，一些早期的系统，比如 DEC) Tj
T*
(PDP-11/70，支持的是一个比物理内存更小的虚拟地址空间。然而，虚拟地址仍然是一个有用的机制，因为它大大地简化了内存管理，并提供了一种自然的保护内存的方法。) Tj
T*
() Tj
T*
(到目前为止，我们都假设有一个单独的页表，将一个虚拟地址空间映射到物理地址空间。实际上，操作系统为每个进程提供了一个独立的页表，因而也就是一个独立的虚拟地址空间。图 9-9) Tj
T*
(展示了基本思想。在这个示例中，进程 i 的页表将 VP 1 映射到 PP 2，VP 2 映射到 PP 7。相似地，进程 j 的页表将 VP 1 映射到 PP 7，VP 2 映射到) Tj
T*
(PP 10。注意，多个虚拟页面可以映射到同一个共享物理页面上。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 9-9 VM 如何为进程提供独立的地址空间。操作系统为系统中的每个进程都维护一个独立的页表) Tj
T*
() Tj
T*
(按需页面调度和独立的虚拟地址空间的结合，对系统中内存的使用和管理造成了深远的影响。特别地，VM 简化了链接和加载、代码和数据共享，以及应用程序的内存分配。) Tj
T*
() Tj
T*
(* 简化链接。独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。例如，像我们在图 8-13 中看到的，一个给定的 Linux) Tj
T*
(系统上的每个进程都使用类似的内存格式。对于 64 位地址空间，代码段总是从虚拟地址 0x400000 开始。数据段跟在代码段之后，中间有一段符合要求的对齐空白。栈占据用户进程地址空) Tj
T*
(间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成完全链接的可执行文件，这些可执行文件是独立于物理内存中代码和数据的最终位置的。) Tj
T*
(* 简化加载。虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。要把目标文件中 .text 和 .data 节加载到一个新创建的进程中，Linux 加载器为代码和数据段分配虚) Tj
T*
(拟页，把它们标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。有趣的是，加载器从不从磁盘到内存实际复制任何数据。在每个页初次被引用时，要么是 CPU) Tj
T*
(取指令时引用的，要么是一条正在执行的指令引用一个内存位置时引用的，虚拟内存系统会按照需要自动地调入数据页。) Tj
T*
() Tj
T*
(  将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称作内存映射（memory mapping）。Linux 提供一个称为 mmap) Tj
T*
(  的系统调用，允许应用程序自己做内存映射。我们会在 9.8 节中更详细地描述应用级内存映射。) Tj
T*
() Tj
T*
(* 简化共享。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的一致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情) Tj
T*
(况中，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。) Tj
T*
() Tj
T*
(然而，在一些情况中，还是需要进程来共享代码和数据。例如，每个进程必须调用相同的操作系统内核代码，而每个 C 程序都会调用 C 标准库中的程序，比如) Tj
T*
(printf。操作系统通过将不同进程中适当的虚拟页面映射到相同的物理页面，从而安排多个进程共享这部分代码的一个副本，而不是在每个进程中都包括单独的内核和 C 标准库的副本，如图) Tj
T*
(9-9 所示。) Tj
T*
() Tj
T*
(* 简化内存分配。虚拟内存为向用户进程提供一个简单的分配额外内存的机制。当一个运行在用户进程中的程序要求额外的堆空间时（如调用 malloc) Tj
T*
(的结果），操作系统分配一个适当数字（例如 k）个连续的虚拟内存页面，并且将它们映射到物理内存中任意位置的 k 个任意的物理页面。由于页表工作的方式，操作系统没有必要分配 k) Tj
T*
(个连续的物理内存页面。页面可以随机地分散在物理内存中。) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
493 0 obj
<< /Length 3438 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(================================================================================) Tj
T*
(9.5 虚拟内存作为内存保护的工具) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(9.5 虚拟内存作为内存保护的工具) Tj
T*
() Tj
T*
() Tj
T*
(任何现代计算机系统必须为操作系统提供手段来控制对内存系统的访问。不应该允许一个用户进程修改它的只读代码段。而且也不应该允许它读或修改任何内核中的代码和数据结构。不应该允许它读或者写) Tj
T*
(其他进程的私有内存，并且不允许它修改任何与其他进程共享的虚拟页面，除非所有的共享者都显式地允许它这么做（通过调用明确的进程间通信系统调用）。) Tj
T*
() Tj
T*
(就像我们所看到的，提供独立的地址空间使得区分不同进程的私有内存变得容易。但是，地址翻译机制可以以一种自然的方式扩展到提供更好的访问控制。因为每次 CPU) Tj
T*
(生成一个地址时，地址翻译硬件都会读一个 PTE，所以通过在 PTE 上添加一些额外的许可位来控制对一个虚拟页面内容的访问十分简单。图 9-10 展示了大致的思想。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-10 &#x7528;&#x865A;&#x62DF;&#x5185;&#x5B58;&#x6765;&#x63D0;&#x4F9B;&#x9) Tj
T*
(875;&#x9762;&#x7EA7;&#x7684;&#x5185;&#x5B58;&#x4FDD;&#x62A4;]) Tj
T*
() Tj
T*
(在这个示例中，每个 PTE 中已经添加了三个许可位。SUP) Tj
T*
(位表示进程是否必须运行在内核（超级用户）模式下才能访问该页。运行在内核模式中的进程可以访问任何页面，但是运行在用户模式中的进程只允许访问那些 SUP 为 0 的页面。READ 位和) Tj
T*
(WRITE 位控制对页面的读和写访问。例如，如果进程 i 运行在用户模式下，那么它有读 VP 0 和读写 VP 1 的权限。然而，不允许它访问 VP 2。) Tj
T*
() Tj
T*
(如果一条指令违反了这些许可条件，那么 CPU 就触发一个一般保护故障，将控制传递给一个内核中的异常处理程序。Linux shell) Tj
T*
(一般将这种异常报告为“段错误（segmentation fault）”。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(9.6 地址翻译) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(9.6 地址翻译) Tj
T*
() Tj
T*
() Tj
T*
(这一节讲述的是地址翻译的基础知识。我们的目标是让你了解硬件在支持虚拟内存中的角色，并给出足够多的细节使得你可以亲手演示一些具体的示例。不过，要记住我们省略了大量的细节，尤其是和时序) Tj
T*
(相关的细节，虽然这些细节对硬件设计者来说是非常重要的，但是超出了我们讨论的范围。图 9-11 概括了我们在这节里将要使用的所有符号，供读者参考。) Tj
T*
() Tj
T*
(> 基本参数) Tj
T*
() Tj
T*
(| 符号 | 描述 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| $$\\small N=2^n$$  | 虚拟地址空间中的地址数量 |) Tj
T*
(| $$\\small M=2^m$$ | 物理地址空间中的地址数量 |) Tj
T*
(| $$\\small P=2^p$$ | 页的大小（字节） |) Tj
T*
() Tj
T*
(> 虚拟地址（VA）的组成部分) Tj
T*
() Tj
T*
(| 符号 | 描述 |) Tj
T*
(| :--- | :--- |) Tj
T*
ET
endstream
endobj
494 0 obj
<< /Length 2360 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(| VPO | 虚拟页面偏移量（字节） |) Tj
T*
(| VPN | 虚拟页号 |) Tj
T*
(| TLBI | TLB 索引 |) Tj
T*
(| TLBT | TLB 标记 |) Tj
T*
() Tj
T*
(> 物理地址（PA）的组成部分) Tj
T*
() Tj
T*
(| 符号 | 描述 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| PPO | 物理页面偏移量（字节） |) Tj
T*
(| PPN | 物理页号 |) Tj
T*
(| CO | 缓冲块内的字节偏移量 |) Tj
T*
(| CI | 高速缓存索引 |) Tj
T*
(| CT | 高速缓存标记 |) Tj
T*
() Tj
T*
(> 图 9-11 地址翻译符号小结) Tj
T*
() Tj
T*
(形式上来说，地址翻译是一个 N 元素的虚拟地址空间（VAS）中的元素和一个 M 元素的物理地址空间（PAS）中元素之间的映射，) Tj
T*
() Tj
T*
($$) Tj
T*
(\\rm MAP: VAS \\rightarrow PAS \\cup Ø) Tj
T*
($$) Tj
T*
() Tj
T*
(这里) Tj
T*
() Tj
T*
($$) Tj
T*
(\\rm MAP\(A\) = \\begin{cases}) Tj
T*
(A' &\\text{如果虚拟地址 } A \\text{ 处的数据在 PAS 的物理地址 } A' \\text{ 处}\\\\) Tj
T*
(Ø &\\text{如果虚拟地址 } A \\text{ 处的数据不在物理内存中}) Tj
T*
(\\end{cases}) Tj
T*
($$) Tj
T*
() Tj
T*
(图 9-12 展示了 MMU 如何利用页表来实现这种映射。CPU 中的一个控制寄存器，页表基址寄存器（Page Table Base Register，PTBR）指向当前页表。n) Tj
T*
(位的虚拟地址包含两个部分：一个 p 位的虚拟页面偏移（Virtual Page Offset，VPO）和一个$$\\small \(n-p\)$$位的虚拟页号（Virtual Page) Tj
T*
(Number，VPN）。MMU 利用 VPN 来选择适当的 PTE。例如，VPN 0 选择 PTE 0，VPN 1 选择 PTE) Tj
T*
(1，以此类推。将页表条目中物理页号（Physical Page Number，PPN）和虚拟地址中的 VPO 串联起来，就得到相应的物理地址。注意，因为物理和虚拟页面都是 P) Tj
T*
(字节的，所以物理页面偏移（Physical Page Offset，PPO）和 VPO 是相同的。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-12) Tj
T*
(&#x4F7F;&#x7528;&#x9875;&#x8868;&#x7684;&#x5730;&#x5740;&#x7FFB;&#x8BD1;]) Tj
T*
() Tj
T*
(图 9-13a 展示了当页面命中时，CPU 硬件执行的步骤。) Tj
T*
() Tj
T*
(* 第 1 步：处理器生成一个虚拟地址，并把它传送给 MMU。) Tj
T*
(* 第 2 步：MMU 生成 PTE 地址，并从高速缓存/主存请求得到它。) Tj
T*
(* 第 3 步：高速缓存/主存向 MMU 返回 PTE。) Tj
T*
ET
endstream
endobj
495 0 obj
<< /Length 3188 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(* 第 4 步：MMU 构造物理地址，并把它传送给高速缓存/主存。) Tj
T*
(* 第 5 步：高速缓存/主存返回所请求的数据字给处理器。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 9-13 页面命中（a）和缺页（b）的操作图) Tj
T*
(>) Tj
T*
(> （VA：虚拟地址。PTEA：页表条目地址。PTE：页表条目。PA：物理地址）) Tj
T*
() Tj
T*
(页面命中完全是由硬件来处理的，与之不同的是，处理缺页要求硬件和操作系统内核协作完成，如图 9-13b 所示。) Tj
T*
() Tj
T*
(* 第 1 步到第 3 步：和图 9-13a 中的第 1 步到第 3 步相同。) Tj
T*
(* 第 4 步：PTE 中的有效位是零，所以 MMU 触发了一次异常，传递 CPU 中的控制到操作系统内核中的缺页异常处理程序。) Tj
T*
(* 第 5 步：缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。) Tj
T*
(* 第 6 步：缺页处理程序页面调入新的页面，并更新内存中的 PTE。) Tj
T*
(* 第 7 步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU 将引起缺页的虚拟地址重新发送给 MMU。因为虚拟页面现在缓存在物理内存中，所以就会命中，在 MMU) Tj
T*
(执行了图 9-13b 中的步骤之后，主存就会将所请求字返回给处理器。) Tj
T*
() Tj
T*
(练习题 9.3) Tj
T*
() Tj
T*
() Tj
T*
(给定一个 32 位的虚拟地址空间和一个 24 位的物理地址，对于下面的页面大小 P，确定 VPN、VPO、PPN 和 PPO 中的位数：) Tj
T*
() Tj
T*
(| P | VPN 位数 | VPO 位数 | PPN 位数 | PPO 位数 |) Tj
T*
(| :---: | :---: | :---: | :---: | :---: |) Tj
T*
(| 1 KB |  |  |  |  |) Tj
T*
(| 2 KB |  |  |  |  |) Tj
T*
(| 4 KB |  |  |  |  |) Tj
T*
(| 8 KB |  |  |  |  |) Tj
T*
() Tj
T*
(为了完全掌握地址翻译，你需要很好地理解这类问题。下面是如何解决第一个子问题：我们有 n=32 个虚拟地址位和 m=24 个物理地址位。页面大小是$$\\small P = 1~\\rm) Tj
T*
(KB$$，这意味着对于 VPO 和 PPO，我们都需要 $$\\small \\rm log_2\(1K\)=10$$ 位。（回想一下，VPO 和 PPO 是相同的。）剩下的地址位分别是) Tj
T*
(VPN 和 PPN。) Tj
T*
() Tj
T*
(| P | VPN 位数 | VPO 位数 | PPN 位数 | PPO 位数 |) Tj
T*
(| :---: | :---: | :---: | :---: | :---: |) Tj
T*
(| 1 KB | 22 | 10 | 14 | 10 |) Tj
T*
(| 2 KB | 21 | 11 | 13 | 11 |) Tj
T*
(| 4 KB | 20 | 12 | 12 | 12 |) Tj
T*
(| 8 KB | 19 | 13 | 11 | 13 |) Tj
T*
() Tj
T*
(9.6.1 结合高速缓存和虚拟内存) Tj
T*
() Tj
T*
() Tj
T*
(在任何既使用虚拟内存又使用 SRAM 高速缓存的系统中，都有应该使用虚拟地址还是使用物理地址来访问 SRAM 高速缓存的问题。尽管关于这个折中的详细讨论已经超出了我们的讨论范围，但) Tj
T*
(是大多数系统是选择物理寻址的。使用物理寻址，多个进程同时在高速缓存中有存储块和共享来自相同虚拟页面的块成为很简单的事情。而且，高速缓存无需处理保护问题，因为访问权限的检査是地址翻译) Tj
T*
ET
endstream
endobj
496 0 obj
<< /Length 3594 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(过程的一部分。) Tj
T*
() Tj
T*
(图 9-14 展示了一个物理寻址的高速缓存如何和虚拟内存结合起来。主要的思路是地址翻译发生在高速缓存查找之前。注意，页表条目可以缓存，就像其他的数据字一样。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 9-14 将 VM 与物理寻址的高速缓存结合起来) Tj
T*
(>) Tj
T*
(> （VA：虚拟地址。PTEA：页表条目地址。PTE：页表条目。PA：物理地址）) Tj
T*
() Tj
T*
(9.6.2 利用 TLB 加速地址翻译) Tj
T*
() Tj
T*
() Tj
T*
(正如我们看到的，每次 CPU 产生一个虚拟地址，MMU 就必须查阅一个) Tj
T*
(PTE，以便将虚拟地址翻译为物理地址。在最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期。如果 PTE 碰巧缓存在 L1 中，那么开销就下降到 1 个或 2) Tj
T*
(个周期。然而，许多系统都试图消除即使是这样的开销，它们在 MMU 中包括了一个关于 PTE 的小的缓存，称为翻译后备缓冲器（Translation Lookaside) Tj
T*
(Buffer，TLB）。) Tj
T*
() Tj
T*
(TLB 是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个 PTE 组成的块。TLB 通常有高度的相联度。如图 9-15) Tj
T*
(所示，用于组选择和行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果 TLB 有$$\\small T = 2^t$$个组，那么 TLB 索引（TLBI）是由 VPN) Tj
T*
(的 t 个最低位组成的，而 TLB 标记（TLBT）是由 VPN 中剩余的位组成的。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-15) Tj
T*
(&#x865A;&#x62DF;&#x5730;&#x5740;&#x4E2D;&#x7528;&#x4EE5;&#x8BBF;&#x95EE; TLB) Tj
T*
(&#x7684;&#x7EC4;&#x6210;&#x90E8;&#x5206;]) Tj
T*
() Tj
T*
(图 9-16a 展示了当 TLB 命中时（通常情况）所包括的步骤。这里的关键点是，所有的地址翻译步骤都是在芯片上的 MMU 中执行的，因此非常快。) Tj
T*
() Tj
T*
(* 第 1 步：CPU 产生一个虚拟地址。) Tj
T*
(* 第 2 步和第 3 步：MMU 从 TLB 中取出相应的 PTE。) Tj
T*
(* 第 4 步：MMU 将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。) Tj
T*
(* 第 5 步：高速缓存/主存将所请求的数据字返回给 CPU。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-16 TLB) Tj
T*
(&#x547D;&#x4E2D;&#x548C;&#x4E0D;&#x547D;&#x4E2D;&#x7684;&#x64CD;&#x4F5C;&#x56FE;]) Tj
T*
() Tj
T*
(当 TLB 不命中时，MMU 必须从 L1 缓存中取出相应的 PTE，如图 9-16b 所示。新取出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的条目。) Tj
T*
() Tj
T*
(9.6.3 多级页表) Tj
T*
() Tj
T*
() Tj
T*
(到目前为止，我们一直假设系统只用一个单独的页表来进行地址翻译。但是如果我们有一个 32 位的地址空间、4KB 的页面和一个 4 字节的) Tj
T*
(PTE，那么即使应用所引用的只是虚拟地址空间中很小的一部分，也总是需要一个 4MB 的页表驻留在内存中。对于地址空间为 64 位的系统来说，问题将变得更复杂。) Tj
T*
() Tj
T*
(用来压缩页表的常用方法是使用层次结构的页表。用一个具体的示例是最容易理解这个思想的。假设 32 位虚拟地址空间被分为 4KB 的页，而每个页表条目都是 4) Tj
T*
(字节。还假设在这一时刻，虚拟地址空间有如下形式：内存的前 2K 个页面分配给了代码和数据，接下来的 6K 个页面还未分配，再接下来的 1023 个页面也未分配，接下来的 1) Tj
T*
ET
endstream
endobj
497 0 obj
<< /Length 4152 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(个页面分配给了用户栈。图 9-17 展示了我们如何为这个虚拟地址空间构造一个两级的页表层次结构。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-17 &#x4E00;&#x4E2A;&#x4E24;&#x7EA7;&#x9875;&#x8868;&#x5C42;&#x6B21;&#x7) Tj
T*
(ED3;&#x6784;&#x3002;&#x6CE8;&#x610F;&#x5730;&#x5740;&#x662F;&#x4ECE;&#x4E0A;&#x5F80;&#x4E0) Tj
T*
(B;&#x589E;&#x52A0;&#x7684;]) Tj
T*
() Tj
T*
(一级页表中的每个 PTE 负责映射虚拟地址空间中一个 4MB 的片（chunk），这里每一片都是由 1024 个连续的页面组成的。比如，PTE 0 映射第一片，PTE 1) Tj
T*
(映射接下来的一片，以此类推。假设地址空间是 4GB，1024 个 PTE 已经足够覆盖整个空间了。) Tj
T*
() Tj
T*
(如果片 i 中的每个页面都未被分配，那么一级 PTE i 就为空。例如，图 9-17 中，片 2 ~ 7 是未被分配的。然而，如果在片 i 中至少有一个页是分配了的，那么一级) Tj
T*
(PTE i 就指向一个二级页表的基址。例如，在图 9-17 中，片 0、1 和 8 的所有或者部分已被分配，所以它们的一级 PTE 就指向二级页表。) Tj
T*
() Tj
T*
(二级页表中的每个 PTE 都负责映射一个 4KB 的虚拟内存页面，就像我们查看只有一级的页表一样。注意，使用 4 字节的 PTE，每个一级和二级页表都是 4KB) Tj
T*
(字节，这刚好和一个页面的大小是一样的。) Tj
T*
() Tj
T*
(这种方法从两个方面减少了内存要求。第一，如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不会存在。这代表着一种巨大的潜在节约，因为对于一个典型的程序，4GB 的虚拟地) Tj
T*
(址空间的大部分都会是未分配的。第二，只有一级页表才需要总是在主存中；虚拟内存系统可以在需要时创建、页面调入或调出二级页表，这就减少了主存的压力；只有最经常使用的二级页表才需要缓存在) Tj
T*
(主存中。) Tj
T*
() Tj
T*
(图 9-18 描述了使用 k 级页表层次结构的地址翻译。虚拟地址被划分成为 k 个 VPN 和 1 个 VPO。每个 VPN i 都是一个到第 i 级页表的索引，其中) Tj
T*
($$\\small 1\\leqslant i \\leqslant k$$ 。第 j 级页表中的每个 PTE，$$\\small 1 \\leqslant j \\leqslant) Tj
T*
(k-1$$，都指向第 j+1 级的某个页表的基址。第 k 级页表中的每个 PTE 包含某个物理页面的 PPN，或者一个磁盘块的地址。为了构造物理地址，在能够确定 PPN) Tj
T*
(之前，MMU 必须访问为个 PTE。对于只有一级的页表结构，PPO 和 VPO 是相同的。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-18 &#x4F7F;&#x7528; k) Tj
T*
(&#x7EA7;&#x9875;&#x8868;&#x7684;&#x5730;&#x5740;&#x7FFB;&#x8BD1;]) Tj
T*
() Tj
T*
(访问 k 个 PTE，第一眼看上去昂贵而不切实际。然而，这里 TLB 能够起作用，正是通过将不同层次上页表的 PTE 缓存起来。实际上，带多级页表的地址翻译并不比单级页表慢很多。) Tj
T*
() Tj
T*
(9.6.4 综合：端到端的地址翻译) Tj
T*
() Tj
T*
() Tj
T*
(在这一节里，我们通过一个具体的端到端的地址翻译示例，来综合一下我们刚学过的这些内容，这个示例运行在有一个 TLB 和 L1 d-cache) Tj
T*
(的小系统上。为了保证可管理性，我们做出如下假设：) Tj
T*
() Tj
T*
(* 内存是按字节寻址的。) Tj
T*
(* 内存访问是针对 1 字节的字的（不是 4 字节的字）。) Tj
T*
(* 虚拟地址是 14 位长的（$$\\small n=14$$）。) Tj
T*
(* 物理地址是 12 位长的（$$\\small m =12$$）。) Tj
T*
(* 页面大小是 64 字节（$$\\small P=64$$）。) Tj
T*
(* TLB 是四路组相联的，总共有 16 个条目。) Tj
T*
(* L1 d-cache 是物理寻址、直接映射的，行大小为 4 字节，而总共有 16 个组。) Tj
T*
() Tj
T*
(图 9-19 展示了虚拟地址和物理地址的格式。因为每个页面是$$\\small 2^6=64$$字节，所以虚拟地址和物理地址的低 6 位分别作为 VPO 和 PPO。虚拟地址的高 8) Tj
T*
(位作为 VPN。物理地址的高 6 位作为 PPN。) Tj
T*
() Tj
T*
ET
endstream
endobj
498 0 obj
<< /Length 4110 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
([Image: Image]) Tj
T*
() Tj
T*
(> 图 9-19 小内存系统的寻址。假设 14 位的虚拟地址（n=14），12 位的物理地址（m=12）和 64 字节的页面（P=64）) Tj
T*
() Tj
T*
(图 9-20 展示了小内存系统的一个快照，包括 TLB（图 9-20a）、页表的一部分（图 9-20b）和 L1 高速缓存（图 9-20c）。在 TLB) Tj
T*
(和高速缓存的图上面，我们还展示了访问这些设备时硬件是如何划分虚拟地址和物理地址的位的。) Tj
T*
() Tj
T*
(* TLB。TLB 是利用 VPN 的位进行虚拟寻址的。因为 TLB 有 4 个组，所以 VPN 的低 2 位就作为组索引（TLBI）。VPN 中剩下的高 6) Tj
T*
(位作为标记（TLBT），用来区别可能映射到同一个 TLB 组的不同的 VPN。) Tj
T*
(* 页表。这个页表是一个单级设计，一共有$$2^8=256$$个页表条目（PTE）。然而，我们只对这些条目中的开头 16 个感兴趣。为了方便，我们用索引它的 VPN 来标识每个) Tj
T*
(PTE；但是要记住这些 VPN 并不是页表的一部分，也不储存在内存中。另外，注意每个无效 PTE 的 PPN) Tj
T*
(都用一个破折号来表示，以加强一个概念：无论刚好这里存储的是什么位值，都是没有任何意义的。) Tj
T*
(* 高速缓存。直接映射的缓存是通过物理地址中的字段来寻址的。因为每个块都是 4 字节，所以物理地址的低 2 位作为块偏移（CO）。因为有 16 组，所以接下来的 4) Tj
T*
(位就用来表示组索引（CI）。剩下的 6 位作为标记（CT）。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-20 \\\(a\\\) &#x5C0F;&#x5185;&#x5B58;&#x7CFB;&#x7EDF;&#x7684; TLB&#xFF1A;&#) Tj
T*
(x56DB;&#x7EC4;&#xFF0C;16&#x4E2A;&#x6761;&#x76EE;&#xFF0C;&#x56DB;&#x8DEF;&#x7EC4;&#x76F8;&#) Tj
T*
(x8054;]) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-20 \\\(b\\\) &#x5C0F;&#x5185;&#x5B58;&#x7CFB;&#x7EDF;&#x7684;&#x9875;&#x886) Tj
T*
(8;&#xFF1A;&#x53EA;&#x5C55;&#x793A;&#x4E86;&#x524D; 16 &#x4E2A; PTE]) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-20 \\\(c\\\)) Tj
T*
(&#x5C0F;&#x5185;&#x5B58;&#x7CFB;&#x7EDF;&#x7684;&#x9AD8;&#x901F;&#x7F13;&#x5B58;&#xFF1A;16) Tj
T*
(&#x4E2A;&#x7EC4;&#xFF0C;4) Tj
T*
(&#x5B57;&#x8282;&#x7684;&#x5757;&#xFF0C;&#x76F4;&#x63A5;&#x6620;&#x5C04;]) Tj
T*
() Tj
T*
(> 图 9-20 小内存系统的 TLB、页表以及缓存。TLB、页表和缓存中所有的值都是十六进制表示的) Tj
T*
() Tj
T*
(给定了这种初始化设定，让我们来看看当 CPU 执行一条读地址 0x03d4 处字节的加载指令时会发生什么。（回想一下我们假定 CPU 读取 1 字节的字，而不是 4) Tj
T*
(字节的字。）为了开始这种手工的模拟，我们发现写下虚拟地址的各个位，标识出我们会需要的各种字段，并确定它们的十六进制值，是非常有帮助的。当硬件解码地址时，它也执行相似的任务。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(开始时，MMU 从虚拟地址中抽取出 VPN（0x0F），并且检查 TLB，看它是否因为前面的某个内存引用缓存了 PTE 0x0F 的一个副本。TLB 从 VPN 中抽取出 TLB) Tj
T*
(索引（0x03）和 TLB 标记（0x3），组 0x3 的第二个条目中有效匹配，所以命中，然后将缓存的 PPN（0x0D）返回给 MMU。) Tj
T*
() Tj
T*
(如果 TLB 不命中，那么 MMU 就需要从主存中取出相应的 PTE。然而，在这种情况中，我们很幸运，TLB 会命中。现在，MMU 有了形成物理地址所需要的所有东西。它通过将来自) Tj
T*
(PTE 的 PPN（0x0D）和来自虚拟地址的 VPO（0x14）连接起来，这就形成了物理地址（0x354）。) Tj
T*
() Tj
T*
(接下来，MMU 发送物理地址给缓存，缓存从物理地址中抽取出缓存偏移 CO（0x0）、缓存组索引 CI（0x5）以及缓存标记 CT（0x0D）。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(因为组 0x5 中的标记与 CT 相匹配，所以缓存检测到一个命中，读出在偏移量 CO 处的数据字节（0x36），并将它返回给 MMU，随后 MMU 将它传递回 CPU。) Tj
T*
() Tj
T*
ET
endstream
endobj
499 0 obj
<< /Length 2205 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(翻译过程的其他路径也是可能的。例如，如果 TLB 不命中，那么 MMU 必须从页表中的 PTE 中取出 PPN。如果得到的 PTE) Tj
T*
(是无效的，那么就产生一个缺页，内核必须调入合适的页面，重新运行这条加载指令。另一种可能性是 PTE 是有效的，但是所需要的内存块在缓存中不命中。) Tj
T*
() Tj
T*
(练习题 9.4) Tj
T*
() Tj
T*
() Tj
T*
(说明 9.6.4 节中的示例内存系统是如何将一个虚拟地址翻译成一个物理地址和访问缓存的。对于给定的虚拟地址，指明访问的 TLB 条目、物理地址和返回的缓存字节值。指出是否发生了) Tj
T*
(TLB 不命中，是否发生了缺页，以及是否发生了缓存不命中。如果是缓存不命中，在“返回的缓存字节”栏中输入 “—”。如果有缺页，则在 “PPN” 一栏中输入 “—”，并且将 C) Tj
T*
(部分和 D 部分空着。) Tj
T*
() Tj
T*
(虚拟地址：0x03d7) Tj
T*
() Tj
T*
(A. 虚拟地址格式) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(B. 地址翻译) Tj
T*
() Tj
T*
(| 参数 | 值 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| VPN |  |) Tj
T*
(| TLB 索引 |  |) Tj
T*
(| TLB 标记 |  |) Tj
T*
(| TLB 命中？（是/否） |  |) Tj
T*
(| 缺页？（是/否） |  |) Tj
T*
(| PPN |  |) Tj
T*
() Tj
T*
(C. 物理地址格式) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(D. 物理内存引用) Tj
T*
() Tj
T*
(| 参数 | 值 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| 字节偏移 |  |) Tj
T*
(| 缓存索引 |  |) Tj
T*
(| 缓存标记 |  |) Tj
T*
(| 缓存命中？（是/否） |  |) Tj
T*
(| 返回的缓存字节 |  |) Tj
T*
() Tj
T*
(做一些这样的手工模拟，能很好地巩固你对地址翻译的理解。你会发现写出地址中的所有的位，然后在不同的位字段上画出方框，例如 VPN、TLBI) Tj
T*
(等，这会很有帮助。在这个特殊的练习中，没有任何类型的不命中：TLB 有一份 PTE 的副本，而缓存有一份所请求数据字的副本。对于命中和不命中的一些不同的组合，请参见习题) Tj
T*
(9.11、9.12 和 9.13。) Tj
T*
() Tj
T*
(A. 00 0011 1101 0111) Tj
T*
ET
endstream
endobj
500 0 obj
<< /Length 2305 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(B.) Tj
T*
() Tj
T*
(| 参数 | 值 |) Tj
T*
(| :--- | :---: |) Tj
T*
(| VPN | 0xf |) Tj
T*
(| TLB 索引 | 0x3 |) Tj
T*
(| TLB 标记 | 0x3 |) Tj
T*
(| TLB 命中？（是/否） | 是 |) Tj
T*
(| 缺页？（是/否） | 否 |) Tj
T*
(| PPN | 0xd |) Tj
T*
() Tj
T*
(C. 0011 0101 0111) Tj
T*
() Tj
T*
(D.) Tj
T*
() Tj
T*
(| 参数 | 值 |) Tj
T*
(| :--- | :---: |) Tj
T*
(| 字节偏移 | 0x3 |) Tj
T*
(| 缓存索引 | 0x5 |) Tj
T*
(| 缓存标记 | 0xd |) Tj
T*
(| 缓存命中？（是/否） | 是 |) Tj
T*
(| 返回的缓存字节 | 0x1d |) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(9.7 案例研究：Intel Core i7 / Linux 内存系统) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(9.7 案例研究：Intel Core i7 / Linux 内存系统) Tj
T*
() Tj
T*
() Tj
T*
(我们以一个实际系统的案例研究来总结我们对虚拟内存的讨论：一个运行 Linux 的 Intel Core i7。虽然底层的 Haswell 微体系结构允许完全的 64) Tj
T*
(位虚拟和物理地址空间，而现在的（以及可预见的未来的）Core i7 实现支持 48 位（256 TB）虚拟地址空间和 52 位（4 PB）物理地址空间，还有一个兼容模式，支持 32) Tj
T*
(位（4 GB）虚拟和物理地址空间。) Tj
T*
() Tj
T*
(图 9-21 给出了 Corei7 内存系统的重要部分。处理器封装（processor package）包括四个核、一个大的所有核共享的 L3 高速缓存，以及一个 DDR3) Tj
T*
(内存控制器。每个核包含一个层次结构的 TLB、一个层次结构的数据和指令高速缓存，以及一组快速的点到点链路，这种链路基于 QuickPath 技术，是为了让一个核与其他核和外部) Tj
T*
(I/O 桥直接通信。TLB 是虚拟寻址的，是四路组相联的。L1、L2 和 L3 高速缓存是物理寻址的，块大小为 64 字节。L1 和 L2 是 8 路组相联的，而 L3 是 16) Tj
T*
(路组相联的。页大小可以在启动时被配置为 4 KB 或 4 MB。Linux 使用的是 4 KB 的页。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-21 Core i7 &#x7684;&#x5185;&#x5B58;&#x7CFB;&#x7EDF;]) Tj
T*
() Tj
T*
(9.7.1 Core i7 地址翻译) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
501 0 obj
<< /Length 4439 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(图 9-22 总结了完整的 Core i7 地址翻译过程，从 CPU 产生虚拟地址的时刻一直到来自内存的数据字到达 CPU。Core i7) Tj
T*
(采用四级页表层次结构。每个进程有它自己私有的页表层次结构。当一个 Linux 进程在运行时，虽然 Core i7) Tj
T*
(体系结构允许页表换进换出，但是与已分配了的页相关联的页表都是驻留在内存中的。CR3 控制寄存器指向第一级页表（L1）的起始位置。CR3) Tj
T*
(的值是每个进程上下文的一部分，每次上下文切换时，CR3 的值都会被恢复。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-22 Core i7 &#x5730;&#x5740;&#x7FFB;&#x8BD1;&#x7684;&#x6982;&#x51B5;&#x3) Tj
T*
(002;&#x4E3A;&#x4E86;&#x7B80;&#x5316;&#xFF0C;&#x6CA1;&#x6709;&#x663E;&#x793A;) Tj
T*
(i-cache&#x3001;i-TLB &#x548C; L2 &#x7EDF;&#x4E00; TLB]) Tj
T*
() Tj
T*
(图 9-23 给出了第一级、第二级或第三级页表中条目的格式。当 $$\\small P=1$$ 时（Linux 中就总是如此），地址字段包含一个 40) Tj
T*
(位物理页号（PPN），它指向适当的页表的开始处。注意，这强加了一个要求，要求物理页表 4 KB 对齐。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-23 &#x7B2C;&#x4E00;&#x7EA7;&#x3001;&#x7B2C;&#x4E8C;&#x7EA7;&#x548C;&#x7) Tj
T*
(B2C;&#x4E09;&#x7EA7;&#x9875;&#x8868;&#x6761;&#x76EE;&#x683C;&#x5F0F;&#x3002;&#x6BCF;&#x4E2) Tj
T*
(A;&#x6761;&#x76EE;&#x5F15;&#x7528;&#x4E00;&#x4E2A; 4 KB &#x5B50;&#x9875;&#x8868;]) Tj
T*
() Tj
T*
(图 9-24 给出了第四级页表中条目的格式。当$$\\small P=1$$，地址字段包括一个 40 位 PPN，它指向物理内存中某一页的基地址。这又强加了一个要求，要求物理页 4) Tj
T*
(KB 对齐。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-24 &#x7B2C;&#x56DB;&#x7EA7;&#x9875;&#x8868;&#x6761;&#x76EE;&#x7684;&#x6) Tj
T*
(83C;&#x5F0F;&#x3002;&#x6BCF;&#x4E2A;&#x6761;&#x76EE;&#x5F15;&#x7528;&#x4E00;&#x4E2A; 4 KB) Tj
T*
(&#x5B50;&#x9875;]) Tj
T*
() Tj
T*
(PTE 有三个权限位，控制对页的访问。R/W 位确定页的内容是可以读写的还是只读的。U/S) Tj
T*
(位确定是否能够在用户模式中访问该页，从而保护操作系统内核中的代码和数据不被用户程序访问。XD（禁止执行）位是在 64) Tj
T*
(位系统中引入的，可以用来禁止从某些内存页取指令。这是一个重要的新特性，通过限制只能执行只读代码段，使得操作系统内核降低了缓冲区溢出攻击的风险。) Tj
T*
() Tj
T*
(当 MMU 翻译每一个虚拟地址时，它还会更新另外两个内核缺页处理程序会用到的位。每次访问一个页时，MMU 都会设置 A 位，称为引用位（reference) Tj
T*
(bit）。内核可以用这个引用位来实现它的页替换算法。每次对一个页进行了写之后，MMU 都会设置 D 位，又称修改位或脏位（dirty) Tj
T*
(bit）。修改位告诉内核在复制替换页之前是否必须写回牺牲页。内核可以通过调用一条特殊的内核模式指令来清除引用位或修改位。) Tj
T*
() Tj
T*
(图 9-25 给出了 Core i7 MMU 如何使用四级的页表来将虚拟地址翻译成物理地址。36 位 VPN 被划分成四个 9 位的片，每个片被用作到一个页表的偏移量。CR3) Tj
T*
(寄存器包含 L1 页表的物理地址。VPN 1 提供到一个 L1 PTE 的偏移量，这个 PTE 包含 L2 页表的基地址。VPN 2 提供到一个 L2 PTE 的偏移量，以此类推。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 9-25Corei7 页表翻译) Tj
T*
(>) Tj
T*
(> （PT：页表，PTE：页表条目，VPN：虚拟页号，VPO：虚拟页偏移，PPN：物理页号，PPO：物理页偏移量。图中还给出了这四级页表的 Linux 名字）) Tj
T*
() Tj
T*
(旁注 - 优化地址翻译) Tj
T*
() Tj
T*
() Tj
T*
(在对地址翻译的讨论中，我们描述了一个顺序的两个步骤的过程，1）MMU 将虚拟地址翻译成物理地址，2）将物理地址传送到 L1) Tj
T*
(高速缓存。然而，实际的硬件实现使用了一个灵活的技巧，允许这些步骤部分重叠，因此也就加速了对 L1 高速缓存的访问。例如，页面大小为 4KB 的 Corei7 系统上的一个虚拟地址有) Tj
T*
(12 位的 VPO，并且这些位和相应物理地址中的 PPO 的 12 位是相同的。因为八路组相联的、物理寻址的 L1 高速缓存有 64 个组和大小为 64) Tj
T*
ET
endstream
endobj
502 0 obj
<< /Length 4563 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(字节的缓存块，每个物理地址有 6 个（$$\\rm log264$$）缓存偏移位和 6 个（$$\\rm log264$$）索引位。这 12 位恰好符合虚拟地址的 VPO) Tj
T*
(部分，这绝不是偶然！当 CPU 需要翻译一个虚拟地址时，它就发送 VPN 到 MMU，发送 VPO 到高速 L1 缓存。当 MMU 向 TLB 请求一个页表条目时，L1) Tj
T*
(高速缓存正忙着利用 VPO 位查找相应的组，并读出这个组里的 8 个标记和相应的数据字。当 MMU 从 TLB 得到 PPN 时，缓存已经准备好试着把这个 PPN 与这 8) Tj
T*
(个标记中的一个进行匹配了。) Tj
T*
() Tj
T*
(9.7.2 Linux 虚拟内存系统) Tj
T*
() Tj
T*
() Tj
T*
(一个虚拟内存系统要求硬件和内核软件之间的紧密协作。版本与版本之间细节都不尽相同，对此完整的阐释超出了我们讨论的范围。但是，在这一小节中我们的目标是对 Linux) Tj
T*
(的虚拟内存系统做一个描述，使你能够大致了解一个实际的操作系统是如何组织虚拟内存，以及如何处理缺页的。) Tj
T*
() Tj
T*
(Linux 为每个进程维护了一个单独的虚拟地址空间，形式如图 9-26) Tj
T*
(所示。我们已经多次看到过这幅图了，包括它那些熟悉的代码、数据、堆、共享库以及栈段。既然我们理解了地址翻译，就能够填入更多的关于内核虚拟内存的细节了，这部分虚拟内存位于用户栈之上。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-26 &#x4E00;&#x4E2A; Linux) Tj
T*
(&#x8FDB;&#x7A0B;&#x7684;&#x865A;&#x62DF;&#x5185;&#x5B58;]) Tj
T*
() Tj
T*
(内核虚拟内存包含内核中的代码和数据结构。内核虚拟内存的某些区域被映射到所有进程共享的物理页面。例如，每个进程共享内核的代码和全局数据结构。有趣的是，Linux) Tj
T*
(也将一组连续的虚拟页面（大小等于系统中 DRAM) Tj
T*
(的总量）映射到相应的一组连续的物理页面。这就为内核提供了一种便利的方法来访问物理内存中任何特定的位置，例如，当它需要访问页表，或在一些设备上执行内存映射的 I/O) Tj
T*
(操作，而这些设备被映射到特定的物理内存位置时。) Tj
T*
() Tj
T*
(内核虚拟内存的其他区域包含每个进程都不相同的数据。比如说，页表、内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。) Tj
T*
() Tj
T*
(1. Linux 虚拟内存区域) Tj
T*
() Tj
T*
() Tj
T*
(Linux 将虚拟内存组织成一些区域（也叫做段）的集合。一个区域（area）就是已经存在着的（已分配的）虚拟内存的连续片（chunk），这些页是以某种方式相关联的。例如，代码段、数) Tj
T*
(据段、堆、共享库段，以及用户栈都是不同的区域。每个存在的虚拟页面都保存在某个区域中，而不属于某个区域的虚拟页是不存在的，并且不能被进程引用。区域的概念很重要，因为它允许虚拟地址空间) Tj
T*
(有间隙。内核不用记录那些不存在的虚拟页，而这样的页也不占用内存、磁盘或者内核本身中的任何额外资源。) Tj
T*
() Tj
T*
(图 9-27 强调了记录一个进程中虚拟内存区域的内核数据结构。内核为系统中的每个进程维护一个单独的任务结构（源代码中的) Tj
T*
(task\\_struct）。任务结构中的元素包含或者指向内核运行该进程所需要的所有信息（例如，PID、指向用户栈的指针、可执行目标文件的名字，以及程序计数器）。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-27 Linux) Tj
T*
(&#x662F;&#x5982;&#x4F55;&#x7EC4;&#x7EC7;&#x865A;&#x62DF;&#x5185;&#x5B58;&#x7684;]) Tj
T*
() Tj
T*
(任务结构中的一个条目指向 mm\\struct，它描述了虚拟内存的当前状态。我们感兴趣的两个字段是 pgd 和 mmap，其中 pgd 指向第一级页表（页全局目录）的基址，而) Tj
T*
(mmap 指向一个 vm\\area\\structs（区域结构）的链表，其中每个 vm\\area\\_structs 都描述了当前虚拟地址空间的一个区域。当内核运行这个进程时，就将) Tj
T*
(pgd 存放在 CR3 控制寄存器中。) Tj
T*
() Tj
T*
(为了我们的目的，一个具体区域的区域结构包含下面的字段：) Tj
T*
() Tj
T*
(* vm\\_start：指向这个区域的起始处。) Tj
T*
(* vm\\_end：指向这个区域的结束处。) Tj
T*
(* vm\\_prot：描述这个区域内包含的所有页的读写许可权限。) Tj
T*
ET
endstream
endobj
503 0 obj
<< /Length 4674 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(* vm\\_flags：描述这个区域内的页面是与其他进程共享的，还是这个进程私有的（还描述了其他一些信息）。) Tj
T*
(* vm\\_next：指向链表中下—区域结构。) Tj
T*
() Tj
T*
(2. Linux 缺页异常处理) Tj
T*
() Tj
T*
() Tj
T*
(假设 MMU 在试图翻译某个虚拟地址 A 时，触发了一个缺页。这个异常导致控制转移到内核的缺页处理程序，处理程序随后就执行下面的步骤：) Tj
T*
() Tj
T*
(1. 虚拟地址 A 是合法的吗？换句话说，A 在某个区域结构定义的区域内吗？为了回答这个问题，缺页处理程序搜索区域结构的链表，把 A 和每个区域结构中的 vm\\start 和) Tj
T*
(vm\\end 做比较。如果这个指令是不合法的，那么缺页处理程序就触发一个段错误，从而终止这个进程。这个情况在图 9-28 中标识为 “1”。) Tj
T*
() Tj
T*
(   因为一个进程可以创建任意数量的新虚拟内存区域（使用在下一节中描述的 mmap 函数），所以顺序搜索区域结构的链表花销可能会很大。因此在实际中，Linux) Tj
T*
(   使用某些我们没有显示出来的字段，Linux 在链表中构建了一棵树，并在这棵树上进行查找。) Tj
T*
() Tj
T*
(2. 试图进行的内存访问是否合法？换句话说，进程是否有读、写或者执行这个区域内页面的权限？例如，这个缺页是不是由一条试图对这个代码段里的只读页面进行写操作的存储指令造成的？这个缺页) Tj
T*
(是不是因为一个运行在用户模式中的进程试图从内核虚拟内存中读取字造成的？如果试图进行的访问是不合法的，那么缺页处理程序会触发一个保护异常，从而终止这个进程。这种情况在图 9-28) Tj
T*
(中标识为 “2”。) Tj
T*
(3. 此刻，内核知道了这个缺页是由于对合法的虚拟地址进行合法的操作造成的。它是这样来处理这个缺页的：选择一个牺牲页面，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更) Tj
T*
(新页表。当缺页处理程序返回时，CPU 重新启动引起缺页的指令，这条指令将再次发送 A 到 MMU。这次，MMU 就能正常地翻译 A，而不会再产生缺页中断了。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-28 Linux &#x7F3A;&#x9875;&#x5904;&#x7406;]) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(9.8 内存映射) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(9.8 内存映射) Tj
T*
() Tj
T*
() Tj
T*
(Linux 通过将一个虚拟内存区域与一个磁盘上的对象（object）关联起来，以初始化这个虚拟内存区域的内容，这个过程称为内存映射（memory) Tj
T*
(mapping），虚拟内存区域可以映射到两种类型的对象中的一种：) Tj
T*
() Tj
T*
(1. Linux 文件系统中的普通文件：一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。文件区（section）被分成页大小的片，每一片包含一个虚拟页面的初始) Tj
T*
(内容。因为按需进行页面调度，所以这些虚拟页面没有实际交换进入物理内存，直到 CPU) Tj
T*
(第一次引用到页面（即发射一个虚拟地址，落在地址空间这个页面的范围之内）。如果区域比文件区要大，那么就用零来填充这个区域的余下部分。) Tj
T*
(2. 匿名文件：一个区域也可以映射到一个匿名文件，匿名文件是由内核创建的，包含的全是二进制零。CPU 第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页面) Tj
T*
(，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，将这个页面标记为是驻留在内存中的。注意在磁盘和内存之间并没有实际的数据传送。因为这个原因，映射到匿名文件) Tj
T*
(的区域中的页面有时也叫做请求二进制零的页（demand-zero page）。) Tj
T*
() Tj
T*
(无论在哪种情况中，一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件（swap file）之间换来换去。交换文件也叫做交换空间（swap) Tj
T*
(space）或者交换区域（swap area）。需要意识到的很重要的一点是，在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面的总数。) Tj
T*
() Tj
T*
(9.8.1 再看共享对象) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
504 0 obj
<< /Length 5331 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(内存映射的概念来源于一个聪明的发现：如果虚拟内存系统可以集成到传统的文件系统中，那么就能提供一种简单而高效的把程序和数据加载到内存中的方法。) Tj
T*
() Tj
T*
(正如我们已经看到的，进程这一抽象能够为每个进程提供自己私有的虚拟地址空间，可以免受其他进程的错误读写。不过，许多进程有同样的只读代码区域。例如，每个运行 Linux shell) Tj
T*
(程序 bash 的进程都有相同的代码区域。而且，许多程序需要访问只读运行时库代码的相同副本。例如，每个 C 程序都需要来自标准 C 库的诸如 printf) Tj
T*
(这样的函数。那么，如果每个进程都在物理内存中保持这些常用代码的副本，那就是极端的浪费了。幸运的是，内存映射给我们提供了一种清晰的机制，用来控制多个进程如何共享对象。) Tj
T*
() Tj
T*
(一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，要么作为私有对象。如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那) Tj
T*
(些也把这个共享对象映射到它们虚拟内存的其他进程而言，也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。) Tj
T*
() Tj
T*
(另一方面，对于一个映射到私有对象的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟内存区域叫做共享区) Tj
T*
(域。类似地，也有私有区域。) Tj
T*
() Tj
T*
(假设进程 1 将一个共享对象映射到它的虚拟内存的一个区域中，如图 9-29a 所示。现在假设进程 2 将同一个共享对象映射到它的地址空间（并不一定要和进程 1) Tj
T*
(在相同的虚拟地址处，如图 9-29b 所示）。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-29 &#x4E00;&#x4E2A;&#x5171;&#x4EAB;&#x5BF9;&#x8C61;&#xFF08;&#x6CE8;&#x6) Tj
T*
(10F;&#xFF0C;&#x7269;&#x7406;&#x9875;&#x9762;&#x4E0D;&#x4E00;&#x5B9A;&#x662F;&#x8FDE;&#x7EE) Tj
T*
(D;&#x7684;&#xFF09;]) Tj
T*
() Tj
T*
(因为每个对象都有一个唯一的文件名，内核可以迅速地判定进程 1 已经映射了这个对象，而且可以使进程 2 中的页表条目指向相应的物理页面。关键点在于即使对象被映射到了多个共享区域，物理) Tj
T*
(内存中也只需要存放共享对象的一个副本。为了方便，我们将物理页面显示为连续的，但是在一般情况下当然不是这样的。) Tj
T*
() Tj
T*
(私有对象使用一种叫做写时复制（copy-on-) Tj
T*
(write）的巧妙技术被映射到虚拟内存中。一个私有对象开始生命周期的方式基本上与共享对象的一样，在物理内存中只保存有私有对象的一份副本。比如，图 9-30a 展示了一种情况，其中两) Tj
T*
(个进程将一个私有对象映射到它们虚拟内存的不同区域，但是共享这个对象同一个物理副本。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复) Tj
T*
(制。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理内存中对象的一个单独副本。然而，只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个保护故障。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-30) Tj
T*
(&#x4E00;&#x4E2A;&#x79C1;&#x6709;&#x7684;&#x5199;&#x65F6;&#x590D;&#x5236;&#x5BF9;&#x8C61;]) Tj
T*
() Tj
T*
(当故障处理程序注意到保护异常是由于进程试图写私有的写时复制区域中的一个页面而引起的，它就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写) Tj
T*
(权限，如图 9-30b 所示。当故障处理程序返回时，CPU 重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。) Tj
T*
() Tj
T*
(通过延迟私有对象中的副本直到最后可能的时刻，写时复制最充分地使用了稀有的物理内存。) Tj
T*
() Tj
T*
(9.8.2 再看 fork 函数) Tj
T*
() Tj
T*
() Tj
T*
(既然我们理解了虚拟内存和内存映射，那么我们可以清晰地知道 fork 函数是如何创建一个带有自己独立虚拟地址空间的新进程的。) Tj
T*
() Tj
T*
(当 fork 函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。为了给这个新进程创建虚拟内存，它创建了当前进程的) Tj
T*
(mm\\_struct、区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。) Tj
T*
() Tj
T*
(当 fork 在新进程中返回时，新进程现在的虚拟内存刚好和调用 fork) Tj
T*
(时存在的虚拟内存相同。当这两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。) Tj
T*
() Tj
T*
ET
endstream
endobj
505 0 obj
<< /Length 3660 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(9.8.3 再看 execve 函数) Tj
T*
() Tj
T*
() Tj
T*
(虚拟内存和内存映射在将程序加载到内存的过程中也扮演着关键的角色。既然已经理解了这些概念，我们就能够理解 execve) Tj
T*
(函数实际上是如何加载和执行程序的。假设运行在当前进程中的程序执行了如下的 execve 调用：) Tj
T*
() Tj
T*
(    execve\("a.out", NULL, NULL\);) Tj
T*
() Tj
T*
(正如在第 8 章中学到的，execve 函数在当前进程中加载并运行包含在可执行目标文件 a.out 中的程序，用 a.out 程序有效地替代了当前程序。加载并运行 a.out) Tj
T*
(需要以下几个步骤：) Tj
T*
() Tj
T*
(1. 删除已存在的用户区域。删除当前进程虚拟地址的用户部分中的已存在的区域结构。) Tj
T*
(2. 映射私有区域。为新程序的代码、数据、bss 和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时复制的。代码和数据区域被映射为 a.out 文件中的. text 和.) Tj
T*
(data 区。bss 区域是请求二进制零的，映射到匿名文件，其大小包含在 a.out 中。栈和堆区域也是请求二进制零的，初始长度为零。图 9-31 概括了私有区域的不同映射。) Tj
T*
(3. 映射共享区域。如果 a.out 程序与共享对象（或目标）链接，比如标准 C 库) Tj
T*
(libc.so，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。) Tj
T*
(4. 设置程序计数器（PC）。execve 做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-31 &#x52A0;&#x8F7D;&#x5668;&#x662F;&#x5982;&#x4F55;&#x6620;&#x5C04;&#x7) Tj
T*
(528;&#x6237;&#x5730;&#x5740;&#x7A7A;&#x95F4;&#x7684;&#x533A;&#x57DF;&#x7684;]) Tj
T*
() Tj
T*
(下一次调度这个进程时，它将从这个入口点开始执行。Linux 将根据需要换入代码和数据页面。) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
(    #include <sys/mman.h>) Tj
T*
() Tj
T*
(    void *mmap\(void *start, size_t length, int prot, int flags,) Tj
T*
(               int fd, off_t offset\);) Tj
T*
() Tj
T*
(    // 返回：若成功时则为指向映射区域的指针，若出错则为 MAP_FAILED\(-1\)。) Tj
T*
() Tj
T*
(mmap 函数要求内核创建一个新的虚拟内存区域，最好是从地址 start 开始的一个区域，并将文件描述符 fd) Tj
T*
(指定的对象的一个连续的片（chunk）映射到这个新的区域。连续的对象片大小为 length 字节，从距文件开始处偏移量为 offset 字节的地方开始。start) Tj
T*
(地址仅仅是一个暗示，通常被定义为 NULL。为了我们的目的，我们总是假设起始地址为 NULL。图 9-32 描述了这些参数的意义。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-32 mmap) Tj
T*
(&#x53C2;&#x6570;&#x7684;&#x53EF;&#x89C6;&#x5316;&#x89E3;&#x91CA;]) Tj
T*
() Tj
T*
(参数 prot 包含描述新映射的虚拟内存区域的访问权限位（即在相应区域结构中的 vm\\_prot 位）。) Tj
T*
() Tj
T*
(* PROT\\_EXEC：这个区域内的页面由可以被 CPU 执行的指令组成。) Tj
T*
(* PROT\\_READ：这个区域内的页面可读。) Tj
T*
(* PROT\\_WRITE：这个区域内的页面可写。) Tj
T*
(* PROT\\_NONE：这个区域内的页面不能被访问。) Tj
T*
() Tj
T*
(参数 flags 由描述被映射对象类型的位组成。如果设置了 MAP\\ANON 标记位，那么被映射的对象就是一个匿名对象，而相应的虚拟页面是请求二进制零的。MAP\\PRI-VATE) Tj
T*
ET
endstream
endobj
506 0 obj
<< /Length 2038 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(表示被映射的对象是一个私有的、写时复制的对象，而 MAP\\_SHARED 表示是一个共享对象。例如) Tj
T*
() Tj
T*
(    bufp = Mmap\(NULL, size, PROT_READ, MAP_PRIVATE|MAP_ANON, 0, 0\);) Tj
T*
() Tj
T*
(让内核创建一个新的包含 size 字节的只读、私有、请求二进制零的虚拟内存区域。如果调用成功，那么 bufp 包含新区域的地址。) Tj
T*
() Tj
T*
(munmap 函数删除虚拟内存的区域：) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
(    #include <sys/mman.h>) Tj
T*
() Tj
T*
(    int munmap\(void *start, size_t length\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为 0，若出错则为 -1。) Tj
T*
() Tj
T*
(munmap 函数删除从虚拟地址 start 开始的，由接下来 length 字节组成的区域。接下来对已删除区域的引用会导致段错误。) Tj
T*
() Tj
T*
(练习题 9.5) Tj
T*
() Tj
T*
() Tj
T*
(编写一个 C 程序 mmapcopy.c，使用 mmap 将一个任意大小的磁盘文件复制到 stdouto 输入文件的名字必须作为一个命令行参数来传递。) Tj
T*
() Tj
T*
(解决这个题目将帮助你很好地理解内存映射。请自己独立完成这道题。我们没有讨论 open、fstat 或者 write 函数，所以你需要阅读它们的帮助页来看看它们是如何工作的。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    /*) Tj
T*
(    * mmapcopy - uses mmap to copy file fd to stdout) Tj
T*
(    */) Tj
T*
(    void mmapcopy\(int fd, int size\)) Tj
T*
(    {) Tj
T*
(        char *bufp; /* ptr to memory-mapped VM area */) Tj
T*
() Tj
T*
(        bufp = Mmap\(NULL, size, PROT_READ, MAP_PRIVATE, fd, 0\);) Tj
T*
(        Write\(1, bufp, size\);) Tj
T*
(        return;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* mmapcopy driver */) Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        struct stat stat;) Tj
T*
(        int fd;) Tj
T*
() Tj
T*
(        /* Check for required command-line argument */) Tj
T*
(        if \(argc != 2\) {) Tj
T*
ET
endstream
endobj
507 0 obj
<< /Length 3677 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            printf\("usage: %s <filename>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Copy the input argument to stdout */) Tj
T*
(        fd = Open\(argv[1], O_RDONLY, 0\);) Tj
T*
(        fstat\(fd, &stat\);) Tj
T*
(        mmapcopy\(fd, stat.st_size\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(9.9 动态内存分配) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(9.9 动态内存分配) Tj
T*
() Tj
T*
() Tj
T*
(虽然可以使用低级的 mmap 和 munmap 函数来创建和删除虚拟内存的区域，但是 C 程序员还是会觉得当运行时需要额外虚拟内存时，用动态内存分配器（dynamic memory) Tj
T*
(allocator）更方便，也有更好的可移植性。) Tj
T*
() Tj
T*
(动态内存分配器维护着一个进程的虚拟内存区域，称为堆（heap）（见图) Tj
T*
(9-33）。系统之间细节不同，但是不失通用性，假设堆是一个请求二进制零的区域，它紧接在未初始化的数据区域后开始，并向上生长（向更高的地址）。对于每个进程，内核维护着一个变量) Tj
T*
(brk（读做 “break”），它指向堆的顶部。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-33 &#x5806;]) Tj
T*
() Tj
T*
(分配器将堆视为一组不同大小的块（block）的集合来维护。每个块就是一个连续的虚拟内存片（chunk），要么是已分配的，要么是空闲的。已分配的块显式地保留为供应用程序使用。空闲块可) Tj
T*
(用来分配。空闲块保持空闲，直到它显式地被应用所分配。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显式执行的，要么是内存分配器自身隐式执行的。) Tj
T*
() Tj
T*
(分配器有两种基本风格。两种风格都要求应用显式地分配块。它们的不同之处在于由哪个实体来负责释放已分配的块。) Tj
T*
() Tj
T*
(* 显式分配器（explicit allocator），要求应用显式地释放任何已分配的块。例如，C 标准库提供一种叫做 malloc 程序包的显式分配器。C 程序通过调用) Tj
T*
(malloc 函数来. 分配一个块，并通过调用 free 函数来释放一个块。C++ 中的 new 和 delete 操作符与 C 中的 malloc 和 free 相当。) Tj
T*
(* 隐式分配器（implicit allocator），另一方面，要求分配器检测一个已分配块何时不再被程序所使用，那么就释放这个块。隐式分配器也叫做垃圾收集器（garbage) Tj
T*
(collector），而自动释放未使用的已分配的块的过程叫做垃圾收集（garbage collection）。例如，诸如 Lisp、ML 以及 Java) Tj
T*
(之类的高级语言就依赖垃圾收集来释放已分配的块。) Tj
T*
() Tj
T*
(本节剩下的部分讨论的是显式分配器的设计和实现。我们将在 9.10 节中讨论隐式分配器。为了更具体，我们的讨论集中于管理堆内存的分配器。然而，应该明白内存分配是一个普遍的概念，可以出) Tj
T*
(现在各种上下文中。例如，图形处理密集的应用程序就经常使用标准分配器来要求获得一大块虚拟内存，然后使用与应用相关的分配器来管理内存，在该块中创建和销毁图形的节点。) Tj
T*
() Tj
T*
(9.9.1 malloc 和 free 函数) Tj
T*
() Tj
T*
() Tj
T*
(C 标准库提供了一个称为 malloc 程序包的显式分配器。程序通过调用 malloc 函数来从堆中分配块。) Tj
T*
ET
endstream
endobj
508 0 obj
<< /Length 3254 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(    #include <stdlib.h>) Tj
T*
() Tj
T*
(    void *malloc\(size_t size\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为已分配块的指针，若出错则为 NULL。) Tj
T*
() Tj
T*
(malloc 函数返回一个指针，指向大小为至少 size 字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。实际中，对齐依赖于编译代码在 32 位模式（gcc) Tj
T*
(-m32）还是 64 位模式（默认的）中运行。在 32 位模式中，malloc 返回的块的地址总是 8 的倍数。在 64 位模式中，该地址总是 16 的倍数。) Tj
T*
() Tj
T*
(旁注 - 一个字有多大) Tj
T*
() Tj
T*
() Tj
T*
(回想一下在第 3 章中我们对机器代码的讨论，Intel 将 4 字节对象称为双字。然而，在本节中，我们会假设字是 4 字节的对象，而双字是 8 字节的对象，这和传统术语是一致的。) Tj
T*
() Tj
T*
(如果 malloc 遇到问题（例如，程序要求的内存块比可用的虚拟内存还要大），那么它就返回 NULL，并设置 errno。malloc) Tj
T*
(不初始化它返回的内存。那些想要已初始化的动态内存的应用程序可以使用 calloc，calloc 是一个基于 malloc) Tj
T*
(的瘦包装函数，它将分配的内存初始化为零。想要改变一个以前已分配块的大小，可以使用 realloc 函数。) Tj
T*
() Tj
T*
(动态内存分配器，例如 malloc，可以通过使用 mmap 和 munmap 函数，显式地分配和释放堆内存，或者还可以使用 sbrk 函数：) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
() Tj
T*
(    void *sbrk\(intptr_t incr\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为旧的 brk 指针，若出错则为 -1。) Tj
T*
() Tj
T*
(sbrk 函数通过将内核的 brk 指针增加 incr 来扩展和收缩堆。如果成功，它就返回 brk 的旧值，否则，它就返回 -1，并将 errno 设置为 ENOMEM。如果) Tj
T*
(incr 为零，那么 sbrk 就返回 brk 的当前值。用一个为负的 incr 来调用 sbrk 是合法的，而且很巧妙，因为返回值（brk 的旧值）指向距新堆顶向上) Tj
T*
(abs\\\(incr\\\) 字节处。) Tj
T*
() Tj
T*
(程序是通过调用 free 函数来释放已分配的堆块。) Tj
T*
() Tj
T*
(    #include <stdlib.h>) Tj
T*
() Tj
T*
(    void free\(void *ptr\);) Tj
T*
() Tj
T*
(    // 返回：无。) Tj
T*
() Tj
T*
(ptr 参数必须指向一个从 malloc、calloc 或者 realloc 获得的已分配块的起始位置。如果不是，那么 free) Tj
T*
(的行为就是未定义的。更糟的是，既然它什么都不返回，free 就不会告诉应用出现了错误。就像我们将在 9.11 节里看到的，这会产生一些令人迷惑的运行时错误。) Tj
T*
() Tj
T*
(图 9-34 展示了一个 malloc 和 free 的实现是如何管理一个 C 程序的 16 字的（非常）小的堆的。每个方框代表了一个 4) Tj
T*
(字节的字。粗线标出的矩形对应于已分配块（有阴影的）和空闲块（无阴影的）。初始时，堆是由一个大小为 16 个字的、双字对齐的、空闲块组成的。（本节中，我们假设分配器返回的块是 8) Tj
T*
(字节双字边界对齐的。）) Tj
T*
() Tj
T*
ET
endstream
endobj
509 0 obj
<< /Length 3208 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(* 图 9-34a：程序请求一个 4 字的块。malloc 的响应是：从空闲块的前部切出一个 4 字的块，并返回一个指向这个块的第一字的指针。) Tj
T*
(* 图 9-34b：程序请求一个 5 字的块。malloc 的响应是：从空闲块的前部分配一个 6 字的块。在本例中，malloc) Tj
T*
(在块里填充了一个额外的字，是为了保持空闲块是双字边界对齐的。) Tj
T*
(* 图 9-34c：程序请求一个 6 字的块，而 malloc 就从空闲块的前部切出一个 6 字的块。) Tj
T*
(* 图 9-34d：程序释放在图 9-34b 中分配的那个 6 字的块。注意，在调用 free 返回之后，指针 p2 仍然指向被释放了的块。应用有责任在它被一个新的 malloc) Tj
T*
(调用重新初始化之前，不再使用 p2。) Tj
T*
(* 图 9-34e：程序请求一个 2 字的块。在这种情况中，malloc 分配在前一步中被释放了的块的一部分，并返回一个指向这个新块的指针。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 9-34 用 malloc 和 free) Tj
T*
(分配和释放块。每个方框对应于一个字。每个粗线标出的矩形对应于一个块。阴影部分是已分配的块。已分配的块的填充区域是深阴影的。无阴影部分是空闲块。堆地址是从左往右增加的) Tj
T*
() Tj
T*
(9.9.2 为什么要使用动态内存分配) Tj
T*
() Tj
T*
() Tj
T*
(程序使用动态内存分配的最重要的原因是经常直到程序实际运行时，才知道某些数据结构的大小。例如，假设要求我们编写一个 C 程序，它读一个 n 个 ASCII) Tj
T*
(码整数的链表，每一行一个整数，从 stdin 到一个 C 数组。输入是由整数 n 和接下来要读和存储到数组中的 n) Tj
T*
(个整数组成的。最简单的方法就是静态地定义这个数组，它的最大数组大小是硬编码的：) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    #define MAXN 15213) Tj
T*
() Tj
T*
(    int array[MAXN];) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int i, n;) Tj
T*
() Tj
T*
(        scanf\("%d", &n\);) Tj
T*
(        if \(n > MAXN\)) Tj
T*
(            app_error\("Input file too big"\);) Tj
T*
(        for \(i = 0; i < n; i++\)) Tj
T*
(            scanf\("%d", &array[i]\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(像这样用硬编码的大小来分配数组通常不是一种好想法。MAXN 的值是任意的，与机器上可用的虚拟内存的实际数量没有关系。而且，如果这个程序的使用者想读取一个比 MAXN) Tj
T*
(大的文件，唯一的办法就是用一个更大的 MAXN) Tj
T*
(值来重新编译这个程序。虽然对于这个简单的示例来说这不成问题，但是硬编码数组界限的出现对于拥有百万行代码和大量使用者的大型软件产品而言，会变成一场维护的噩梦。) Tj
T*
() Tj
T*
(一种更好的方法是在运行时，在已知了 n 的值之后，动态地分配这个数组。使用这种方法，数组大小的最大值就只由可用的虚拟内存数量来限制了。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
ET
endstream
endobj
510 0 obj
<< /Length 3648 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    {) Tj
T*
(        int *array, i, n;) Tj
T*
() Tj
T*
(        scanf\("%d", &n\);) Tj
T*
(        array = \(int *\)Malloc\(n * sizeof\(int\)\);) Tj
T*
(        for \(i = 0; i < n; i++\)) Tj
T*
(            scanf\("%d", &array[i]\);) Tj
T*
(        free\(array\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(动态内存分配是一种有用而重要的编程技术。然而，为了正确而高效地使用分配器，程序员需要对它们是如何工作的有所了解。我们将在 9.11) Tj
T*
(节中讨论因为不正确地使用分配器所导致的一些可怕的错误。) Tj
T*
() Tj
T*
(9.9.3 分配器的要求和目标) Tj
T*
() Tj
T*
() Tj
T*
(显式分配器必须在一些相当严格的约束条件下工作：) Tj
T*
() Tj
T*
(* 处理任意请求序列。一个应用可以有任意的分配请求和释放请求序列，只要满足约束条件：每个释放请求必须对应于一个当前已分配块，这个块是由一个以前的分配请求获得的。因此，分配器不可以假) Tj
T*
(设分配和释放请求的顺序。例如，分配器不能假设所有的分配请求都有相匹配的释放请求，或者有相匹配的分配和空闲请求是嵌套的。) Tj
T*
(* 立即响应请求。分配器必须立即响应分配请求。因此，不允许分配器为了提高性能重新排列或者缓冲请求。) Tj
T*
(* 只使用堆。为了使分配器是可扩展的，分配器使用的任何非标量数据结构都必须保存在堆里。) Tj
T*
(* 对齐块（对齐要求）。分配器必须对齐块，使得它们可以保存任何类型的数据对象。) Tj
T*
(* 不修改已分配的块。分配器只能操作或者改变空闲块。特别是，一旦块被分配了，就不允许修改或者移动它了。因此，诸如压缩已分配块这样的技术是不允许使用的。) Tj
T*
() Tj
T*
(在这些限制条件下，分配器的编写者试图实现吞吐率最大化和内存使用率最大化，而这两个性能目标通常是相互冲突的。) Tj
T*
() Tj
T*
(目标 1：最大化呑吐率。假定 n 个分配和释放请求的某种序列：) Tj
T*
() Tj
T*
($$) Tj
T*
(R0,R1,\\cdots,Rk,\\cdots,R{n-1}) Tj
T*
($$) Tj
T*
() Tj
T*
(我们希望一个分配器的吞吐率最大化，吞吐率定义为每个单位时间里完成的请求数。例如，如果一个分配器在 1 秒内完成 500 个分配请求和 500 个释放请求，那么它的吞吐率就是每秒) Tj
T*
(1000 次操作。一般而言，我们可以通过使满足分配和释放请求的平均时间最小化来使吞吐率最大化。正如我们会看到的，开发一个具有合理性能的分配器并不困难，所谓合理性能是指一个分配请求的) Tj
T*
(最糟运行时间与空闲块的数量成线性关系，而一个释放请求的运行时间是个常数。) Tj
T*
() Tj
T*
(目标 2：最大化内存利用率。天真的程序员经常不正确地假设虚拟内存是一个无限的资源。实际上，一个系统中被所有进程分配的虚拟内存的全部数量是受磁盘上交换空间的数量限制的。好的程序员知道) Tj
T*
(虚拟内存是一个有限的空间，必须高效地使用。对于可能被要求分配和释放大块内存的动态内存分配器来说，尤其如此。) Tj
T*
() Tj
T*
(有很多方式来描述一个分配器使用堆的效率如何。在我们的经验中，最有用的标准是峰值利用率（peak utilization）。像以前一样，我们给定 n 个分配和释放请求的某种顺序) Tj
T*
() Tj
T*
($$) Tj
T*
(R0,R1,\\cdots,Rk,\\cdots,R{n-1}) Tj
T*
($$) Tj
T*
ET
endstream
endobj
511 0 obj
<< /Length 4264 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(如果一个应用程序请求一个 p字节的块，那么得到的已分配块的有效载荷（payload）是 p 字节。在请求$$Rk$$完成之后，聚集有效载荷（aggregate) Tj
T*
(payload）表示为$$Pk$$，为当前已分配的块的有效载荷之和，而$$H_k$$表示堆的当前的（单调非递减的）大小。) Tj
T*
() Tj
T*
(那么，前如$$\\small k+1$$个请求的峰值利用率，表示为$$\\small U_k$$可以通过下式得到：) Tj
T*
() Tj
T*
($$) Tj
T*
(Uk = \\frac{max{i\\leqslant k}Pi}{Hk}) Tj
T*
($$) Tj
T*
() Tj
T*
(那么，分配器的目标就是在整个序列中使峰值利用率 $$U_{n-1}$$ 最大化。正如我们将要看到的，在最大化吞吐率和最大化利用率之间是互相牵制的。特别是，以堆利用率为代价，很容易编) Tj
T*
(写出吞吐率最大化的分配器。分配器设计中一个有趣的挑战就是在两个目标之间找到一个适当的平衡。) Tj
T*
() Tj
T*
(旁注 - 放宽单调性假设) Tj
T*
() Tj
T*
() Tj
T*
(我们可以通过让成为前$$\\small k+1$$个请求的最高峰，从而使得在我们对$$U_k$$的定义中放宽单调非递减的假设，并且允许堆增长和降低。) Tj
T*
() Tj
T*
(9.9.4 碎片) Tj
T*
() Tj
T*
() Tj
T*
(造成堆利用率很低的主要原因是一种称为碎片（fragmentation）的现象，当虽然有未使用的内存但不能用来满足分配请求时，就发生这种现象。有两种形式的碎片：内部碎片（intern) Tj
T*
(al fragmentation）和外部碎片（external fragmentation）。) Tj
T*
() Tj
T*
(内部碎片是在一个已分配块比有效载荷大时发生的。很多原因都可能造成这个问题。例如，一个分配器的实现可能对已分配块强加一个最小的大小值，而这个大小要比某个请求的有效载荷大。或者，就如我) Tj
T*
(们在图 9-34b 中看到的，分配器可能增加块大小以满足对齐约束条件。) Tj
T*
() Tj
T*
(内部碎片的量化是简单明了的。它就是已分配块大小和它们的有效载荷大小之差的和。因此，在任意时刻，内部碎片的数量只取决于以前请求的模式和分配器的实现方式。) Tj
T*
() Tj
T*
(外部碎片是当空闲内存合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。例如，如果图 9-34e 中的请求要求 6 个字，而不是 2) Tj
T*
(个字，那么如果不向内核请求额外的虚拟内存就无法满足这个请求，即使在堆中仍然有 6 个空闲的字。问题的产生是由于这 6 个字是分在两个空闲块中的。) Tj
T*
() Tj
T*
(外部碎片比内部碎片的量化要困难得多，因为它不仅取决于以前请求的模式和分配器的实现方式，还取决于将来请求的模式。例如，假设在 k 个请求之后，所有空闲块的大小都恰好是 4) Tj
T*
(个字。这个堆会有外部碎片吗？答案取决于将来请求的模式。如果将来所有的分配请求都要求小于或者等于 4 个字的块，那么就不会有外部碎片。另一方面，如果有一个或者多个请求要求比 4) Tj
T*
(个字大的块，那么这个堆就会有外部碎片。) Tj
T*
() Tj
T*
(因为外部碎片难以量化且不可能预测，所以分配器通常釆用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块。) Tj
T*
() Tj
T*
(9.9.5 实现问题) Tj
T*
() Tj
T*
() Tj
T*
(可以想象出的最简单的分配器会把堆组织成一个大的字节数组，还有一个指针 p，初始指向这个数组的第一个字节。为了分配 size 个字节，malloc 将 p 的当前值保存在栈里，将 p) Tj
T*
(增加 size，并将 p 的旧值返回到调用函数。free 只是简单地返回到调用函数，而不做其他任何事情。) Tj
T*
() Tj
T*
(这个简单的分配器是设计中的一种极端情况。因为每个 malloc 和 free) Tj
T*
(只执行很少量的指令，吞吐率会极好。然而，因为分配器从不重复使用任何块，内存利用率将极差。一个实际的分配器要在吞吐率和利用率之间把握好平衡，就必须考虑以下几个问题：) Tj
T*
ET
endstream
endobj
512 0 obj
<< /Length 4077 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(* 空闲块组织：我们如何记录空闲块？) Tj
T*
(* 放置：我们如何选择一个合适的空闲块来放置一个新分配的块？) Tj
T*
(* 分割：在将一个新分配的块放置到某个空闲块之后，我们如何处理这个空闲块中的剩余部分？) Tj
T*
(* 合并：我们如何处理一个刚刚被释放的块？) Tj
T*
() Tj
T*
(本节剩下的部分将更详细地讨论这些问题。因为像放置、分割以及合并这样的基本技术贯穿在许多不同的空闲块组织中，所以我们将在一种叫做隐式空闲链表的简单空闲块组织结构中来介绍它们。) Tj
T*
() Tj
T*
(9.9.6 隐式空闲链表) Tj
T*
() Tj
T*
() Tj
T*
(任何实际的分配器都需要一些数据结构，允许它来区别块边界，以及区别已分配块和空闲块。大多数分配器将这些信息嵌入块本身。一个简单的方法如图 9-35 所示。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-35) Tj
T*
(&#x4E00;&#x4E2A;&#x7B80;&#x5355;&#x7684;&#x5806;&#x5757;&#x7684;&#x683C;&#x5F0F;]) Tj
T*
() Tj
T*
(在这种情况中，一个块是由一个字的头部、有效载荷，以及可能的一些额外的填充组成的。头部编码了这个块的大小（包括头部和所有的填充），以及这个块是已分配的还是空闲的。如果我们强加一个双字) Tj
T*
(的对齐约束条件，那么块大小就总是 8 的倍数，且块大小的最低 3 位总是零。因此，我们只需要内存大小的 29 个高位，释放剩余的 3) Tj
T*
(位来编码其他信息。在这种情况中，我们用其中的最低位（已分配位）来指明这个块是已分配的还是空闲的。例如，假设我们有一个已分配的块，大小为 24（0x18）字节。那么它的头部将是) Tj
T*
() Tj
T*
(0x00000018 \\| 0x1 = 0x00000019) Tj
T*
() Tj
T*
(类似地，一个块大小为 40（0x28）字节的空闲块有如下的头部：) Tj
T*
() Tj
T*
(0x00000028 \\| 0x0 = 0x00000028) Tj
T*
() Tj
T*
(头部后面就是应用调用 malloc) Tj
T*
(时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小可以是任意的。需要填充有很多原因。比如，填充可能是分配器策略的一部分，用来对付外部碎片。或者也需要用它来满足对齐要求。) Tj
T*
() Tj
T*
(假设块的格式如图 9-35 所示，我们可以将堆组织为一个连续的已分配块和空闲块的序列，如图 9-36 所示。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 9-36 用隐式空闲链表来组织堆。阴影部分是已分配块。没有阴影的部分是空闲块。头部标记为（大小（字节）/ 已分配位）) Tj
T*
() Tj
T*
(我们称这种结构为隐式空闲链表，是因为空闲块是通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接地遍历整个空闲块的集合。注意，我们需要某种特殊标记的结束块，) Tj
T*
(在这个示例中，就是一个设置了已分配位而大小为零的终止头部（terminating header）。（就像我们将在 9.9.12 节中看到的，设置已分配位简化了空闲块的合并。）) Tj
T*
() Tj
T*
(隐式空闲链表的优点是简单。显著的缺点是任何操作的开销，例如放置分配的块，要求对空闲链表进行搜索，该搜索所需时间与堆中已分配块和空闲块的总数呈线性关系。) Tj
T*
() Tj
T*
(很重要的一点就是意识到系统对齐要求和分配器对块格式的选择会对分配器上的最小块大小有强制的要求。没有已分配块或者空闲块可以比这个最小值还小。例如，如果我们假设一个双字的对齐要求，那么) Tj
T*
(每个块的大小都必须是双字（8 字节）的倍数。因此，图 9-35) Tj
T*
(中的块格式就导致最小的块大小为两个字：一个字作头，另一个字维持对齐要求。即使应用只请求一字节，分配器也仍然需要创建一个两字的块。) Tj
T*
() Tj
T*
(练习题 9.6) Tj
T*
() Tj
T*
ET
endstream
endobj
513 0 obj
<< /Length 3945 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(确定下面 malloc 请求序列产生的块大小和头部值。假设：1）分配器保持双字对齐，并且使用块格式如图 9-35 中所示的隐式空闲链表。2）块大小向上舍入为最接近的 8) Tj
T*
(字节的倍数。) Tj
T*
() Tj
T*
(| 请求 | 块大小（十进制字节） | 块头部（十六进制） |) Tj
T*
(| :--- | :--- | :--- |) Tj
T*
(| malloc\\\(1\\\) |  |  |) Tj
T*
(| malloc\\\(5\\\) |  |  |) Tj
T*
(| malloc\\\(12\\\) |  |  |) Tj
T*
(| malloc\\\(13\\\) |  |  |) Tj
T*
() Tj
T*
(这道题触及了一些核心的概念，例如对齐要求、最小块大小以及头部编码。确定块大小的一般方法是，将所请求的有效载荷和头部大小的和舍入到对齐要求（在此例中是 8) Tj
T*
(字节）最近的整数倍。比如，malloc\\\(1\\\) 请求的块大小是 4+1=5，然后舍入到 8。而 malloc\\\(13\\\) 请求的块大小是 13+4=17，舍入到 24。) Tj
T*
() Tj
T*
(| 请求 | 块大小（十进制字节） | 块头部（十六进制） |) Tj
T*
(| :--- | :---: | :---: |) Tj
T*
(| malloc\\\(1\\\) | 8 | 0x9 |) Tj
T*
(| malloc\\\(5\\\) | 16 | 0x11 |) Tj
T*
(| malloc\\\(12\\\) | 16 | 0x11 |) Tj
T*
(| malloc\\\(13\\\) | 24 | 0x9 |) Tj
T*
() Tj
T*
(9.9.7 放置已分配的块) Tj
T*
() Tj
T*
() Tj
T*
(当一个应用请求一个互字节的块时，分配器搜索空闲链表，查找一个足够大可以放置所请求块的空闲块。分配器执行这种搜索的方式是由放置策略（placement) Tj
T*
(policy）确定的。一些常见的策略是首次适配（firstfit），下一次适配（nextfit）和最佳适配（bestfit）„) Tj
T*
() Tj
T*
(首次适配从头开始搜索空闲链表，选择第一个合适的空闲块。下一次适配和首次适配很相似，只不过不是从链表的起始处开始每次搜索，而是从上一次查询结束的地方开始。最佳适配检查每个空闲块，选择) Tj
T*
(适合所需请求大小的最小空闲块。) Tj
T*
() Tj
T*
(首次适配的优点是它趋向于将大的空闲块保留在链表的后面。缺点是它趋向于在靠近链表起始处留下小空闲块的“碎片”，这就增加了对较大块的搜索时间。下一次适配是由 Donald Knuth ) Tj
T*
(作为首次适配的一种代替品最早提出的，源于这样一个想法：如果我们上一次在某个空闲块里已经发现了一个匹配，那么很可能下一次我们也能在这个剩余块中发现匹配。下一次适配比首次适配运行起来明) Tj
T*
(显要快一些，尤其是当链表的前面布满了许多小的碎片时。然而，一些研究表明，下一次适配的内存利用率要比首次适配低得多。研究还表明最佳适配比首次适配和下一次适配的内存利用率都要高一些。然) Tj
T*
(而，在简单空闲链表组织结构中，比如隐式空闲链表中，使用最佳适配的缺点是它要求对堆进行彻底的搜索。在后面，我们将看到更加精细复杂的分离式空闲链表组织，它接近于最佳适配策略，不需要进行) Tj
T*
(彻底的堆搜索。) Tj
T*
() Tj
T*
(9.9.8 分割空闲块) Tj
T*
() Tj
T*
() Tj
T*
(一旦分配器找到一个匹配的空闲块，它就必须做另一个策略决定，那就是分配这个空闲块中多少空间。一个选择是用整个空闲块。虽然这种方式简单而快捷，但是主要的缺点就是它会造成内部碎片。如果放) Tj
T*
(置策略趋向于产生好的匹配，那么额外的内部碎片也是可以接受的。) Tj
T*
() Tj
T*
(然而，如果匹配不太好，那么分配器通常会选择将这个空闲块分割为两部分。第一部分变成分配块，而剩下的变成一个新的空闲块。图 9-37 展示了分配器如何分割图 9-36 中 8) Tj
T*
(个字的空闲块，来满足一个应用的对堆内存 3 个字的请求。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
ET
endstream
endobj
514 0 obj
<< /Length 4541 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(> 图 9-37 分割一个空闲块，以满足一个 3 个字的分配请求。阴影部分是已分配块。没有阴影的部分是空闲块。头部标记为（大小（字节）/ 已分配位）) Tj
T*
() Tj
T*
(9.9.9 获取额外的堆内存) Tj
T*
() Tj
T*
() Tj
T*
(如果分配器不能为请求块找到合适的空闲块将发生什么呢？一个选择是通过合并那些在内存中物理上相邻的空闲块来创建一些更大的空闲块（在下一节中描述）。然而，如果这样还是不能生成一个足够大的) Tj
T*
(块，或者如果空闲块已经最大程度地合并了，那么分配器就会通过调用 sbrk) Tj
T*
(函数，向内核请求额外的堆内存。分配器将额外的内存转化成一个大的空闲块，将这个块插入到空闲链表中，然后将被请求的块放置在这个新的空闲块中。) Tj
T*
() Tj
T*
(9.9.10 合并空闲块) Tj
T*
() Tj
T*
() Tj
T*
(当分配器释放一个已分配块时，可能有其他空闲块与这个新释放的空闲块相邻。这些邻接的空闲块可能引起一种现象，叫做假碎片（fault) Tj
T*
(fragmentation），就是有许多可用的空闲块被切割成为小的、无法使用的空闲块。比如，图 9-38 展示了释放图 9-37) Tj
T*
(中分配的块后得到的结果。结果是两个相邻的空闲块，每一个的有效载荷都为 3 个字。因此，接下来一个对 4 字有效载荷的请求就会失败，即使两个空闲块的合计大小足够大，可以满足这个请求。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 9-38 假碎片的示例。阴影部分是已分配块。没有阴影的部分是空闲块。头部标记为（大小（字节）/ 已分配位）) Tj
T*
() Tj
T*
(为了解决假碎片问题，任何实际的分配器都必须合并相邻的空闲块，这个过程称为合并（coalescing）。这就出现了一个重要的策略决定，那就是何时执行合并。分配器可以选择立即合并（im) Tj
T*
(mediate coalescing），也就是在每次一个块被释放时，就合并所有的相邻块。或者它也可以选择推迟合并（deferred) Tj
T*
(coalescing），也就是等到某个稍晚的时候再合并空闲块。例如，分配器可以推迟合并，直到某个分配请求失败，然后扫描整个堆，合并所有的空闲块。) Tj
T*
() Tj
T*
(立即合并很简单明了，可以在常数时间内执行完成，但是对于某些请求模式，这种方式会产生一种形式的抖动，块会反复地合并，然后马上分割。例如，在图 9-38 中，反复地分配和释放一个 3) Tj
T*
(个字的块将产生大量不必要的分割和合并。在对分配器的讨论中，我们会假设使用立即合并，但是你应该了解，快速的分配器通常会选择某种形式的推迟合并。) Tj
T*
() Tj
T*
(9.9.11 带边界标记的合并) Tj
T*
() Tj
T*
() Tj
T*
(分配器是如何实现合并的？让我们称想要释放的块为当前块。那么，合并（内存中的）下一个空闲块很简单而且高效。当前块的头部指向下一个块的头部，可以检查这个指针以判断下一个块是否是空闲的。) Tj
T*
(如果是，就将它的大小简单地加到当前块头部的大小上，这两个块在常数时间内被合并。) Tj
T*
() Tj
T*
(但是我们该如何合并前面的块呢？给定一个带头部的隐式空闲链表，唯一的选择将是搜索整个链表，记住前面块的位置，直到我们到达当前块。使用隐式空闲链表，这意味着每次调用 free) Tj
T*
(需要的时间都与堆的大小成线性关系。即使使用更复杂精细的空闲链表组织，搜索时间也不会是常数。) Tj
T*
() Tj
T*
(Knuth 提出了一种聪明而通用的技术，叫做边界标记（boundary tag），允许在常数时间内进行对前面块的合并。这种思想，如图 9-39 所示，是在每个块的结尾处添加一个脚部) Tj
T*
(（footer，边界标记），其中脚部就是头部的一个副本。如果每个块包括这样一个脚部，那么分配器就可以通过检査它的脚部，判断前面一个块的起始位置和状态，这个脚部总是在距当前块开始位置) Tj
T*
(一个字的距离。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-39 &#x4F7F;&#x7528;&#x8FB9;&#x754C;&#x6807;&#x8BB0;&#x7684;&#x5806;&#x5) Tj
T*
(757;&#x7684;&#x683C;&#x5F0F;]) Tj
T*
() Tj
T*
(考虑当分配器释放当前块时所有可能存在的情况：) Tj
T*
() Tj
T*
ET
endstream
endobj
515 0 obj
<< /Length 4136 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(1. 前面的块和后面的块都是已分配的。) Tj
T*
(2. 前面的块是已分配的，后面的块是空闲的。) Tj
T*
(3. 前面的块是空闲的，而后面的块是已分配的。) Tj
T*
(4. 前面的和后面的块都是空闲的。) Tj
T*
() Tj
T*
(图 9-40 展示了我们如何对这四种情况进行合并。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 9-40 使用边界标记的合并) Tj
T*
(>) Tj
T*
(> （情况 1：前面的和后面块都已分配。情况 2：前面块已分配，后面块空闲。情况 3：前面块空闲，后面块已分配。情况 4：后面块和前面块都空闲）) Tj
T*
() Tj
T*
(* 在情况 1 中，两个邻接的块都是已分配的，因此不可能进行合并。所以当前块的状态只是简单地从已分配变成空闲。) Tj
T*
(* 在情况 2 中，当前块与后面的块合并。用当前块和后面块的大小的和来更新当前块的头部和后面块的脚部。) Tj
T*
(* 在情况 3 中，前面的块和当前块合并。用两个块大小的和来更新前面块的头部和当前块的脚部。) Tj
T*
(* 在情况 4 中，要合并所有的三个块形成一个单独的空闲块，用三个块大小的和来更新前面块的头部和后面块的脚部。在每种情况中，合并都是在常数时间内完成的。) Tj
T*
() Tj
T*
(边界标记的概念是简单优雅的，它对许多不同类型的分配器和空闲链表组织都是通用的。然而，它也存在一个潜在的缺陷。它要求每个块都保持一个头部和一个脚部，在应用程序操作许多个小块时，会产生) Tj
T*
(显著的内存开销。例如，如果一个图形应用通过反复调用 malloc 和 free) Tj
T*
(来动态地创建和销毁图形节点，并且每个图形节点都只要求两个内存字，那么头部和脚部将占用每个已分配块的一半的空间。) Tj
T*
() Tj
T*
(幸运的是，有一种非常聪明的边界标记的优化方法，能够使得在已分配块中不再需要脚部。回想一下，当我们试图在内存中合并当前块以及前面的块和后面的块时，只有在前面的块是空闲时，才会需要用到) Tj
T*
(它的脚部。如果我们把前面块的已分配/空闲位存放在当前块中多出来的低位中，那么已分配的块就不需要脚部了，这样我们就可以将这个多出来的空间用作有效载荷了。不过请注意，空闲块仍然需要脚部) Tj
T*
(。) Tj
T*
() Tj
T*
(练习题 9.7) Tj
T*
() Tj
T*
() Tj
T*
(确定下面每种对齐要求和块格式的组合的最小的块大小。假设：隐式空闲链表，不允许有效载荷为零，头部和脚部存放在 4 字节的字中。) Tj
T*
() Tj
T*
(| 对齐要求 | 已分配的块 | 空闲块 | 最小块大小\\\(字节\\\) |) Tj
T*
(| :---: | :--- | :--- | :---: |) Tj
T*
(| 单字 | 头部和脚部 | 头部和脚部 |  |) Tj
T*
(| 单字 | 头部，但是无脚部 | 头部和脚部 |  |) Tj
T*
(| 双字 | 头部和脚部 | 头部和脚部 |  |) Tj
T*
(| 双字 | 头部，但是没有脚部 | 头部和脚部 |  |) Tj
T*
() Tj
T*
(最小块大小对内部碎片有显著的影响。因此，理解和不同分配器设计和对齐要求相关联的最小块大小是很好的。很有技巧的一部分是，要意识到相同的块可以在不同时刻被分配或者被释放。因此，最小块大) Tj
T*
(小就是最小已分配块大小和最小空闲块大小两者的最大值。例如，在最后一个子问题中，最小的已分配块大小是一个 4 字节头部和一个 1 字节有效载荷，舍入到 8) Tj
T*
(字节。而最小空闲块的大小是一 个 4 字节的头部和一个 4 字节的脚部，加起来是 8 字节，已经是 8 的倍数，就不需要再舍入了。所以，这个分配器的最小块大小就是 8 字节。) Tj
T*
() Tj
T*
(| 对齐要求 | 已分配的块 | 空闲块 | 最小块大小\\\(字节\\\) |) Tj
T*
(| :---: | :--- | :--- | :---: |) Tj
T*
(| 单字 | 头部和脚部 | 头部和脚部 | 12 |) Tj
T*
(| 单字 | 头部，但是无脚部 | 头部和脚部 | 8 |) Tj
T*
ET
endstream
endobj
516 0 obj
<< /Length 2732 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(| 双字 | 头部和脚部 | 头部和脚部 | 16 |) Tj
T*
(| 双字 | 头部，但是没有脚部 | 头部和脚部 | 8 |) Tj
T*
() Tj
T*
(9.9.12 综合：实现一个简单的分配器) Tj
T*
() Tj
T*
() Tj
T*
(构造一个分配器是一件富有挑战性的任务。设计空间很大，有多种块格式、空闲链表格式，以及放置、分割和合并策略可供选择。另一个挑战就是你经常被迫在类型系统的安全和熟悉的限定之外编程，依赖) Tj
T*
(于容易出错的指针强制类型转换和指针运算，这些操作都属于典型的低层系统编程。) Tj
T*
() Tj
T*
(虽然分配器不需要大量的代码，但是它们也还是细微而不可忽视的。熟悉诸如 C++ 或者 Java 之类高级语言的学生通常在他们第一次遇到这种类型的编程时，会遭遇一个概念上的障碍。为了帮) Tj
T*
(助你清除这个障碍，我们将基于隐式空闲链表，使用立即边界标记合并方式，从头至尾地讲述一个简单分配器的实现。最大的块大小为$$2^{32}=4$$GB。代码是 64) Tj
T*
(位干净的，即代码能不加修改地运行在 32 位（gcc -m32）或 64 位（gcc -m64）的进程中。) Tj
T*
() Tj
T*
(1. 通用分配器设计) Tj
T*
() Tj
T*
() Tj
T*
(我们的分配器使用如图 9-41 所示的 memlib.c 包所提供的一个内存系统模型。模型的目的在于允许我们在不干涉已存在的系统层 malloc 包的情况下，运行分配器。) Tj
T*
() Tj
T*
(    /* Private global variables */) Tj
T*
(    static char *mem_heap;     /* Points to first byte of heap */) Tj
T*
(    static char *mem_brk;      /* Points to last byte of heap plus 1 */) Tj
T*
(    static char *mem_max_addr; /* Max legal heap addr plus 1*/) Tj
T*
() Tj
T*
(    /*) Tj
T*
(    * mem_init - Initialize the memory system model) Tj
T*
(    */) Tj
T*
(    void mem_init\(void\)) Tj
T*
(    {) Tj
T*
(        mem_heap = \(char *\)Malloc\(MAX_HEAP\);) Tj
T*
(        mem_brk = \(char *\)mem_heap;) Tj
T*
(        mem_max_addr = \(char *\)\(mem_heap + MAX_HEAP\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /*) Tj
T*
(    * mem_sbrk - Simple model of the sbrk function. Extends the heap) Tj
T*
(    *    by incr bytes and returns the start address of the new area. In) Tj
T*
(    *    this model, the heap cannot be shrunk.) Tj
T*
(    */) Tj
T*
(    void *mem_sbrk\(int incr\)) Tj
T*
(    {) Tj
T*
(        char *old_brk = mem_brk;) Tj
T*
() Tj
T*
(        if \( \(incr < 0\) || \(\(mem_brk + incr\) > mem_max_addr\)\) {) Tj
T*
(            errno = ENOMEM;) Tj
T*
(            fprintf\(stderr, "ERROR: mem_sbrk failed. Ran out of memory...\\n"\);) Tj
T*
(            return \(void *\) - 1;) Tj
T*
ET
endstream
endobj
517 0 obj
<< /Length 3388 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        }) Tj
T*
(        mem_brk += incr;) Tj
T*
(        return \(void *\)old_brk;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 9-41 memlib.c：内存系统模型) Tj
T*
() Tj
T*
(mem\\init 函数将对于堆来说可用的虚拟内存模型化为一个大的、双字对齐的字节数组。在 mem\\heap 和 mem\\brk 之间的字节表示已分配的虚拟内存。mem\\brk) Tj
T*
(之后的字节表示未分配的虚拟内存。分配器通过调用 mem\\_sbrk 函数来请求额外的堆内存，这个函数和系统的 sbrk 函数的接口相同，而且语义也相同，除了它会拒绝收缩堆的请求。) Tj
T*
() Tj
T*
(分配器包含在一个源文件中（mm.c），用户可以编译和链接这个源文件到他们的应用之中。分配器输出三个函数到应用程序：) Tj
T*
() Tj
T*
(    extern int mm_init\(void\);) Tj
T*
(    extern void *mm_malloc \(size_t size\);) Tj
T*
(    extern void mm_free \(void *ptr\);) Tj
T*
() Tj
T*
(mm\\init 函数初始化分配器，如果成功就返回 0，否则就返回 -1。mm\\malloc 和 mm\\_free 函数 与它们对应的系统函数有相同的接口和语义。分配器使用如图) Tj
T*
(9-39 所示的块格式。最小块的大小为 16 字节。空闲链表组织成为一个隐式空闲链表，具有如图 9-42 所示的恒定形式。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-42) Tj
T*
(&#x9690;&#x5F0F;&#x7A7A;&#x95F2;&#x94FE;&#x8868;&#x7684;&#x6052;&#x5B9A;&#x5F62;&#x5F0F;]) Tj
T*
() Tj
T*
(第一个字是一个双字边界对齐的不使用的填充字。填充后面紧跟着一个特殊的序言块（prologue block），这是一个 8) Tj
T*
(字节的已分配块，只由一个头部和一个脚部组成。序言块是在初始化时创建的，并且永不释放。在序言块后紧跟的是零个或者多个由 malloc 或者 free) Tj
T*
(调用创建的普通块。堆总是以一个特殊的结尾块（epilogue block）来结束，这个块是一个大小为零的已分配块，只由一个头部组成。序言块和结尾块是一种消除合并时边界条件的技巧。分) Tj
T*
(配器使用一个单独的私有（static）全局变量（heap\\_listp），它总是指向序言块。（作为一个小优化，我们可以让它指向下一个块，而不是这个序言块。）) Tj
T*
() Tj
T*
(2. 操作空闲链表的基本常数和宏) Tj
T*
() Tj
T*
() Tj
T*
(图 9-43 展示了一些我们在分配器编码中将要使用的基本常数和宏。第 2 ~ 4) Tj
T*
(行定义了一些基本的大小常数：字的大小（WSIZE）和双字的大小（DSIZE），初始空闲块的大小和扩展堆时的默认大小（CHUNKSIZE）。) Tj
T*
() Tj
T*
(    /* Basic constants and macros */) Tj
T*
(    #define WSIZE 4             /* Word and header/footer size \(bytes\) */) Tj
T*
(    #define DSIZE 8             /* Double word size \(bytes\) */) Tj
T*
(    #define CHUNKSIZE \(1<<12\)   /* Extend heap by this amount \(bytes\) */) Tj
T*
() Tj
T*
(    #define MAX\(x, y\) \(\(x\) > \(y\)? \(x\) : \(y\)\)) Tj
T*
() Tj
T*
(    /* Pack a size and allocated bit into a word */) Tj
T*
(    #define PACK\(size, alloc\) \(\(size\) | \(alloc\)\)) Tj
T*
() Tj
T*
(    /* Read and write a word at address p */) Tj
T*
(    #define GET\(p\)       \(*\(unsigned int *\)\(p\)\)) Tj
T*
(    #define PUT\(p, val\)  \(*\(unsigned int *\)\(p\) = \(val\)\)) Tj
T*
ET
endstream
endobj
518 0 obj
<< /Length 3206 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(    /* Read the size and allocated fields from address p */) Tj
T*
(    #define GET_SIZE\(p\)  \(GET\(p\) & ~0x7\)) Tj
T*
(    #define GET_ALLOC\(p\) \(GET\(p\) & 0x1\)) Tj
T*
() Tj
T*
(    /* Given block ptr bp, compute address of its header and footer */) Tj
T*
(    #define HDRP\(bp\)       \(\(char *\)\(bp\) - WSIZE\)) Tj
T*
(    #define FTRP\(bp\)       \(\(char *\)\(bp\) + GET_SIZE\(HDRP\(bp\)\) - DSIZE\)) Tj
T*
() Tj
T*
(    /* Given block ptr bp, compute address of next and previous blocks */) Tj
T*
(    #define NEXT_BLKP\(bp\)  \(\(char *\)\(bp\) + GET_SIZE\(\(\(char *\)\(bp\) - WSIZE\)\)\)) Tj
T*
(    #define PREV_BLKP\(bp\)  \(\(char *\)\(bp\) - GET_SIZE\(\(\(char *\)\(bp\) - DSIZE\)\)\)) Tj
T*
() Tj
T*
(> 图 9-43 操作空闲链表的基本常数和宏) Tj
T*
() Tj
T*
(在空闲链表中操作头部和脚部可能是很麻烦的，因为它要求大量使用强制类型转换和指针运算。因此，我们发现定义一小组宏来访问和遍历空闲链表是很有帮助的（第 9 ~ 25 行）。PACK) Tj
T*
(宏（第 9 行）将大小和已分配位结合起来并返回一个值，可以把它存放在头部或者脚部中。) Tj
T*
() Tj
T*
(GET 宏（第 12 行）读取和返回参数 p 引用的字。这里强制类型转换是至关重要的。参数 P 典型地是一个*\\\(viod\\\\\)** 指针，不可以直接进行间接引用。类似地，PUT) Tj
T*
(宏（第 13 行）将 val 存放在参数 p 指向的字中。) Tj
T*
() Tj
T*
(GET\\SIZE 和 GET\\ALLOC 宏（第 16 ~ 17 行）从地址 p 处的头部或者脚部分别返回大小和已分配位。剩下的宏是对块指针（block pointer，用 bp) Tj
T*
(表示）的操作，块指针指向第一个有效载荷字节。给定一个块指针 bp，HDRP 和 FTRP 宏（第 20 ~ 21 行）分别返回指向这个块的头部和脚部的指针。NEXT\\BLKP 和) Tj
T*
(PREV\\BLKP 宏（第 24 ~ 25 行）分别返回指向后面的块和前面的块的块指针。) Tj
T*
() Tj
T*
(可以用多种方式来编辑宏，以操作空闲链表。比如，给定一个指向当前块的指针 bp，我们可以使用下面的代码行来确定内存中后面的块的大小：) Tj
T*
() Tj
T*
(    size_t size = GET_SIZE\(HDRP\(NEXT_BLKP\(bp\)\)\);) Tj
T*
() Tj
T*
(3. 创建初始空闲链表) Tj
T*
() Tj
T*
() Tj
T*
(在调用 mm\\malloc 或者 mm\\free 之前，应用必须通过调用 mm\\_init 函数来初始化堆（见图 9-44）。) Tj
T*
() Tj
T*
(    int mm_init\(void\)) Tj
T*
(    {) Tj
T*
(        /* Create the initial empty heap */) Tj
T*
(        if \(\(heap_listp = mem_sbrk\(4 * WSIZE\)\) == \(void *\) - 1\)) Tj
T*
(            return -1;) Tj
T*
(        PUT\(heap_listp, 0\);                            /* Alignment padding */) Tj
T*
(        PUT\(heap_listp + \(1 * WSIZE\), PACK\(DSIZE, 1\)\); /* Prologue header */) Tj
T*
(        PUT\(heap_listp + \(2 * WSIZE\), PACK\(DSIZE, 1\)\); /* Prologue footer */) Tj
T*
(        PUT\(heap_listp + \(3 * WSIZE\), PACK\(0, 1\)\);     /* Epilogue header */) Tj
T*
(        heap_listp += \(2 * WSIZE\);) Tj
T*
() Tj
T*
(        /* Extend the empty heap with a free block of CHUNKSIZE bytes */) Tj
T*
ET
endstream
endobj
519 0 obj
<< /Length 2964 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        if \(extend_heap\(CHUNKSIZE / WSIZE\) == NULL\)) Tj
T*
(            return -1;) Tj
T*
(        return 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 9-44 创建带一个初始空闲块的堆) Tj
T*
() Tj
T*
(rran\\init 函数从内存系统得到 4 个字，并将它们初始化，创建一个空的空闲链表（第 4 ~ 10 行）。然后它调用 extend\\heap 函数（图) Tj
T*
(9-45），这个函数将堆扩展 CHUNKSIZE 字节，并且创建初始的空闲块。此刻，分配器已初始化了，并且准备好接受来自应用的分配和释放请求。) Tj
T*
() Tj
T*
(    static void *extend_heap\(size_t words\)) Tj
T*
(    {) Tj
T*
(        char *bp;) Tj
T*
(        size_t size;) Tj
T*
() Tj
T*
(        /* Allocate an even number of words to maintain alignment */) Tj
T*
(        size = \(words % 2\) ? \(words + 1\) * WSIZE : words * WSIZE;) Tj
T*
(        if \(\(long\)\(bp = mem_sbrk\(size\)\) == -1\)) Tj
T*
(            return NULL;) Tj
T*
() Tj
T*
(        /* Initialize free block header/footer and the epilogue header */) Tj
T*
(        PUT\(HDRP\(bp\), PACK\(size, 0\)\);         /* Free block header */) Tj
T*
(        PUT\(FTRP\(bp\), PACK\(size, 0\)\);         /* Free block footer */) Tj
T*
(        PUT\(HDRP\(NEXT_BLKP\(bp\)\), PACK\(0, 1\)\); /* New epilogue header */) Tj
T*
() Tj
T*
(        /* Coalesce if the previous block was free */) Tj
T*
(        return coalesce\(bp\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 9-45 extend\\_heap：用一个新的空闲块扩展堆) Tj
T*
() Tj
T*
(extend\\heap 函数会在两种不同的环境中被调用：1）当堆被初始化时；2）当 loc 不能找到一个合适的匹配块时。为了保持对齐，extend\\heap) Tj
T*
(将请求大小向上舍入为最接近的 2 字（8 字节）的倍数，然后向内存系统请求额外的堆空间（第 7 ~ 9 行）。) Tj
T*
() Tj
T*
(extend\\heap 函数的剩余部分（第 12 ~ 17 行）有点儿微妙。堆开始于一个双字对齐的边界，并且每次对 extend\\heap) Tj
T*
(的调用都返回一个块，该块的大小是双字的整数倍。因此，对 mem\\_sbrk 的每次调用都返回一个双字对齐的内存片，紧跟在结尾块的头部后面。这个头部变成了新的空闲块的头部（第 12) Tj
T*
(行），并且这个片的最后一个字变成了新的结尾块的头部（第 14 行）。最后，在很可能出现的前一个堆以一个空闲块结束的情况中，我们调用 coalesce) Tj
T*
(函数来合并两个空闲块，并返回指向合并后的块的块指针（第 17 行）。) Tj
T*
() Tj
T*
(4. 释放和合并块) Tj
T*
() Tj
T*
() Tj
T*
(应用通过调用 mm\\_free 函数（图 9-46），来释放一个以前分配的块，这个函数释放所请求的块（bp），然后使用 9.9.11) Tj
T*
(节中描述的边界标记合并技术将之与邻接的空闲块合并起来。) Tj
T*
() Tj
T*
(    void mm_free\(void *bp\)) Tj
T*
ET
endstream
endobj
520 0 obj
<< /Length 2432 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    {) Tj
T*
(        size_t size = GET_SIZE\(HDRP\(bp\)\);) Tj
T*
() Tj
T*
(        PUT\(HDRP\(bp\), PACK\(size, 0\)\);) Tj
T*
(        PUT\(FTRP\(bp\), PACK\(size, 0\)\);) Tj
T*
(        coalesce\(bp\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    static void *coalesce\(void *bp\)) Tj
T*
(    {) Tj
T*
(        size_t prev_alloc = GET_ALLOC\(FTRP\(PREV_BLKP\(bp\)\)\);) Tj
T*
(        size_t next_alloc = GET_ALLOC\(HDRP\(NEXT_BLKP\(bp\)\)\);) Tj
T*
(        size_t size = GET_SIZE\(HDRP\(bp\)\);) Tj
T*
() Tj
T*
(        if \(prev_alloc && next_alloc\) {            /* Case 1 */) Tj
T*
(            return bp;) Tj
T*
(        }) Tj
T*
() Tj
T*
(        else if \(prev_alloc && !next_alloc\) {      /* Case 2 */) Tj
T*
(            size += GET_SIZE\(HDRP\(NEXT_BLKP\(bp\)\)\);) Tj
T*
(            PUT\(HDRP\(bp\), PACK\(size, 0\)\);) Tj
T*
(            PUT\(FTRP\(bp\), PACK\(size, 0\)\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        else if \(!prev_alloc && next_alloc\) {      /* Case 3 */) Tj
T*
(            size += GET_SIZE\(HDRP\(PREV_BLKP\(bp\)\)\);) Tj
T*
(            PUT\(FTRP\(bp\), PACK\(size, 0\)\);) Tj
T*
(            PUT\(HDRP\(PREV_BLKP\(bp\)\), PACK\(size, 0\)\);) Tj
T*
(            bp = PREV_BLKP\(bp\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        else {                                     /* Case 4 */) Tj
T*
(            size += GET_SIZE\(HDRP\(PREV_BLKP\(bp\)\)\) +) Tj
T*
(                    GET_SIZE\(FTRP\(NEXT_BLKP\(bp\)\)\);) Tj
T*
(            PUT\(HDRP\(PREV_BLKP\(bp\)\), PACK\(size, 0\)\);) Tj
T*
(            PUT\(FTRP\(NEXT_BLKP\(bp\)\), PACK\(size, 0\)\);) Tj
T*
(            bp = PREV_BLKP\(bp\);) Tj
T*
(        }) Tj
T*
(        return bp;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 9-46 mm\\_free：释放一个块，并使用边界标记合并将之与所有的邻接空闲块在常数时间内合并) Tj
T*
() Tj
T*
(coalesce 函数中的代码是图 9-40) Tj
T*
(中勾画的四种情况的一种简单直接的实现。这里也有一个微妙的方面。我们选择的空闲链表格式（它的序言块和结尾块总是标记为已分配）允许我们忽略潜在的麻烦边界情况，也就是，请求块 bp) Tj
T*
(在堆的起始处或者是在堆的结尾处。如果没有这些特殊块，代码将混乱得多，更加容易出错，并且更慢，因为我们将不得不在每次释放请求时，都去检査这些并不常见的边界情况。) Tj
T*
ET
endstream
endobj
521 0 obj
<< /Length 2461 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(5. 分配块) Tj
T*
() Tj
T*
() Tj
T*
(一个应用通过调用 mm\\_malloc 函数（见图 9-47）来向内存请求大小为 size) Tj
T*
(字节的块。在检査完请求的真假之后，分配器必须调整请求块的大小，从而为头部和脚部留有空间，并满足双字对齐的要求。第 12 ~ 13 行强制了最小块大小是 16 字节：8) Tj
T*
(字节用来满足对齐要求，而另外 8 个用来放头部和脚部。对于超过 8 字节的请求（第 15 行），一般的规则是加上开销字节，然后向上舍入到最接近的 8 的整数倍。) Tj
T*
() Tj
T*
(    void *mm_malloc\(size_t size\)) Tj
T*
(    {) Tj
T*
(        size_t asize;      /* Adjusted block size */) Tj
T*
(        size_t extendsize; /* Amount to extend heap if no fit */) Tj
T*
(        char *bp;) Tj
T*
() Tj
T*
(        /* Ignore spurious requests */) Tj
T*
(        if \(size == 0\)) Tj
T*
(            return NULL;) Tj
T*
() Tj
T*
(        /* Adjust block size to include overhead and alignment reqs. */) Tj
T*
(        if \(size <= DSIZE\)) Tj
T*
(            asize = 2 * DSIZE;) Tj
T*
(        else) Tj
T*
(            asize = DSIZE * \(\(size + \(DSIZE\) + \(DSIZE - 1\)\) / DSIZE\);) Tj
T*
() Tj
T*
(        /* Search the free list for a fit */) Tj
T*
(        if \(\(bp = find_fit\(asize\)\) != NULL\) {) Tj
T*
(            place\(bp, asize\);) Tj
T*
(            return bp;) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* No fit found. Get more memory and place the block */) Tj
T*
(        extendsize = MAX\(asize, CHUNKSIZE\);) Tj
T*
(        if \(\(bp = extend_heap\(extendsize / WSIZE\)\) == NULL\)) Tj
T*
(            return NULL;) Tj
T*
(        place\(bp, asize\);) Tj
T*
(        return bp;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 9-47 nun\\_malloc：从空闲链表分配一个块) Tj
T*
() Tj
T*
(一旦分配器调整了请求的大小，它就会搜索空闲链表，寻找一个合适的空闲块（第 18 行）。如果有合适的，那么分配器就放置这个请求块，并可选地分割出多余的部分（第 19) Tj
T*
(行），然后返回新分配块的地址。) Tj
T*
() Tj
T*
(如果分配器不能够发现一个匹配的块，那么就用一个新的空闲块来扩展堆（第 24 ~ 26 行），把请求块放置在这个新的空闲块里，可选地分割这个块（第 27) Tj
T*
(行），然后返回一个指针，指向这个新分配的块。) Tj
T*
() Tj
T*
ET
endstream
endobj
522 0 obj
<< /Length 2140 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(练习题 9.8) Tj
T*
() Tj
T*
() Tj
T*
(为 9.9.12 节中描述的简单分配器实现一个 find\\_fit 函数。) Tj
T*
() Tj
T*
(    static void *find_fit\(size_t asize\)) Tj
T*
() Tj
T*
(你的解答应该对隐式空闲链表执行首次适配搜索。) Tj
T*
() Tj
T*
(这里没有特别的技巧。但是解答此题要求你理解简单的隐式链表分配器的剩余部分是如何工作的，是如何操作和遍历块的。) Tj
T*
() Tj
T*
(    static void *find_fit\(size_t asize\)) Tj
T*
(    {) Tj
T*
(        /* First-fit search */) Tj
T*
(        void *bp;) Tj
T*
() Tj
T*
(        for \(bp = heap_listp; GET_SIZE\(HDRP\(bp\)\) > 0; bp = NEXT_BLKP\(bp\)\) {) Tj
T*
(            if \(!GET_ALLOC\(HDRP\(bp\)\) && \(asize <= GET_SIZE\(HDRP\(bp\)\)\)\) {) Tj
T*
(                return bp;) Tj
T*
(            }) Tj
T*
(        }) Tj
T*
(        return NULL; /* No fit */) Tj
T*
(    #endif) Tj
T*
(    }) Tj
T*
() Tj
T*
(练习题 9.9) Tj
T*
() Tj
T*
() Tj
T*
(为示例的分配器编写一个place函数。) Tj
T*
() Tj
T*
(    static void place\(void *bp, size_t asize\)) Tj
T*
() Tj
T*
(你的解答应该将请求块放置在空闲块的起始位置，只有当剩余部分的大小等于或者超出最小块的大小时，才进行分割。) Tj
T*
() Tj
T*
(这又是一个帮助你熟悉分配器的热身练习。注意对于这个分配器，最小块大小是 16 字节。如果分割后剩下的块大于或者等于最小块大小，那么我们就分割这个块（第 6 ~ 10) Tj
T*
(行）。这里唯一有技巧的部分是要意识到在移动到下一块之前（第 8 行），你必须放置新的已分配块（第 6 行和第 7 行）。) Tj
T*
() Tj
T*
(    static void place\(void *bp, size_t asize\)) Tj
T*
(    {) Tj
T*
(        size_t csize = GET_SIZE\(HDRP\(bp\)\);) Tj
T*
() Tj
T*
(        if \(\(csize - asize\) >= \(2 * DSIZE\)\) {) Tj
T*
(            PUT\(HDRP\(bp\), PACK\(asize, 1\)\);) Tj
T*
(            PUT\(FTRP\(bp\), PACK\(asize, 1\)\);) Tj
T*
(            bp = NEXT_BLKP\(bp\);) Tj
T*
(            PUT\(HDRP\(bp\), PACK\(csize - asize, 0\)\);) Tj
T*
ET
endstream
endobj
523 0 obj
<< /Length 3587 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            PUT\(FTRP\(bp\), PACK\(csize - asize, 0\)\);) Tj
T*
(        }) Tj
T*
(        else {) Tj
T*
(            PUT\(HDRP\(bp\), PACK\(csize, 1\)\);) Tj
T*
(            PUT\(FTRP\(bp\), PACK\(csize, 1\)\);) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(9.9.13 显式空闲链表) Tj
T*
() Tj
T*
() Tj
T*
(隐式空闲链表为我们提供了一种介绍一些基本分配器概念的简单方法。然而，因为块分配与堆块的总数呈线性关系，所以对于通用的分配器，隐式空闲链表是不适合的（尽管对于堆块数量预先就知道是很小) Tj
T*
(的特殊的分配器来说它是可以的）。) Tj
T*
() Tj
T*
(一种更好的方法是将空闲块组织为某种形式的显式数据结构。因为根据定义，程序不需要一个空闲块的主体，所以实现这个数据结构的指针可以存放在这些空闲块的主体里面。例如，堆可以组织成一个双向) Tj
T*
(空闲链表，在每个空闲块中，都包含一个 pred（前驱）和 succ（后继）指针，如图 9-48 所示。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-48 &#x4F7F;&#x7528;&#x53CC;&#x5411;&#x7A7A;&#x95F2;&#x94FE;&#x8868;&#x7) Tj
T*
(684;&#x5806;&#x5757;&#x7684;&#x683C;&#x5F0F;]) Tj
T*
() Tj
T*
(使用双向链表而不是隐式空闲链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。不过，释放一个块的时间可以是线性的，也可能是个常数，这取决于我们所选择的空闲链表) Tj
T*
(中块的排序策略。) Tj
T*
() Tj
T*
(一种方法是用后进先出（LIFO）的顺序维护链表，将新释放的块放置在链表的开始处。使用 LIFO) Tj
T*
(的顺序和首次适配的放置策略，分配器会最先检查最近使用过的块。在这种情况下，释放一个块可以在常数时间内完成。如果使用了边界标记，那么合并也可以在常数时间内完成。) Tj
T*
() Tj
T*
(另一种方法是按照地址顺序来维护链表，其中链表中每个块的地址都小于它后继的地址。在这种情况下，释放一个块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配比) Tj
T*
(LIFO 排序的首次适配有更高的内存利用率，接近最佳适配的利用率。) Tj
T*
() Tj
T*
(一般而言，显式链表的缺点是空闲块必须足够大，以包含所有需要的指针，以及头部和可能的脚部。这就导致了更大的最小块大小，也潜在地提高了内部碎片的程度。) Tj
T*
() Tj
T*
(9.9.14 分离的空闲链表) Tj
T*
() Tj
T*
() Tj
T*
(就像我们已经看到的，一个使用单向空闲块链表的分配器需要与空闲块数量呈线性关系的时间来分配块。一种流行的减少分配时间的方法，通常称为分离存储（segregated) Tj
T*
(storage），就是维护多个空闲链表，其中每个链表中的块有大致相等的大小。一般的思路是将所有可能的块大小分成一些等价类，也叫做大小类（size) Tj
T*
(class）。有很多种方式来定义大小类。例如，我们可以根据 2 的幂来划分块大小：) Tj
T*
() Tj
T*
($$) Tj
T*
(\\{1\\},\\{2\\},\\{3,4\\},\\{5\\sim 8\\},\\cdots,\\{1025\\sim 2048\\},\\{4097\\sim \\infty\\}) Tj
T*
($$) Tj
T*
() Tj
T*
(或者我们可以将小的块分派到它们自己的大小类里，而将大块按照 2 的幂分类：) Tj
T*
() Tj
T*
($$) Tj
T*
(\\{1\\},\\{2\\},\\{3\\},\\cdots,\\{1023\\},\\{1024\\},\\{1025\\sim 2048\\},\\{2049\\sim 4096\\},\\{4097\\sim) Tj
T*
ET
endstream
endobj
524 0 obj
<< /Length 5069 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(\\infty\\}) Tj
T*
($$) Tj
T*
() Tj
T*
(分配器维护着一个空闲链表数组，每个大小类一个空闲链表，按照大小的升序排列。当分配器需要一个大小为 n) Tj
T*
(的块时，它就搜索相应的空闲链表。如果不能找到合适的块与之匹配，它就搜索下一个链表，以此类推。) Tj
T*
() Tj
T*
(有关动态内存分配的文献描述了几十种分离存储方法，主要的区别在于它们如何定义大小类，何时进行合并，何时向操作系统请求额外的堆内存，是否允许分割，等等。为了使你大致了解有哪些可能性，我) Tj
T*
(们会描述两种基本的方法：简单分离存储（simple segregated storage）和分离适配（segregated fit）。) Tj
T*
() Tj
T*
(1. 简单分离存储) Tj
T*
() Tj
T*
() Tj
T*
(使用简单分离存储，每个大小类的空闲链表包含大小相等的块，每个块的大小就是这个大小类中最大元素的大小。例如，如果某个大小类定义为 {17 ~ 32}，那么这个类的空闲链表全由大小为) Tj
T*
(32 的块组成。) Tj
T*
() Tj
T*
(为了分配一个给定大小的块，我们检査相应的空闲链表。如果链表非空，我们简单地分配其中第一块的全部。空闲块是不会分割以满足分配请求的。如果链表为空，分配器就向操作系统请求一个固定大小的) Tj
T*
(额外内存片（通常是页大小的整数倍），将这个片分成大小相等的块，并将这些块链接起来形成新的空闲链表。要释放一个块，分配器只要简单地将这个块插入到相应的空闲链表的前部。) Tj
T*
() Tj
T*
(这种简单的方法有许多优点。分配和释放块都是很快的常数时间操作。而且，每个片中都是大小相等的块，不分割，不合并，这意味着每个块只有很少的内存开销。由于每个片只有大小相同的块，那么一个) Tj
T*
(已分配块的大小就可以从它的地址中推断出来。因为没有合并，所以已分配块的头部就不需要一个已分配/空闲标记。因此已分配块不需要头部，同时因为没有合并，它们也不需要脚部。因为分配和释放操) Tj
T*
(作都是在空闲链表的起始处操作，所以链表只需要是单向的，而不用是双向的。关键点在于，在任何块中都需要的唯一字段是每个空闲块中的一个字的 succ 指针，因此最小块大小就是一个字。) Tj
T*
() Tj
T*
(一个显著的缺点是，简单分离存储很容易造成内部和外部碎片。因为空闲块是不会被分割的，所以可能会造成内部碎片。更糟的是，因为不会合并空闲块，所以某些引用模式会引起极多的外部碎片（见练习) Tj
T*
(题 9.10）。) Tj
T*
() Tj
T*
(练习题 9.10) Tj
T*
() Tj
T*
() Tj
T*
(描述一个在基于简单分离存储的分配器中会导致严重外部碎片的引用模式。) Tj
T*
() Tj
T*
(这里有一个会引起外部碎片的模式：应用对第一个大小类做大量的分配和释放请求，然后对第二个大小类做大量的分配和释放请求，接下来是对第三个大小类做大量的分配和释放请求，以此类推。对于每个) Tj
T*
(大小类，分配器都创建了许多不会被回收的存储器，因为分配器不会合并，也因为应用不会再向这个大小类再次请求块了。) Tj
T*
() Tj
T*
(2. 分离适配) Tj
T*
() Tj
T*
() Tj
T*
(使用这种方法，分配器维护着一个空闲链表的数组。每个空闲链表是和一个大小类相关联的，并且被组织成某种类型的显式或隐式链表。每个链表包含潜在的大小不同的块，这些块的大小是大小类的成员。) Tj
T*
(有许多种不同的分离适配分配器。这里，我们描述了一种简单的版本。) Tj
T*
() Tj
T*
(为了分配一个块，必须确定请求的大小类，并且对适当的空闲链表做首次适配，査找一个合适的块。如果找到了一个，那么就（可选地）分割它，并将剩余的部分插入到适当的空闲链表中。如果找不到合适) Tj
T*
(的块，那么就搜索下一个更大的大小类的空闲链表。如此重复，直到找到一个合适的块。如果空闲链表中没有合适的块，那么就向操作系统请求额外的堆内存，从这个新的堆内存中分配出一个块，将剩余部) Tj
T*
(分放置在适当的大小类中。要释放一个块，我们执行合并，并将结果放置到相应的空闲链表中。) Tj
T*
() Tj
T*
(分离适配方法是一种常见的选择，C 标准库中提供的 GNU malloc 包就是釆用的这种方法，因为这种方法既快速，对内存的使用也很有效率。搜索时间减少了，因为搜索被限制在堆的某个部) Tj
T*
(分，而不是整个堆。内存利用率得到了改善，因为有一个有趣的事实：对分离空闲链表的简单的首次适配搜索，其内存利用率近似于对整个堆的最佳适配搜索的内存利用率。) Tj
T*
() Tj
T*
ET
endstream
endobj
525 0 obj
<< /Length 2725 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(3. 伙伴系统) Tj
T*
() Tj
T*
() Tj
T*
(伙伴系统（buddy system）是分离适配的一种特例，其中每个大小类都是 2 的籍。基本的思路是假设一个堆的大小为$$\\small) Tj
T*
(2^m$$个字，我们为每个块大小$$\\small2^k$$维护一个分离空闲链表，其中$$\\small 0\\leqslant k \\leqslant) Tj
T*
(m$$。请求块大小向上舍入到最接近的 2 的幂。最开始时，只有一个大小为 $$\\small 2^m$$ 个字的空闲块。) Tj
T*
() Tj
T*
(为了分配一个大小为$$\\small 2^k$$的块，我们找到第一个可用的、大小为$$\\small 2^j$$的块，其中$$\\small k\\leqslant j \\leqslant) Tj
T*
(m$$。如果 $$\\small) Tj
T*
(j=k$$，那么我们就完成了。否则，我们递归地二分割这个块，直到当我们进行这样的分割时，每个剩下的半块（也叫做伙伴）被放置在相应的空闲链表中。要释放一个大小为$$\\small) Tj
T*
(2^k$$的块，我们继续合并空闲的伙伴。当遇到一个已分配的伙伴时，我们就停止合并。) Tj
T*
() Tj
T*
(关于伙伴系统的一个关键事实是，给定地址和块的大小，很容易计算出它的伙伴的地址。例如，一个块，大小为 32 字节，地址为：) Tj
T*
() Tj
T*
($$) Tj
T*
(xxx\\cdots x00000) Tj
T*
($$) Tj
T*
() Tj
T*
(它的伙伴的地址为) Tj
T*
() Tj
T*
($$) Tj
T*
(xxx\\cdots x10000) Tj
T*
($$) Tj
T*
() Tj
T*
(换句话说，一个块的地址和它的伙伴的地址只有一位不相同。) Tj
T*
() Tj
T*
(伙伴系统分配器的主要优点是它的快速搜索和快速合并。主要缺点是要求块大小为 2) Tj
T*
(的幂可能导致显著的内部碎片。因此，伙伴系统分配器不适合通用目的的工作负载。然而，对于某些特定应用的工作负载，其中块大小预先知道是 2 的幂，伙伴系统分配器就很有吸引力了。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(9.10 垃圾收集) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(9.10 垃圾收集) Tj
T*
() Tj
T*
() Tj
T*
(在诸如 C malloc 包这样的显式分配器中，应用通过调用 malloc 和 free 来分配和释放堆块。应用要负责释放所有不再需要的已分配块。) Tj
T*
() Tj
T*
(未能释放已分配的块是一种常见的编程错误。例如，考虑下面的 C 函数，作为处理的一部分，它分配一块临时存储：) Tj
T*
() Tj
T*
(    void garbage\(\)) Tj
T*
(    {) Tj
T*
(        int *p = \(int *\)Malloc\(15213\);) Tj
T*
(        return; /* Array p is garbage at this point */) Tj
T*
(    }) Tj
T*
ET
endstream
endobj
526 0 obj
<< /Length 4972 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(因为程序不再需要 p，所以在 garbage 返回前应该释放) Tj
T*
(p。不幸的是，程序员忘了释放这个块。它在程序的生命周期内都保持为已分配状态，毫无必要地占用着本来可以用来满足后面分配请求的堆空间。) Tj
T*
() Tj
T*
(垃圾收集器（garbage collector）是一种动态内存分配器，它自动释放程序不再需要的已分配块。这些块被称为垃圾（garbage）（因此术语就称之为垃圾收集器）。自动回收堆) Tj
T*
(存储的过程叫做垃圾收集（garbagecollection）。在一个支持垃圾收集的系统中，应用显式分配堆块，但是从不显示地释放它们。在 C 程序的上下文中，应用调用) Tj
T*
(malloc，但是从不调用 free。反之，垃圾收集器定期识别垃圾块，并相应地调用 free，将这些块放回到空闲链表中。) Tj
T*
() Tj
T*
(垃圾收集可以追溯到 John McCarthy 在 20 世纪 60 年代早期在 MIT 开发的 Lisp 系统。它是诸如 Java、ML、Perl 和 Mathematica) Tj
T*
(等现代语言系统的一个重要部分，而且它仍然是一个重要而活跃的研究领域。有关文献描述了大量的垃圾收集方法，其数量令人吃惊。我们的讨论局限于 McCarthy 独创的) Tj
T*
(Mark&Sweep（标记 & 清除）算法，这个算法很有趣，因为它可以建立在已存在的 malloc 包的基础之上，为 C 和 C++ 程序提供垃圾收集。) Tj
T*
() Tj
T*
(9.10.1 垃圾收集器的基本知识) Tj
T*
() Tj
T*
() Tj
T*
(垃圾收集器将内存视为一张有向可达图（reachability graph），其形式如图 9-49 所示。该图的节点被分成一组根节点（root node）和一组堆节点（heap) Tj
T*
(node）。每个堆节点对应于堆中的一个已分配块。有向边 p→q 意味着块 p 中的某个位置指向块 q) Tj
T*
(中的某个位置。根节点对应于这样一种不在堆中的位置，它们中包含指向堆中的指针。这些位置可以是寄存器、栈里的变量，或者是虚拟内存中读写数据区域内的全局变量。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-49 &#x5783;&#x573E;&#x6536;&#x96C6;&#x5668;&#x5C06;&#x5185;&#x5B58;&#x8) Tj
T*
(9C6;&#x4E3A;&#x4E00;&#x5F20;&#x6709;&#x5411;&#x56FE;]) Tj
T*
() Tj
T*
(当存在一条从任意根节点出发并到达 p 的有向路径时，我们说节点 p 是可达的（reachable）。在任何时刻，不可达节点对应于垃圾，是不能被应用再次使用的。垃圾收集器的角色是维护) Tj
T*
(可达图的某种表示，并通过释放不可达节点且将它们返回给空闲链表，来定期地回收它们。) Tj
T*
() Tj
T*
(像 ML 和 Java 这样的语言的垃圾收集器，对应用如何创建和使用指针有很严格的控制，能够维护可达图的一种精确的表示，因此也就能够回收所有垃圾。然而，诸如 C 和 C++) Tj
T*
(这样的语言的收集器通常不能维持可达图的精确表示。这样的收集器也叫做保守的垃圾收集器（conservative garbage collector）。从某种意义上来说它们是保守的，即) Tj
T*
(每个可达块都被正确地标记为可达了，而一些不可达节点却可能被错误地标记为可达。收集器可以按需提供它们的服务，或者它们可以作为一个和应用并行的独立线程，不断地更新可达图和回收垃圾。例如) Tj
T*
(，考虑如何将一个 C 程序的保守的收集器加入到已存在的 malloc 包中，如图 9-50 所示。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-50 &#x5C06;&#x4E00;&#x4E2A;&#x4FDD;&#x5B88;&#x7684;&#x5783;&#x573E;&#x6) Tj
T*
(536;&#x96C6;&#x5668;&#x52A0;&#x5165;&#x5230; C &#x7684; malloc &#x5305;&#x4E2D;]) Tj
T*
() Tj
T*
(无论何时需要堆空间时，应用都会用通常的方式调用 malloc。如果 malloc) Tj
T*
(找不到一个合适的空闲块，那么它就调用垃圾收集器，希望能够回收一些垃圾到空闲链表。收集器识别出垃圾块，并通过调用 free 函数将它们返回给堆。关键的思想是收集器代替应用去调用) Tj
T*
(free。当对收集器的调用返回时，malloc 重试，试图发现一个合适的空闲块。如果还是失败了，那么它就会向操作系统要求额外的内存。最后，malloc) Tj
T*
(返回一个指向请求块的指针（如果成功）或者返回一个空指针（如果不成功）。) Tj
T*
() Tj
T*
(9.10.2 Mark&Sweep 垃圾收集器) Tj
T*
() Tj
T*
() Tj
T*
(Mark&Sweep 垃圾收集器由标记（mark）阶段和清除（sweep）阶段组成，标记阶段标记出根节点的所有可达的和已分配的后继，而后面的清除阶段释放每个未被标记的已分配块。块头) Tj
T*
(部中空闲的低位中的一位通常用来表示这个块是否被标记了。) Tj
T*
() Tj
T*
(我们对 Mark&Sweep 的描述将假设使用下列函数，其中 ptr 定义为 *typedef void\\ ptr**：) Tj
T*
() Tj
T*
ET
endstream
endobj
527 0 obj
<< /Length 2567 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(* ptr isPtr \\\(ptr p\\\)。如果 p 指向一个已分配块中的某个字，那么就返回一个指向这个块的起始位置的指针 b。否则返回 NULL。) Tj
T*
(* int blockMarked\\\(ptr b\\\)。如果块 b 是已标记的，那么就返回 true。) Tj
T*
(* int blockAllocated \\\(ptr b\\\)。如果块 b 是已分配的，那么就返回 true。) Tj
T*
(* void markBlock \\\(ptr b\\\)。标记块 b。) Tj
T*
(* int length \\\(b\\\)。返回块 b 的以字为单位的长度\\\(不包括头部\\\)。) Tj
T*
(* void unmarkBlock \\\(ptr b\\\)。将块 b 的状态由已标记的改为未标记的。) Tj
T*
(* ptr nextBlock \\\(ptr b\\\)。返回堆中块 b 的后继。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(标记阶段为每个根节点调用一次图 9-51a 所示的 mark 函数。如果 p 不指向一个已分配并且未标记的堆块，mark) Tj
T*
(函数就立即返回。否则，它就标记这个块，并对块中的每个字递归地调用它自己。每次对 mark) Tj
T*
(函数的调用都标记某个根节点的所有未标记并且可达的后继节点。在标记阶段的末尾，任何未标记的已分配块都被认定为是不可达的，是垃圾，可以在清除阶段回收。) Tj
T*
() Tj
T*
(清除阶段是对图 9-51b 所示的 sweep 函数的一次调用。sweep 函数在堆中每个块上反复循环，释放它所遇到的所有未标记的已分配块（也就是垃圾）。) Tj
T*
() Tj
T*
(    void mark\(ptr p\) {) Tj
T*
(        if \(\(b = isPtr\(p\)\) == NULL\)) Tj
T*
(            return;) Tj
T*
(        if \(blockMarked\(b\)\)) Tj
T*
(            return;) Tj
T*
(        markBlock\(b\);) Tj
T*
(        len = length\(b\);) Tj
T*
(        for \(i = 0; i < len; i++\)) Tj
T*
(            mark\(b[i]\);) Tj
T*
(        return;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> a）mark 函数) Tj
T*
() Tj
T*
(    void sweep\(ptr b, ptr end\) {) Tj
T*
(        while \(b < end\) {) Tj
T*
(            if \(blockMarked\(b\)\)) Tj
T*
(                unmarkBlock\(b\);) Tj
T*
(            else if \(blockAllocated\(b\)\)) Tj
T*
(                free\(b\);) Tj
T*
(            b = nextBlock\(b\);) Tj
T*
(        }) Tj
T*
(        return;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> b）sweep 函数) Tj
T*
() Tj
T*
(> 图 9-51 mark 和 sweep 函数的伪代码) Tj
T*
() Tj
T*
(图 9-52 展示了一个小堆的 Mark&Sweep 的图形化解释。块边界用粗线条表示。每个方块对应于内存中的一个字。每个块有一个字的头部，要么是已标记的，要么是未标记的。) Tj
T*
ET
endstream
endobj
528 0 obj
<< /Length 4456 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 9-52 Mark&Sweep 示例。注意这个示例中的箭头表示内存引用，而不是空闲链表指针) Tj
T*
() Tj
T*
(初始情况下，图 9-52 中的堆由六个已分配块组成，其中每个块都是未分配的。第 3 块包含一个指向第 1 块的指针。第 4 块包含指向第 3 块和第 6 块的指针。根指向第 4) Tj
T*
(块。在标记阶段之后，第 1 块、第 3 块、第 4 块和第 6 块被做了标记，因为它们是从根节点可达的。第 2 块和第 5) Tj
T*
(块是未标记的，因为它们是不可达的。在清除阶段之后，这两个不可达块被回收到空闲链表。) Tj
T*
() Tj
T*
(9.10.3 C 程序的保守 Mark&Sweep) Tj
T*
() Tj
T*
() Tj
T*
(Mark&Sweep 对 C 程序的垃圾收集是一种合适的方法，因为它可以就地工作，而不需要移动任何块。然而，C 语言为 isPtr 函数的实现造成了一些有趣的挑战。) Tj
T*
() Tj
T*
(第一，C 不会用任何类型信息来标记内存位置。因此，对 isPtr 没有一种明显的方式来判断它的输入参数 p 是不是一个指针。第二，即使我们知道 p 是一个指针，对 isPtr) Tj
T*
(也没有明显的方式来判断 p 是否指向一个已分配块的有效载荷中的某个位置。) Tj
T*
() Tj
T*
(对后一问题的解决方法是将已分配块集合维护成一棵平衡二叉树，这棵树保持着这样一个属性：左子树中的所有块都放在较小的地址处，而右子树中的所有块都放在较大的地址处。如图 9-53) Tj
T*
(所示，这就要求每个已分配块的头部里有两个附加字段（left 和 right）。每个字段指向某个已分配块的头部。isPtr\\\(ptr p\\\)) Tj
T*
(函数用树来执行对已分配块的二分查找。在每一步中，它依赖于块头部中的大小字段来判断 p 是否落在这个块的范围之内。) Tj
T*
() Tj
T*
([Image: &#x56FE; 9-53 &#x4E00;&#x68F5;&#x5DF2;&#x5206;&#x914D;&#x5757;&#x7684;&#x5E73;&#x8) Tj
T*
(861;&#x6811;&#x4E2D;&#x7684;&#x5DE6;&#x53F3;&#x6307;&#x9488;]) Tj
T*
() Tj
T*
(平衡树方法保证会标记所有从根节点可达的节点，从这个意义上来说它是正确的。这是一个必要的保证，因为应用程序的用户当然不会喜欢把他们的已分配块过早地返回给空闲链表。然而，这种方法从某种) Tj
T*
(意义上而言又是保守的，因为它可能不正确地标记实际上不可达的块，因此它可能不会释放某些垃圾。虽然这并不影响应用程序的正确性，但是这可能导致不必要的外部碎片。) Tj
T*
() Tj
T*
(C 程序的 Mark&Sweep 收集器必须是保守的，其根本原因是 C 语言不会用类型信息来标记内存位置。因此，像 int 或者 float) Tj
T*
(这样的标量可以伪装成指针。例如，假设某个可达的已分配块在它的有效载荷中包含一个 int，其值碰巧对应于某个其他已分配块 b) Tj
T*
(的有效载荷中的一个地址。对收集器而言，是没有办法推断出这个数据实际上是 int 而不是指针。因此，分配器必须保守地将块 b 标记为可达，尽管事实上它可能是不可达的。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(9.11 C 程序中常见的与内存有关的错误) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(9.11 C 程序中常见的与内存有关的错误) Tj
T*
() Tj
T*
() Tj
T*
(对 c 程序员来说，管理和使用虚拟内存可能是个困难的、容易出错的任务。与内存有关的错误属于那些最令人惊恐的错误，因为它们在时间和空间上，经常在距错误源一段距离之后才表现出来。将错误) Tj
T*
(的数据写到错误的位置，你的程序可能在最终失败之前运行了好几个小时，且使程序中止的位置距离错误的位置已经很远了。我们用一些常见的与内存有关错误的讨论，来结束对虚拟内存的讨论。) Tj
T*
() Tj
T*
(9.11.1 间接引用坏指针) Tj
T*
() Tj
T*
() Tj
T*
(正如我们在 9.7.2 节中学到的，在进程的虚拟地址空间中有较大的洞，没有映射到任何有意义的数据。如果我们试图间接引用一个指向这些洞的指针，那么操作系统就会以段异常中止程序。而且，) Tj
T*
ET
endstream
endobj
529 0 obj
<< /Length 2590 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(虚拟内存的某些区域是只读的。试图写这些区域将会以保护异常中止这个程序。) Tj
T*
() Tj
T*
(间接引用坏指针的一个常见示例是经典的 scanf 错误。假设我们想要使用 scanf 从 stdin 读一个整数到一个变量。正确的方法是传递给 scanf 一个格式串和变量的地址：) Tj
T*
() Tj
T*
(    scanf\("%d", &val\)) Tj
T*
() Tj
T*
(然而，对于 C 程序员初学者而言（对有经验者也是如此！），很容易传递 val 的内容，而不是它的地址：) Tj
T*
() Tj
T*
(    scanf\("%d", val\)) Tj
T*
() Tj
T*
(在这种情况下，scanf 将把 val 的内容解释为一个地址，并试图将一个字写到这个位置。在最好的情况下，程序立即以异常终止。在最糟糕的情况下，val) Tj
T*
(的内容对应于虚拟内存的某个合法的读/写区域，于是我们就覆盖了这块内存，这通常会在相当长的一段时间以后造成灾难性的、令人困惑的后果。) Tj
T*
() Tj
T*
(9.11.2 读未初始化的内存) Tj
T*
() Tj
T*
() Tj
T*
(虽然 bss 内存位置（诸如未初始化的全局 C 变量）总是被加载器初始化为零，但是对于堆内存却并不是这样的。一个常见的错误就是假设堆内存被初始化为零：) Tj
T*
() Tj
T*
(    /* Return y = Ax */) Tj
T*
(    int *matvec\(int **A, int *x, int n\)) Tj
T*
(    {) Tj
T*
(        int i, j;) Tj
T*
() Tj
T*
(        int *y = \(int *\)Malloc\(n * sizeof\(int\)\);) Tj
T*
() Tj
T*
(        for \(i = 0; i < n; i++\)) Tj
T*
(            for \(j = 0; j < n; j++\)) Tj
T*
(                y[i] += A[i][j] * x[j];) Tj
T*
(        return y;) Tj
T*
(    }) Tj
T*
() Tj
T*
(在这个示例中，程序员不正确地假设向量 y 被初始化为零。正确的实现方式是显式地将 y\\[i\\] 设置为零，或者使用 calloc。) Tj
T*
() Tj
T*
(9.11.3 允许栈缓冲区溢出) Tj
T*
() Tj
T*
() Tj
T*
(正如我们在 3.10.3 节中看到的，如果一个程序不检查输入串的大小就写入栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误（buffer overflow) Tj
T*
(bug）。例如，下面的函数就有缓冲区溢出错误，因为 gets 函数复制一个任意长度的串到缓冲区。为了纠正这个错误，我们必须使用 fgets 函数，这个函数限制了输入串的大小：) Tj
T*
() Tj
T*
(    void bufoverflow\(\)) Tj
T*
(    {) Tj
T*
(        char buf[64];) Tj
T*
(        gets\(buf\); /* Here is the stack buffer overflow bug */) Tj
T*
(        return;) Tj
T*
(    }) Tj
T*
() Tj
T*
ET
endstream
endobj
530 0 obj
<< /Length 2691 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(9.11.4 假设指针和它们指向的对象是相同大小的) Tj
T*
() Tj
T*
() Tj
T*
(一种常见的错误是假设指向对象的指针和它们所指向的对象是相同大小的：) Tj
T*
() Tj
T*
(    /* Create an nxm array */) Tj
T*
(    int **makeArray1\(int n, int m\)) Tj
T*
(    {) Tj
T*
(        int i;) Tj
T*
(        int **A = \(int **\)Malloc\(n * sizeof\(int\)\);) Tj
T*
() Tj
T*
(        for \(i = 0; i < n; i++\)) Tj
T*
(            A[i] = \(int *\)Malloc\(m * sizeof\(int\)\);) Tj
T*
(        return A;) Tj
T*
(    }) Tj
T*
() Tj
T*
(这里的目的是创建一个由 n 个指针组成的数组，每个指针都指向一个包含 m 个 int 的数组。然而，因为程序员在第 5 行将 *sizeof\\\(int \\\\\) 写成了) Tj
T*
(sizeof\\\(int\\\)**，代码实际上创建的是一个 int 的数组。) Tj
T*
() Tj
T*
(这段代码只有在 int 和指向 int 的指针大小相同的机器上运行良好。但是，如果我们在像 Core i7 这样的机器上运行这段代码，其中指针大于 int，那么第 7 行和第 8) Tj
T*
(行的循环将写到超出 A 数组结尾的地方。因为这些字中的一个很可能是已分配块的边界标记脚部，所以我们可能不会发现这个错误，直到在这个程序的后面很久释放这个块时，此时，分配器中的合并代) Tj
T*
(码会戏剧性地失败，而没有任何明显的原因。这是“在远处起作用（action at distance）”的一个阴险的示例，这类“在远处起作用”是与内存有关的编程错误的典型情况。) Tj
T*
() Tj
T*
(9.11.5 造成错位错误) Tj
T*
() Tj
T*
() Tj
T*
(错位（off-by-one）错误是另一种很常见的造成覆盖错误的来源：) Tj
T*
() Tj
T*
(    /* Create an nxm array */) Tj
T*
(    int **makeArray2\(int n, int m\)) Tj
T*
(    {) Tj
T*
(        int i;) Tj
T*
(        int **A = \(int **\)Malloc\(n * sizeof\(int *\)\);) Tj
T*
() Tj
T*
(        for \(i = 0; i <= n; i++\)) Tj
T*
(            A[i] = \(int *\)Malloc\(m * sizeof\(int\)\);) Tj
T*
(        return A;) Tj
T*
(    }) Tj
T*
() Tj
T*
(这是前面一节中程序的另一个版本。这里我们在第 5 行创建了一个 n 个元素的指针数组，但是随后在第 7 行和第 8 行试图初始化这个数组的 n+1 个元素，在这个过程中覆盖了 A) Tj
T*
(数组后面的某个内存位置。) Tj
T*
() Tj
T*
(9.11.6 引用指针，而不是它所指向的对象) Tj
T*
() Tj
T*
() Tj
T*
(如果不太注意 C 操作符的优先级和结合性，我们就会错误地操作指针，而不是指针所指向的对象。比如，考虑下面的函数，其目的是删除一个有  *\\size) Tj
T*
ET
endstream
endobj
531 0 obj
<< /Length 2706 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(项的二叉堆里的第一项，然后对剩下的 \\size-1* 项重新建堆：) Tj
T*
() Tj
T*
(    int *binheapDelete\(int **binheap, int *size\)) Tj
T*
(    {) Tj
T*
(        int *packet = binheap[0];) Tj
T*
() Tj
T*
(        binheap[0] = binheap[*size - 1];) Tj
T*
(        *size--; /* This should be \(*size\)-- */) Tj
T*
(        heapify\(binheap, *size, 0\);) Tj
T*
(        return \(packet\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(在第 6 行，目的是减少 size 指针指向的整数的值。然而，因为一元运算符——和 \\ 的优先级相同，从右向左结合，所以第 6 行中的代码实际减少的是指针自己的值，而不是它所指向的) Tj
T*
(整数的值。如果幸运地话，程序会立即失败；但是更有可能发生的是，当程序在执行过程后很久才产生出一个不正确的结果时，我们只有一头的雾水。这里的原则是当你对优先级和结合性有疑问的时候，就) Tj
T*
(使用括号。比如，在第 6 行，我们可以使用表达式 \\\(\\size\\\)--**，清晰地表明我们的意图。) Tj
T*
() Tj
T*
(9.11.7 误解指针运算) Tj
T*
() Tj
T*
() Tj
T*
(另一种常见的错误是忘记了指针的算术操作是以它们指向的对象的大小为单位来进行的，而这种大小単位并不一定是字节。例如，下面函数的目的是扫描一个 int 的数组，并返回一个指针，指向) Tj
T*
(val 的首次出现：) Tj
T*
() Tj
T*
(    int *search\(int *p, int val\)) Tj
T*
(    {) Tj
T*
(        while \(*p && *p != val\)) Tj
T*
(            p += sizeof\(int\); /* Should be p++ */) Tj
T*
(        return p;) Tj
T*
(    }) Tj
T*
() Tj
T*
(然而，因为每次循环时，第 4 行都把指针加了 4（一个整数的字节数），函数就不正确地扫描数组中每 4 个整数。) Tj
T*
() Tj
T*
(9.11.8 引用不存在的变量) Tj
T*
() Tj
T*
() Tj
T*
(没有太多经验的 C 程序员不理解栈的规则，有时会引用不再合法的本地变量，如下列所示：) Tj
T*
() Tj
T*
(    int *stackref \(\)) Tj
T*
(    {) Tj
T*
(        int val;) Tj
T*
() Tj
T*
(        return &val;) Tj
T*
(    }) Tj
T*
() Tj
T*
(这个函数返回一个指针（比如说是 p），指向栈里的一个局部变量，然后弹出它的栈帧。尽管 p) Tj
T*
(仍然指向一个合法的内存地址，但是它已经不再指向一个合法的变量了。当以后在程序中调用其他函数时，内存将重用它们的栈帧。再后来，如果程序分配某个值给) Tj
T*
(*\\p**，那么它可能实际上正在修改另一个函数的栈帧中的一个条目，从而潜在地带来灾难性的、令人困惑的后果。) Tj
T*
ET
endstream
endobj
532 0 obj
<< /Length 2286 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(9.11.9 引用空闲堆块中的数据) Tj
T*
() Tj
T*
() Tj
T*
(一个相似的错误是引用已经被释放了的堆块中的数据。例如，考虑下面的示例，这个示例在第 6 行分配了一个整数数组 x，在第 10 行中先释放了块 x，然后在第 14 行中又引用了它：) Tj
T*
() Tj
T*
(    int *heapref\(int n, int m\)) Tj
T*
(    {) Tj
T*
(        int i;) Tj
T*
(        int *x, *y;) Tj
T*
() Tj
T*
(        x = \(int *\)Malloc\(n * sizeof\(int\)\);) Tj
T*
(    .) Tj
T*
(    . // Other calls to malloc and free go here) Tj
T*
(    .) Tj
T*
(        free\(x\);) Tj
T*
() Tj
T*
(        y = \(int *\)Malloc\(m * sizeof\(int\)\);) Tj
T*
(        for \(i = 0; i < m; i++\)) Tj
T*
(            y[i] = x[i]++; /* Oops! x[i] is a word in a free block */) Tj
T*
() Tj
T*
(        return y;) Tj
T*
(    }) Tj
T*
() Tj
T*
(取决于在第 6 行和第 10 行发生的 malloc 和 free 的调用模式，当程序在第 14 行引用 x\\[i\\] 时，数组 x) Tj
T*
(可能是某个其他已分配堆块的一部分了，因此其内容被重写了。和其他许多与内存有关的错误一样，这个错误只会在程序执行的后面，当我们注意到 y 中的值被破坏了时才会显现出来。) Tj
T*
() Tj
T*
(9.11.10 引起内存泄漏) Tj
T*
() Tj
T*
() Tj
T*
(内存泄漏是缓慢、隐性的杀手，当程序员不小心忘记释放已分配块，而在堆里创建了垃圾时，会发生这种问题。例如，下面的函数分配了一个堆块 x，然后不释放它就返回：) Tj
T*
() Tj
T*
(    void leak\(int n\)) Tj
T*
(    {) Tj
T*
(        int *x = \(int *\)Malloc\(n * sizeof\(int\)\);) Tj
T*
(        return;  /* x is garbage at this point */) Tj
T*
(    }) Tj
T*
() Tj
T*
(如果经常调用) Tj
T*
(leak，那么渐渐地，堆里就会充满了垃圾，最糟糕的情况下，会占用整个虚拟地址空间。对于像守护进程和服务器这样的程序来说，内存泄漏是特别严重的，根据定义这些程序是不会终止的。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(9.12 小结) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
ET
endstream
endobj
533 0 obj
<< /Length 4914 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(9.12 小结) Tj
T*
() Tj
T*
() Tj
T*
(虚拟内存是对主存的一个抽象。支持虚拟内存的处理器通过使用一种叫做虚拟寻址的间接形式来引用主存。处理器产生一个虚拟地址，在被发送到主存之前，这个地址被翻译成一个物理地址。从虚拟地址空) Tj
T*
(间到物理地址空间的地址翻译要求硬件和软件紧密合作。专门的硬件通过使用页表来翻译虚拟地址，而页表的内容是由操作系统提供的。) Tj
T*
() Tj
T*
(虚拟内存提供三个重要的功能。第一，它在主存中自动缓存最近使用的存放磁盘上的虚拟地址空间的内容。虚拟内存缓存中的块叫做页。对磁盘上页的引用会触发缺页，缺页将控制转移到操作系统中的一个) Tj
T*
(缺页处理程序。缺页处理程序将页面从磁盘复制到主存缓存，如果必要，将写回被驱逐的页。第二，虚拟内存简化了内存管理，进而又简化了链接、在进程间共享数据、进程的内存分配以及程序加载。最后) Tj
T*
(，虚拟内存通过在每条页表条目中加入保护位，从而了简化了内存保护。) Tj
T*
() Tj
T*
(地址翻译的过程必须和系统中所有的硬件缓存的操作集成在一起。大多数页表条目位于 L1 高速缓存中，但是一个称为 TLB 的页表条目的片上高速缓存，通常会消除访问在 L1) Tj
T*
(上的页表条目的开销。) Tj
T*
() Tj
T*
(现代系统通过将虚拟内存片和磁盘上的文件片关联起来，来初始化虚拟内存片，这个过程称为内存映射。内存映射为共享数据、创建新的进程以及加载程序提供了一种高效的机制。应用可以使用 mmap) Tj
T*
(函数来手工地创建和删除虚拟地址空间的区域。然而，大多数程序依赖于动态内存分配器，例如 malloc，它管理虚拟地址空间区域内一个称为堆的区域。动态内存分配器是一个感觉像系统级程序的) Tj
T*
(应用级程序，它直接操作内存，而无需类型系统的很多帮助。分配器有两种类型。显式分配器要求应用显式地释放它们的内存块。隐式分配器（垃圾收集器）自动释放任何未使用的和不可达的块。) Tj
T*
() Tj
T*
(对于 C 程序员来说，管理和使用虚拟内存是一件困难和容易出错的任务。常见的错误示例包括：间接引用坏指针，读取未初始化的内存，允许栈缓冲区溢岀，假设指针和它们指向的对象大小相同，引用) Tj
T*
(指针而不是它所指向的对象，误解指针运算，引用不存在的变量，以及引起内存泄漏。) Tj
T*
() Tj
T*
(参考文献说明) Tj
T*
() Tj
T*
() Tj
T*
(Kilburn 和他的同事们发表了第一篇关于虚拟内存的描述【63】。体系结构教科书包括关于硬件在虚拟内存中的角色的更多细节【46】。操作系统教科书包含关于操作系统角色的更多信息【1) Tj
T*
(02，106，113】。Bovet 和 Cesati【11】给出了 Linux 虚拟内存系统的详细描述。Intel 公司提供了 IA 处理器上 32 位和 64) Tj
T*
(位地址翻译的详细文档【52】。) Tj
T*
() Tj
T*
(Knuth 在 1968 年编写了有关内存分配的经典之作【64】。从那以后，在这个领域就有了大量的文献。Wilson、Johnstone、Neely 和 Boles) Tj
T*
(编写了一篇关于显式分配器的漂亮综述和性能评价的文章【118】。本书中关于各种分配器策略的吞吐率和利用率的一般评价就引自于他们的调查。Jones 和 Lins) Tj
T*
(提供了关于垃圾收集的全面综述【56】。Kernighan 和 Ritchie【61】展示了一个简单分配器的完整代码，这个简单的分配器是基于显式空闲链表的，每个空闲块中都有一个块大小) Tj
T*
(和后继指针。这段代码使用联合（union）来消除大量的复杂指针运算，这是很有趣的，但是代价是释放操作是线性时间（而不是常数时间）。Doug Lea 开发了广泛使用的开源) Tj
T*
(malloc 包，称为 dlmalloc【67】。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(家庭作业) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(家庭作业) Tj
T*
() Tj
T*
() Tj
T*
(练习题 9.11) Tj
T*
() Tj
T*
() Tj
T*
(在下面的一系列问题中，你要展示 9.6.4 节中的示例内存系统如何将虚拟地址翻译成物理地址，以及如何访问缓存。对于给定的虚拟地址，请指出访问的 TLB) Tj
T*
(条目、物理地址，以及返回的缓存字节值。请指明是否 TLB 不命中，是否发生了缺页，是否发生了缓存不命中。如果有缓存不命中，对于“返回的缓存字节”用 “—” 来表示。如果有缺页，对于) Tj
T*
ET
endstream
endobj
534 0 obj
<< /Length 1068 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(“PPN” 用 "—”来表示，而 C 部分和 D 部分就空着。) Tj
T*
() Tj
T*
(虚拟地址：0x027C) Tj
T*
() Tj
T*
(A. 虚拟地址格式) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(B. 地址翻译) Tj
T*
() Tj
T*
(| 参数 | 值 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| VPN |  |) Tj
T*
(| TLB 索引 |  |) Tj
T*
(| TLB 标记 |  |) Tj
T*
(| TLB 命中？（是/否） |  |) Tj
T*
(| 缺页？（是/否） |  |) Tj
T*
(| PPN |  |) Tj
T*
() Tj
T*
(C. 物理地址格式) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(D. 物理地址引用) Tj
T*
() Tj
T*
(| 参数 | 值 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| 字节偏移 |  |) Tj
T*
(| 缓存索引 |  |) Tj
T*
(| 缓存标记 |  |) Tj
T*
(| 缓存命中？（是/否） |  |) Tj
T*
(| 返回的缓存字节 |  |) Tj
T*
() Tj
T*
(练习题 9.12) Tj
T*
() Tj
T*
() Tj
T*
(对于下面的地址，重复习题 9.11：) Tj
T*
() Tj
T*
(虚拟地址：0x03a9) Tj
T*
() Tj
T*
(A. 虚拟地址格式) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(B. 地址翻译) Tj
T*
() Tj
T*
ET
endstream
endobj
535 0 obj
<< /Length 1075 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(| 参数 | 值 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| VPN |  |) Tj
T*
(| TLB 索引 |  |) Tj
T*
(| TLB 标记 |  |) Tj
T*
(| TLB 命中？（是/否） |  |) Tj
T*
(| 缺页？（是/否） |  |) Tj
T*
(| PPN |  |) Tj
T*
() Tj
T*
(C. 物理地址格式) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(D. 物理地址引用) Tj
T*
() Tj
T*
(| 参数 | 值 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| 字节偏移 |  |) Tj
T*
(| 缓存索引 |  |) Tj
T*
(| 缓存标记 |  |) Tj
T*
(| 缓存命中？（是/否） |  |) Tj
T*
(| 返回的缓存字节 |  |) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(练习题 9.13) Tj
T*
() Tj
T*
() Tj
T*
(对于下面的地址，重复习题 9.11：) Tj
T*
() Tj
T*
(虚拟地址：0x0040) Tj
T*
() Tj
T*
(A. 虚拟地址格式) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(B. 地址翻译) Tj
T*
() Tj
T*
(| 参数 | 值 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| VPN |  |) Tj
T*
(| TLB 索引 |  |) Tj
T*
(| TLB 标记 |  |) Tj
T*
(| TLB 命中？（是/否） |  |) Tj
T*
(| 缺页？（是/否） |  |) Tj
T*
(| PPN |  |) Tj
T*
ET
endstream
endobj
536 0 obj
<< /Length 1881 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(C. 物理地址格式) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(D. 物理地址引用) Tj
T*
() Tj
T*
(| 参数 | 值 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| 字节偏移 |  |) Tj
T*
(| 缓存索引 |  |) Tj
T*
(| 缓存标记 |  |) Tj
T*
(| 缓存命中？（是/否） |  |) Tj
T*
(| 返回的缓存字节 |  |) Tj
T*
() Tj
T*
(练习题 9.14) Tj
T*
() Tj
T*
() Tj
T*
(假设有一个输入文件 hello.txt，由字符串 “Hello, world!\\n” 组成，编写一个 C 程序，使用 mmap 将 hello.txt 的内容改变为 “Jello,) Tj
T*
(world! \\n”。) Tj
T*
() Tj
T*
(练习题 9.15) Tj
T*
() Tj
T*
() Tj
T*
(确定下面的 malloc 请求序列得到的块大小和头部值。假设：1）分配器保持双字对齐，使用隐式空闲链表，以及图 9-35 中的块格式。2）块大小向上舍入为最接近的 8 字节的倍数。) Tj
T*
() Tj
T*
(| 请求 | 块大小（十进制字节） | 块头部（十六进制） |) Tj
T*
(| :--- | :--- | :--- |) Tj
T*
(| malloc\\\(3\\\) |  |  |) Tj
T*
(| malloc\\\(11\\\) |  |  |) Tj
T*
(| malloc\\\(20\\\) |  |  |) Tj
T*
(| malloc\\\(21\\\) |  |  |) Tj
T*
() Tj
T*
(练习题 9.16) Tj
T*
() Tj
T*
() Tj
T*
(确定下面对齐要求和块格式的每个组合的最小块大小。假设：显式空闲链表、每个空闲块中有四字节的 pred 和 succ) Tj
T*
(指针、不允许有效载荷的大小为零，并且头部和脚部存放在一个四字节的字中。) Tj
T*
() Tj
T*
(| 对齐要求 | 已分配块 | 空闲块 | 最小块大小（字节） |) Tj
T*
(| :---: | :--- | :---: | :--- |) Tj
T*
(| 单字 | 头部和脚部 | 头部和脚部 |  |) Tj
T*
(| 单字 | 头部，但是没有脚部 | 头部和脚部 |  |) Tj
T*
(| 双字 | 头部和脚部 | 头部和脚部 |  |) Tj
T*
(| 双字 | 头部，但是没有脚部 | 头部和脚部 |  |) Tj
T*
() Tj
T*
ET
endstream
endobj
537 0 obj
<< /Length 2771 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(练习题 9.17) Tj
T*
() Tj
T*
() Tj
T*
(开发 9.9.12 节中的分配器的一个版本，执行下一次适配搜索，而不是首次适配搜索。) Tj
T*
() Tj
T*
(练习题 9.18) Tj
T*
() Tj
T*
() Tj
T*
(9.9.12 节中的分配器要求每个块既有头部也有脚部，以实现常数时间的合并。修改分配器，使得空闲块需要头部和脚部，而已分配块只需要头部。) Tj
T*
() Tj
T*
(练习题 9.19) Tj
T*
() Tj
T*
() Tj
T*
(下面给出了三组关于内存管理和垃圾收集的陈述。在每一组中，只有一句陈述是正确的。你的任务就是判断哪一句是正确的。) Tj
T*
() Tj
T*
(1.  * a）在一个伙伴系统中，最高可达 50% 的空间可以因为内部碎片而被浪费了。) Tj
T*
(   * b）首次适配内存分配算法比最佳适配算法要慢一些（平均而言）。) Tj
T*
(   * c）只有当空闲链表按照内存地址递增排序时，使用边界标记来回收才会快速。) Tj
T*
(   * d）伙伴系统只会有内部碎片，而不会有外部碎片。) Tj
T*
(2.  * a）在按照块大小递减顺序排序的空闲链表上，使用首次适配算法会导致分配性能很低，但是可以避免外部碎片。) Tj
T*
(   * b）对于最佳适配方法，空闲块链表应该按照内存地址的递增顺序排序。) Tj
T*
(   * c）最佳适配方法选择与请求段匹配的最大的空闲块。) Tj
T*
(   * d）在按照块大小递增的顺序排序的空闲链表上，使用首次适配算法与使用最佳适配算法等价。) Tj
T*
(3. Mark&Sweep 垃圾收集器在下列哪种情况下叫做保守的：) Tj
T*
(   * a）它们只有在内存请求不能被满足时才合并被释放的内存。) Tj
T*
(   * b）它们把一切看起来像指针的东西都当做指针。) Tj
T*
(   * c）它们只在内存用尽时，才执行垃圾收集。) Tj
T*
(   * d）它们不释放形成循环链表的内存块。) Tj
T*
() Tj
T*
(练习题 9.19) Tj
T*
() Tj
T*
() Tj
T*
(编写你自己的 malloc 和 free 版本，将它的运行时间和空间利用率与标准 C 库提供的 malloc 版本进行比较。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(第 10 章：系统级 I/O) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(第 10 章：系统级 I/O) Tj
T*
() Tj
T*
() Tj
T*
(第三部分：程序间的交互和通信) Tj
T*
() Tj
T*
() Tj
T*
(我们学习计算机系统到现在，一直假设程序是独立运行的，只包含最小限度的输入和输出。然而，在现实世界里，应用程序利用操作系统提供的服务来与 I/O 设备及其他程序通信。) Tj
T*
ET
endstream
endobj
538 0 obj
<< /Length 4962 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(本书的这一部分将使你了解 Unix 操作系统提供的基本 I/O 服务，以及如何用这些服务来构造应用程序，例如 Web 客户端和服务器，它们是通过 Internet) Tj
T*
(彼此通信的。你将学习编写诸如 Web 服务器这样的可以同时为多个客户端提供服务的并发程序。编写并发应用程序还能使程序在现代多核处理器上执行得更快。当学完了这个部分，你将逐渐变成一个) Tj
T*
(很牛的程序员，对计算机系统以及它们对程序的影响有很成熟的理解。) Tj
T*
() Tj
T*
(输入/输出（I/O）是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。输入操作是从 I/O 设备复制数据到主存，而输出操作是从主存复制数据到 I/O 设备。) Tj
T*
() Tj
T*
(所有语言的运行时系统都提供执行 I/O 的较高级别的工具。例如，ANSIC 提供标准 I/O 库，包含像 printf 和 scanf 这样执行带缓冲区的 I/O 函数。C++) Tj
T*
(语言用它的重载操作符 &lt;&lt;（输入）和 &gt;&gt;（输出）提供了类似的功能。在 Linux 系统中，是通过使用由内核提供的系统级 Unix I/O) Tj
T*
(函数来实现这些较高级别的 I/O 函数的。大多数时候，高级别 I/O 函数工作良好，没有必要直接使用 Unix I/O。那么为什么还要麻烦地学习 Unix I/O 呢？) Tj
T*
() Tj
T*
(* 了解 Unix I/O 将帮助你理解其他的系统概念。I/O 是系统操作不可或缺的一部分，因此，我们经常遇到 I/O 和其他系统概念之间的循环依赖。例如，I/O) Tj
T*
(在进程的创建和执行中扮演着关键的角色。反过来，进程创建又在不同进程间的文件共享中扮演着关键角色。因此，要真正理解) Tj
T*
(I/O，你必须理解进程，反之亦然。在对存储器层次结构、链接和加载、进程以及虚拟内存的讨论中，我们已经接触了 I/O) Tj
T*
(的某些方面。既然你对这些概念有了比较好的理解，我们就能闭合这个循环，更加深入地研究 I/O。) Tj
T*
(* 有时你除了使用 Unix I/O 以外别无选择。在某些重要的情况中，使用高级 I/O 函数不太可能，或者不太合适。例如，标准 I/O) Tj
T*
(库没有提供读取文件元数据的方式，例如文件大小或文件创建时间。另外，I/O 库还存在一些问题，使得用它来进行网络编程非常冒险。) Tj
T*
() Tj
T*
(这一章介绍 Unix I/O 和标准 I/O 的一般概念，并且向你展示在 C) Tj
T*
(程序中如何可靠地使用它们。除了作为一般性的介绍之外，这一章还为我们随后学习网络编程和并发性奠定坚实的基础。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(10.1 Unix I/O) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(10.1 Unix I/O) Tj
T*
() Tj
T*
() Tj
T*
(一个 Linux 文件就是一个 m 个字节的序列：) Tj
T*
() Tj
T*
($$) Tj
T*
(B0,B1,\\cdots,Bk,\\cdots,B{m-1}) Tj
T*
($$) Tj
T*
() Tj
T*
(所有的 I/O 设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。这种将设备优雅地映射为文件的方式，允许 Linux) Tj
T*
(内核引出一个简单、低级的应用接口，称为 Unix I/O，这使得所有的输入和输出都能以一种统一且一致的方式来执行：) Tj
T*
() Tj
T*
(* 打开文件。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O) Tj
T*
(设备。内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关这个打开文件的所有信息。应用程序只需记住这个描述符。) Tj
T*
(* Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入（描述符为 0）、标准输出（描述符为 1）和标准错误（描述符为 2）。头文件) Tj
T*
(&lt;unistd.h&gt; 定义了常量 STDIN\\FILENO、STDOUT\\FILENO 和 STDERR\\_FILENO，它们可用来代替显式的描述符值。) Tj
T*
(* 改变当前的文件位置。对于每个打开的文件，内核保持着一个文件位置 k，初始为 0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行 seek) Tj
T*
(操作，显式地设置文件的当前位置为 k。) Tj
T*
(* 读写文件。一个读操作就是从文件复制 n &gt; 0 个字节到内存，从当前文件位置 k 开始，然后将 k 增加到 k+n。给定一个大小为 m 字节的文件，当$$\\small) Tj
T*
(k\\geqslant m$$时执行读操作会触发一个称为 end-of-file（EOF）的条件，应用程序能检测到这个条件。在文件结尾处并没有明确的 “EOF 符号”。) Tj
T*
ET
endstream
endobj
539 0 obj
<< /Length 3858 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(  类似地，写操作就是从内存复制 n &gt; 0 个字节到一个文件，从当前文件位置 k 开始，然后更新 k。) Tj
T*
() Tj
T*
(* 关闭文件。当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止) Tj
T*
(时，内核都会关闭所有打开的文件并释放它们的内存资源。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(10.2 文件) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(10.2 文件) Tj
T*
() Tj
T*
() Tj
T*
(每个 Linux 文件都有一个类型（type）来表明它在系统中的角色：) Tj
T*
() Tj
T*
(* 普通文件（regular file）包含任意数据。应用程序常常要区分文本文件（text file）和二进制文件（binary file），文本文件是只含有 ASCII 或) Tj
T*
(Unicode 字符的普通文件；二进制文件是所有其他的文件。对内核而言，文本文件和二进制文件没有区别。) Tj
T*
() Tj
T*
(  Linux 文本文件包含了一个文本行（text line）序列，其中每一行都是一个字符序列，以一个新行符（“\\n”）结束。新行符与 ASCII) Tj
T*
(  的换行符（LF）是一样的，其数字值为 0x0a。) Tj
T*
() Tj
T*
(* 目录（directory）是包含一组链接（link）的文件，其中每个链接都将一个文件名（filename）映射到一个文件，这个文件可能是另一个目录。每个目录至少含有两个条目：是) Tj
T*
(到该目录自身的链接，以及是到目录层次结构（见下文）中父目录（parent directory）的链接。你可以用 mkdir 命令创建一个目录，用 Is 查看其内容，用 rmdir) Tj
T*
(删除该目录。) Tj
T*
(* 套接字（socket）是用来与另一个进程进行跨网络通信的文件（11.4 节）。) Tj
T*
() Tj
T*
(其他文件类型包含命名通道（named pipe）、 符号链接（symbolic link），以及字符和块设备（character and block) Tj
T*
(device），这些不在本书的讨论范畴。) Tj
T*
() Tj
T*
(Linux 内核将所有文件都组织成一个目录层次结构（directory hierarchy），由名为 /（斜杠）的根目录确定。系统中的每个文件都是根目录的直接或间接的后代。图) Tj
T*
(10-1 显示了 Linux 系统的目录层次结构的一部分。) Tj
T*
() Tj
T*
([Image: &#x56FE; 10-1 Linux &#x76EE;&#x5F55;&#x5C42;&#x6B21;&#x7684;&#x4E00;&#x90E8;&#x520) Tj
T*
(6;&#x3002;&#x5C3E;&#x90E8;&#x6709;&#x659C;&#x6760;&#x8868;&#x793A;&#x662F;&#x76EE;&#x5F55;) Tj
T*
(]) Tj
T*
() Tj
T*
(作为其上下文的一部分，每个进程都有一个当前工作目录（current working directory）来确定其在目录层次结构中的当前位置。你可以用 cd 命令来修改 shell) Tj
T*
(中的当前工作目录。) Tj
T*
() Tj
T*
(目录层次结构中的位置用路径名（pathname）来指定。路径名是一个字符串，包括一个可选斜杠，其后紧跟一系列的文件名，文件名之间用斜杠分隔。路径名有两种形式：) Tj
T*
() Tj
T*
(* 绝对路径名（absolute pathname）以一个斜杠开始，表示从根节点开始的路径。例如，在图 10-1 中，hello.c 的绝对路径名为) Tj
T*
(/home/droh/hello.c。) Tj
T*
(* 相对路径名（relative pathname）以文件名开始，表示从当前工作目录开始的路径。例如，在图 10-1 中，如果 /home/droh 是当前工作目录，那么) Tj
T*
(hello.c 的相对路径名就是 ./hello.c。反之，如果 /home/bryant 是当前工作目录，那么相对路径名就是 ../home/droh/hello.c。) Tj
T*
ET
endstream
endobj
540 0 obj
<< /Length 2182 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(10.3 打开和关闭文件) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(10.3 打开和关闭文件) Tj
T*
() Tj
T*
() Tj
T*
(进程是通过调用 open 函数来打开一个已存在的文件或者创建一个新文件的：) Tj
T*
() Tj
T*
(    #include <sys/types.h>) Tj
T*
(    #include <sys/stat.h>) Tj
T*
(    #include <fcntl.h>) Tj
T*
() Tj
T*
(    int open\(char *filename, int flags, mode_t mode\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为新文件描述符，若出错为 -1。) Tj
T*
() Tj
T*
(open 函数将 filename 转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。flags 参数指明了进程打算如何访问这个文件：) Tj
T*
() Tj
T*
(* O\\_RDONLY：只读。) Tj
T*
(* O\\_WRONLY：只写。) Tj
T*
(* O\\_RDWR：可读可写。) Tj
T*
() Tj
T*
(例如，下面的代码说明如何以读的方式打开一个已存在的文件：) Tj
T*
() Tj
T*
(    fd = Open\("foo.txt", O_RDONLY, 0\);) Tj
T*
() Tj
T*
(flags 参数也可以是一个或者更多位掩码的或，为写提供给一些额外的指示：) Tj
T*
() Tj
T*
(* O\\_CREAT：如果文件不存在，就创建它的一个截断的（truncated）（空）文件。) Tj
T*
(* O\\_TRUNC：如果文件已经存在，就截断它。) Tj
T*
(* O\\_APPEND：在每次写操作前，设置文件位置到文件的结尾处。) Tj
T*
() Tj
T*
(例如，下面的代码说明的是如何打开一个已存在文件，并在后面添加一些数据：) Tj
T*
() Tj
T*
(    fd = Open\("foo.txt", O_WRONLY|O_APPEND, 0\);) Tj
T*
() Tj
T*
(mode 参数指定了新文件的访问权限位。这些位的符号名字如图 10-2 所示。) Tj
T*
() Tj
T*
(| 掩码 | 描述 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| S\\_IRUSR | 使用者（拥有者）能够读这个文件 |) Tj
T*
(| S\\_IWUSR | 使用者（拥有者）能够写这个文件 |) Tj
T*
(| S\\_IXUSR | 使用者（拥有者）能够执行这个文件 |) Tj
T*
ET
endstream
endobj
541 0 obj
<< /Length 2016 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(| S\\_IRGRP | 拥有者所在组的成员能够读这个文件 |) Tj
T*
(| S\\_IWGRP | 拥有者所在组的成员能够写这个文件 |) Tj
T*
(| S\\_IXGRP | 拥有者所在组的成员能够执行这个文件 |) Tj
T*
(| S\\_IROTH | 其他人（任何人）能够读这个文件 |) Tj
T*
(| S\\_IWOTH | 其他人（任何人）能够写这个文件 |) Tj
T*
(| S\\_IXOTH | 其他人（任何人）能够执行这个文件 |) Tj
T*
() Tj
T*
(> 图 10-2 访问权限位。在 sys/stat.h 中定义) Tj
T*
() Tj
T*
(作为上下文的一部分，每个进程都有一个 umask，它是通过调用 umask 函数来设置的。当进程通过带某个 mode 参数的 open) Tj
T*
(函数调用来创建一个新文件时，文件的访问权限位被设置为 mode & ~umask。例如，假设我们给定下面的 mode 和 umask 默认值：) Tj
T*
() Tj
T*
(    #define DEF_MODE   S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH) Tj
T*
(    #define DEF_UMASK  S_IWGRP|S_IWOTH) Tj
T*
() Tj
T*
(接下来，下面的代码片段创建一个新文件，文件的拥有者有读写权限，而所有其他的用户都有读权限：) Tj
T*
() Tj
T*
(    umask\(DEF_UMASK\);) Tj
T*
(    fd = Open\("foo.txt", O_CREAT|O_TRUNC|O_WRONLY, DEF_MODE\);) Tj
T*
() Tj
T*
(最后，进程通过调用 close 函数关闭一个打开的文件。) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
() Tj
T*
(    int close\(int fd\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为 0，若出错则为 -1。) Tj
T*
() Tj
T*
(关闭一个已关闭的描述符会出错。) Tj
T*
() Tj
T*
(练习题 10.1) Tj
T*
() Tj
T*
() Tj
T*
(下面程序的输出是什么？) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int fd1, fd2;) Tj
T*
() Tj
T*
(        fd1 = Open\("foo.txt", O_RDONLY, 0\);) Tj
T*
(        Close\(fd1\);) Tj
T*
(        fd2 = Open\("baz.txt", O_RDONLY, 0\);) Tj
T*
(        printf\("fd2 = %d\\n", fd2\);) Tj
T*
(        exit\(0\);) Tj
T*
ET
endstream
endobj
542 0 obj
<< /Length 2252 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    }) Tj
T*
() Tj
T*
(Unix 进程生命周期开始时，打开的描述符赋给了 stdin（描述符 0）、stdout（描述符 1）和 stderr（描述符 2）。open) Tj
T*
(函数总是返回最低的未打开的描述符，所以第一次调用。pen 会返回描述符 3。调用 close 函数会释放描述符 3。最后对 open 的调用会返回描述符 3，因此程序的输出是) Tj
T*
(“fd2=3”。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(10.4 读和写文件) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(10.4 读和写文件) Tj
T*
() Tj
T*
() Tj
T*
(应用程序是通过分别调用 read 和 write 函数来执行输入和输出的。) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
() Tj
T*
(    ssize_t read\(int fd, void *buf, size_t n\);) Tj
T*
(    // 返回：若成功则为读的字节数，若 EOF 则为0，若出错为 -1。) Tj
T*
() Tj
T*
(    ssize_t write\(int fd, const void *buf, size_t n\);) Tj
T*
(    // 返回：若成功则为写的字节数，若出错则为 -1。) Tj
T*
() Tj
T*
(read 函数从描述符为 fd 的当前文件位置复制最多 n 个字节到内存位置 buf。返回值 -1 表示一个错误，而返回值 0 表示) Tj
T*
(EOF。否则，返回值表示的是实际传送的字节数量。) Tj
T*
() Tj
T*
(write 函数从内存位置 buf 复制至多 n 个字节到描述符 fd 的当前文件位置。图 10-3 展示了一个程序使用 read 和 write) Tj
T*
(调用一次一个字节地从标准输入复制到标准输出。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(void\)) Tj
T*
(    {) Tj
T*
(        char c;) Tj
T*
() Tj
T*
(        while\(Read\(STDIN_FILENO, &c, 1\) != 0\)) Tj
T*
(            Write\(STDOUT_FILENO, &c, 1\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 10-3 一次一个字节地从标准输入复制到标准输出) Tj
T*
() Tj
T*
(通过调用 lseek 函数，应用程序能够显示地修改当前文件的位置，这部分内容不在我们的讲述范围之内。) Tj
T*
() Tj
T*
(旁注 - ssize\\t 和 size\\t 有些什么区别？) Tj
T*
ET
endstream
endobj
543 0 obj
<< /Length 4154 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
() Tj
T*
(你可能已经注意到了，read 函数有一个 size\\t 的输入参数和一个 ssize\\t 的返回值。那么这两种类型之间有什么区别呢？在 x86-64 系统中，size\\t 被定义为) Tj
T*
(unsigned long，而 ssize\\t（有符号的大小）被定义为 long。read 函数返回一个有符号的大小，而不是一个无符号大小，这是因为出错时它必须返回) Tj
T*
(-1。有趣的是，返回一个 -1 的可能性使得 read 的最大值减小了一半。) Tj
T*
() Tj
T*
(在某些情况下，read 和 write 传送的字节比应用程序要求的要少。这些不足值（short count）不表示有错误。出现这样情况的原因有：) Tj
T*
() Tj
T*
(* 读时遇到 EOF。假设我们准备读一个文件，该文件从当前文件位置开始只含有 20 多个字节，而我们以 50 个字节的片进行读取。这样一来，下一个 read 返回的不足值为) Tj
T*
(20，此后的 read 将通过返回不足值 0 来发出 EOF 信号。) Tj
T*
(* 从终端读文本行。如果打开文件是与终端相关联的（如键盘和显示器），那么每个 read 函数将一次传送一个文本行，返回的不足值等于文本行的大小。) Tj
T*
(* 读和写网络套接字（socket）。如果打开的文件对应于网络套接字（11.4 节），那么内部缓冲约束和较长的网络延迟会引起 read 和 write 返回不足值。对 Linux) Tj
T*
(管道（pipe）调用 read 和 write 时，也有可能出现不足值，这种进程间通信机制不在我们讨论的范围之内。) Tj
T*
() Tj
T*
(实际上，除了 EOF，当你在读磁盘文件时，将不会遇到不足值，而且在写磁盘文件时，也不会遇到不足值。然而，如果你想创建健壮的（可靠的）诸如 Web) Tj
T*
(服务器这样的网络应用，就必须通过反复调用 read 和 write 处理不足值，直到所有需要的字节都传送完毕。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(10.5 用 RIO 包健壮地读写) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(10.5 用 RIO 包健壮地读写) Tj
T*
() Tj
T*
() Tj
T*
(在这一小节里，我们会讲述一个 I/O 包，称为 RIO（Robust I/O，健壮的 I/O）包，它会自动为你处理上文中所述的不足值。在像网络程序这样容易出现不足值的应用中，RIO) Tj
T*
(包提供了方便、健壮和高效的 I/O。RIO 提供了两类不同的函数：) Tj
T*
() Tj
T*
(* 无缓冲的输入输出函数。这些函数直接在内存和文件之间传送数据，没有应用级缓冲。它们对将二进制数据读写到网络和从网络读写二进制数据尤其有用。) Tj
T*
(* 带缓冲的输入函数。这些函数允许你高效地从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，类似于为 printf 这样的标准 I/O) Tj
T*
(函数提供的缓冲区。与【110】中讲述的带缓冲的 I/O 例程不同，带缓冲的 RIO 输入函数是线程安全的（12.7.1) Tj
T*
(节），它在同一个描述符上可以被交错地调用。例如，你可以从一个描述符中读一些文本行，然后读取一些二进制数据，接着再多读取一些文本行。) Tj
T*
() Tj
T*
(我们讲述 RIO 例程有两个原因。第一，在接下来的两章中，我们开发的网络应用中使用了它们；第二，通过学习这些例程的代码，你将从总体上对 Unix I/O 有更深入的了解。) Tj
T*
() Tj
T*
(10.5.1 RIO 的无缓冲的输入输出函数) Tj
T*
() Tj
T*
() Tj
T*
(通过调用 rio\\readn 和 rio\\writen 函数，应用程序可以在内存和文件之间直接传送数据。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    ssize_t rio_readn\(int fd, void *usrbuf, size_t n\);) Tj
T*
(    ssize_t rio_writen\(int fd, void *usrbuf, size_t n\);) Tj
T*
(    // 返回：若成功则为传送的字节数，若 EOF 则为 0\(只对 rio_readn 而言\)，若出错则为 -1。) Tj
T*
() Tj
T*
ET
endstream
endobj
544 0 obj
<< /Length 2375 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(rio\\readn 函数从描述符 fd 的当前文件位置最多传送 n 个字节到内存位置 usrbuf。类似地，rio\\writen 函数从位置 usrbuf 传送 n 个字节到描述符) Tj
T*
(fd。rio\\read 函数在遇到 EOF 时只能返回一个不足值。rio\\writen 函数决不会返回不足值。对同一个描述符，可以任意交错地调用 rio\\readn 和) Tj
T*
(rio\\writen。) Tj
T*
() Tj
T*
(图 10-4 显示了 rio\\readn 和 rio\\writen 的代码。注意，如果 rio\\readn 和 rio\\writen) Tj
T*
(函数被一个从应用信号处理程序的返回中断，那么每个函数都会手遍地重启 read 或 write。为了尽可能有较好的可移植性，我们允许被中断的系统调用，且在必要时重启它们。) Tj
T*
() Tj
T*
(    ssize_t rio_readn\(int fd, void *usrbuf, size_t n\)) Tj
T*
(    {) Tj
T*
(        size_t nleft = n;) Tj
T*
(        ssize_t nread;) Tj
T*
(        char *bufp = usrbuf;) Tj
T*
() Tj
T*
(        while \(nleft > 0\) {) Tj
T*
(            if \(\(nread = read\(fd, bufp, nleft\)\) < 0\) {) Tj
T*
(                if \(errno == EINTR\) /* Interrupted by sig handler return */) Tj
T*
(                    nread = 0;      /* and call read\(\) again */) Tj
T*
(                else) Tj
T*
(                    return -1;      /* errno set by read\(\) */) Tj
T*
(            }) Tj
T*
(            else if \(nread == 0\)) Tj
T*
(                break;              /* EOF */) Tj
T*
(            nleft -= nread;) Tj
T*
(            bufp += nread;) Tj
T*
(        }) Tj
T*
(        return \(n - nleft\);         /* Return >= 0 */) Tj
T*
(    }) Tj
T*
() Tj
T*
(    ssize_t rio_writen\(int fd, void *usrbuf, size_t n\)) Tj
T*
(    {) Tj
T*
(        size_t nleft = n;) Tj
T*
(        ssize_t nwritten;) Tj
T*
(        char *bufp = usrbuf;) Tj
T*
() Tj
T*
(        while \(nleft > 0\) {) Tj
T*
(            if \(\(nwritten = write\(fd, bufp, nleft\)\) <= 0\) {) Tj
T*
(                if \(errno == EINTR\)  /* Interrupted by sig handler return */) Tj
T*
(                    nwritten = 0;    /* and call write\(\) again */) Tj
T*
(                else) Tj
T*
(                    return -1;       /* errno set by write\(\) */) Tj
T*
(            }) Tj
T*
(            nleft -= nwritten;) Tj
T*
(            bufp += nwritten;) Tj
T*
(        }) Tj
T*
(        return n;) Tj
T*
(    }) Tj
T*
ET
endstream
endobj
545 0 obj
<< /Length 2880 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(> 图 10-4 rio\\readn 和 rio\\writen 函数) Tj
T*
() Tj
T*
(10.5.2 RIO 的带缓冲的输入函数) Tj
T*
() Tj
T*
() Tj
T*
(假设我们要编写一个程序来计算文本文件中文本行的数量，该如何来实现呢？一种方法就是用 read) Tj
T*
(函数来一次一个字节地从文件传送到用户内存，检查每个字节来查找换行符。这个方法的缺点是效率不是很高，每读取文件中的一个字节都要求陷入内核。) Tj
T*
() Tj
T*
(一种更好的方法是调用一个包装函数（rio\\readlineb），它从一个内部读缓冲区复制一个文本行，当缓冲区变空时，会自动地调用 read) Tj
T*
(重新填满缓冲区。对于既包含文本行也包含二进制数据的文件（例如 11.5.3 节中描述的 HTTP 响应），我们也提供了一个 rio\\readn 带缓冲区的版本，叫做) Tj
T*
(rio\\readnb，它从和 rio\\readlineb 一样的读缓冲区中传送原始字节。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void rio_readinitb\(rio_t *rp, int fd\);) Tj
T*
(    // 返回：无。) Tj
T*
() Tj
T*
(    ssize_t rio_readlineb\(rio_t *rp, void *usrbuf, size_t maxlen\);) Tj
T*
(    ssize_t rio_readnb\(rio_t *rp, void *usrbuf, size_t n\);) Tj
T*
(    // 返回：若成功则为读的字节数，若 EOF 则为 0，若出错则为 -1。) Tj
T*
() Tj
T*
(每打开一个描述符，都会调用一次 rio\\readinitb 函数。它将描述符 fd 和地址 rp 处的一个类型为 rio\\t 的读缓冲区联系起来。) Tj
T*
() Tj
T*
(rio\\readlineb 函数从文件叩读出下一个文本行（包括结尾的换行符），将它复制到内存位置 usrbuf，并且用) Tj
T*
(NULL（零）字符来结束这个文本行。rio\\readlineb 函数最多读 maxlen-1 个字节，余下的一个字符留给结尾的 NULL 字符。超过 maxlen-1) Tj
T*
(字节的文本行被截断，并用一个 NULL 字符结束。) Tj
T*
() Tj
T*
(rio\\readnb 函数从文件 rp 最多读 n 个字节到内存位置 usrbuf。对同一描述符，对 rio\\readlineb 和 rio\\readnb) Tj
T*
(的调用可以任意交叉进行。然而，对这些带缓冲的函数的调用却不应和无缓冲的 rio\\readn 函数交叉使用。) Tj
T*
() Tj
T*
(在本书剩下的部分中将给出大量的 RIO 函数的示例。图 10-5 展示了如何使用 RIO 函数来一次一行地从标准输入复制一个文本文件到标准输出。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        int n;) Tj
T*
(        rio_t rio;) Tj
T*
(        char buf[MAXLINE];) Tj
T*
() Tj
T*
(        Rio_readinitb\(&rio, STDIN_FILENO\);) Tj
T*
(        while \(\(n = Rio_readlineb\(&rio, buf, MAXLINE\)\) != 0\)) Tj
T*
(            Rio_writen\(STDOUT_FILENO, buf, n\);) Tj
T*
(    }) Tj
T*
() Tj
T*
ET
endstream
endobj
546 0 obj
<< /Length 2519 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(> 图 10-5 从标准输入复制一个文本文件到标准输出) Tj
T*
() Tj
T*
(图 10-6 展示了一个读缓冲区的格式，以及初始化它的 rio\\readinitb 函数的代码。rio\\readinitb) Tj
T*
(函数创建了一个空的读缓冲区，并且将一个打开的文件描述符和这个缓冲区联系起来。) Tj
T*
() Tj
T*
(    #define RIO_BUFSIZE 8192) Tj
T*
(    typedef struct {) Tj
T*
(        int rio_fd;                /* Descriptor for this internal buf */) Tj
T*
(        int rio_cnt;               /* Unread bytes in internal buf */) Tj
T*
(        char *rio_bufptr;          /* Next unread byte in internal buf */) Tj
T*
(        char rio_buf[RIO_BUFSIZE]; /* Internal buffer */) Tj
T*
(    } rio_t;) Tj
T*
() Tj
T*
(    void rio_readinitb\(rio_t *rp, int fd\)) Tj
T*
(    {) Tj
T*
(        rp->rio_fd = fd;) Tj
T*
(        rp->rio_cnt = 0;) Tj
T*
(        rp->rio_bufptr = rp->rio_buf;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 10-6 一个类型为 rio\\t 的读缓冲区和初始化它的 rio\\readinitb 函数) Tj
T*
() Tj
T*
(RIO 读程序的核心是图 10-7 所示的 rio\\read 函数。rio\\read 函数是 Linuxread 函数的带缓冲的版本。当调用 rio\\read 要求读 n) Tj
T*
(个字节时，读缓冲区内有 rp-&gt;rio\\cnt 个未读字节。如果缓冲区为空，那么会通过调用 read 再填满它。这个 read) Tj
T*
(调用收到一个不足值并不是错误，只不过读缓冲区是填充了一部分。一旦缓冲区非空，rio\\read 就从读缓冲区复制 n 和 rp-&gt;rio\\cnt) Tj
T*
(中较小值个字节到用户缓冲区，并返回复制的字节数。) Tj
T*
() Tj
T*
(    static ssize_t rio_read\(rio_t *rp, char *usrbuf, size_t n\)) Tj
T*
(    {) Tj
T*
(        int cnt;) Tj
T*
() Tj
T*
(        while \(rp->rio_cnt <= 0\) {  /* Refill if buf is empty */) Tj
T*
(            rp->rio_cnt = read\(rp->rio_fd, rp->rio_buf,) Tj
T*
(                               sizeof\(rp->rio_buf\)\);) Tj
T*
(            if \(rp->rio_cnt < 0\) {) Tj
T*
(                if \(errno != EINTR\) /* Interrupted by sig handler return */) Tj
T*
(                    return -1;) Tj
T*
(            }) Tj
T*
(            else if \(rp->rio_cnt == 0\)  /* EOF */) Tj
T*
(                return 0;) Tj
T*
(            else) Tj
T*
(                rp->rio_bufptr = rp->rio_buf; /* Reset buffer ptr */) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Copy min\(n, rp->rio_cnt\) bytes from internal buf to user buf */) Tj
T*
(        cnt = n;) Tj
T*
ET
endstream
endobj
547 0 obj
<< /Length 2193 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        if \(rp->rio_cnt < n\)) Tj
T*
(            cnt = rp->rio_cnt;) Tj
T*
(        memcpy\(usrbuf, rp->rio_bufptr, cnt\);) Tj
T*
(        rp->rio_bufptr += cnt;) Tj
T*
(        rp->rio_cnt -= cnt;) Tj
T*
(        return cnt;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 10-7 内部的 rio\\_read 函数) Tj
T*
() Tj
T*
(对于一个应用程序，rio\\read 函数和 Linuxread 函数有同样的语义。在出错时，它返回值 -1，并且适当地设置 errno。在 EOF 时，它返回值) Tj
T*
(0。如果要求的字节数超过了读缓冲区内未读的字节的数量，它会返回一个不足值。两个函数的相似性使得很容易通过用 rio\\read 代替 read) Tj
T*
(来创建不同类型的带缓冲的读函数。例如，用 rio\\read 代替 read，图 10-8 中的 rio\\readnb 函数和 rio\\readn 有相同的结构。相似地，图 10-8) Tj
T*
(中的 rio\\readlineb 程序最多调用 maxlen-1 次 rio\\_read。每次调用都从读缓冲区返回一个字正然后检查这个字节是否是结尾的换行符。) Tj
T*
() Tj
T*
(    ssize_t rio_readlineb\(rio_t *rp, void *usrbuf, size_t maxlen\)) Tj
T*
(    {) Tj
T*
(        int n, rc;) Tj
T*
(        char c, *bufp = usrbuf;) Tj
T*
() Tj
T*
(        for \(n = 1; n < maxlen; n++\) {) Tj
T*
(            if \(\(rc = rio_read\(rp, &c, 1\)\) == 1\) {) Tj
T*
(                *bufp++ = c;) Tj
T*
(                if \(c == ’\\n’\) {) Tj
T*
(                    n++;) Tj
T*
(                    break;) Tj
T*
(                }) Tj
T*
(            } else if \(rc == 0\) {) Tj
T*
(                if \(n == 1\)) Tj
T*
(                    return 0; /* EOF, no data read */) Tj
T*
(                else) Tj
T*
(                    break;    /* EOF, some data was read */) Tj
T*
(            } else) Tj
T*
(                return -1;    /* Error */) Tj
T*
(        }) Tj
T*
(        *bufp = 0;) Tj
T*
(        return n - 1;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    ssize_t rio_readnb\(rio_t *rp, void *usrbuf, size_t n\)) Tj
T*
(    {) Tj
T*
(        size_t nleft = n;) Tj
T*
(        ssize_t nread;) Tj
T*
(        char *bufp = usrbuf;) Tj
T*
() Tj
T*
(        while \(nleft > 0\) {) Tj
T*
ET
endstream
endobj
548 0 obj
<< /Length 2603 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            if \(\(nread = rio_read\(rp, bufp, nleft\)\) < 0\)) Tj
T*
(                return -1;          /* errno set by read\(\) */) Tj
T*
(            else if \(nread == 0\)) Tj
T*
(                break;              /* EOF */) Tj
T*
(            nleft -= nread;) Tj
T*
(            bufp += nread;) Tj
T*
(        }) Tj
T*
(        return \(n - nleft\);         /* Return >= 0 */) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 10-8 rio\\readlineb 和 rio\\readnb 函数) Tj
T*
() Tj
T*
(旁注 - RIO 包的起源) Tj
T*
() Tj
T*
() Tj
T*
(RIO 函数的灵感来自于 W. Richard Stevens 在他的经典网络编程作品【110】中描述的 readLine、readn 和 writen 函数。rio\\readn) Tj
T*
(和 rio\\writen 函数与 Stevens 的 readn 和 writen 函数是一样的。然而，Stevens 的 readline 函数有一些局限性在 RI0) Tj
T*
(中得到了纠正。第一，因为 readline 是带缓冲的，而 readn 不带，所以这两个函数不能在同一描述符上一起使用。第二，因为它使用一个 static 缓冲区，Stevens) Tj
T*
(的 readline 函数不是线程安全的，这就要求 Stevens 引入一个不同的线程安全的版本，称为 read-line\\ro 我们已经在 rio\\readlineb 和) Tj
T*
(rio\\_readnb 函数中修改了这两个缺陷，使得这两个函数是相互兼容和线程安全的。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(10.6 读取文件元数据) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(10.6 读取文件元数据) Tj
T*
() Tj
T*
() Tj
T*
(应用程序能够通过调用 stat 和 fstat 函数，检索到关于文件的信息（有时也称为文件的元数据（metadata））。) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
(    #include <sys/stat.h>) Tj
T*
() Tj
T*
(    int stat\(const char *filename, struct stat *buf\);) Tj
T*
(    int fstat\(int fd, struct stat *buf\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为 0，若出错则为 -1。) Tj
T*
() Tj
T*
(stat 函数以一个文件名作为输入，并填写如图 10-9 所示的一个 stat 数据结构中的各个成员。fstat 函数是相似的，只不过是以文件描述符而不是文件名作为输入。当我们在) Tj
T*
(11.5 节中讨论 Web 服务器时，会需要 stat 数据结构中的 st\\mode 和 st\\size 成员，其他成员则不在我们的讨论之列。) Tj
T*
() Tj
T*
(    /* Metadata returned by the stat and fstat functions */) Tj
T*
(    struct stat {) Tj
T*
ET
endstream
endobj
549 0 obj
<< /Length 2322 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        dev_t         st_dev;      /* Device */) Tj
T*
(        ino_t         st_ino;      /* inode */) Tj
T*
(        mode_t        st_mode;     /* Protection and file type */) Tj
T*
(        nlink_t       st_nlink;    /* Number of hard links */) Tj
T*
(        uid_t         st_uid;      /* User ID of owner */) Tj
T*
(        gid_t         st_gid;      /* Group ID of owner */) Tj
T*
(        dev_t         st_rdev;     /* Device type \(if inode device\) */) Tj
T*
(        off_t         st_size;     /* Total size, in bytes */) Tj
T*
(        unsigned long st_blksize;  /* Block size for filesystem I/O */) Tj
T*
(        unsigned long st_blocks;   /* Number of blocks allocated */) Tj
T*
(        time_t        st_atime;    /* Time of last access */) Tj
T*
(        time_t        st_mtime;    /* Time of last modification */) Tj
T*
(        time_t        st_ctime;    /* Time of last change */) Tj
T*
(    };) Tj
T*
() Tj
T*
(> 图 10-9 stat 数据结构) Tj
T*
() Tj
T*
(st\\size 成员包含了文件的字节数大小。st\\mode 成员则编码了文件访问许可位（图 10-2）和文件类型（10.2 节）。Linux 在 sys/stat.h) Tj
T*
(中定义了宏谓词来确定 st\\_mode 成员的文件类型：) Tj
T*
() Tj
T*
(* S\\_ISREG\\\(m\\\)。这是一个普通文件吗？) Tj
T*
(* S\\_ISDIR\\\(m\\\)。这是一个目录文件吗？) Tj
T*
(* S\\_ISSOCK\\\(m\\\)。这是一个网络套接字吗？) Tj
T*
() Tj
T*
(图 10-10 展示了我们会如何使用这些宏和 stat 函数来读取和解释一个文件的 st\\_mode 位。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main \(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        struct stat stat;) Tj
T*
(        char *type, *readok;) Tj
T*
() Tj
T*
(        Stat\(argv[1], &stat\);) Tj
T*
(        if \(S_ISREG\(stat.st_mode\)\)     /* Determine file type */) Tj
T*
(            type = "regular";) Tj
T*
(        else if \(S_ISDIR\(stat.st_mode\)\)) Tj
T*
(            type = "directory";) Tj
T*
(        else) Tj
T*
(            type = "other";) Tj
T*
(        if \(\(stat.st_mode & S_IRUSR\)\)  /* Check read access */) Tj
T*
(            readok = "yes";) Tj
T*
(        else) Tj
T*
(            readok = "no";) Tj
T*
() Tj
T*
(        printf\("type: %s, read: %s\\n", type, readok\);) Tj
T*
ET
endstream
endobj
550 0 obj
<< /Length 2045 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 10-10 查询和处理一个文件的 st\\_mode 位) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(10.7 读取目录内容) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(10.7 读取目录内容) Tj
T*
() Tj
T*
() Tj
T*
(应用程序可以用 readdir 系列函数来读取目录的内容。) Tj
T*
() Tj
T*
(    #include <sys/types.h>) Tj
T*
(    #include <dirent.h>) Tj
T*
() Tj
T*
(    DIR *opendir\(const char *name\);) Tj
T*
() Tj
T*
(    // 返回：若成功，则为处理的指针；若出错，则为 NULL。) Tj
T*
() Tj
T*
(函数 opendir 以路径名为参数，返回指向目录流（directory stream）的指针。流是对条目有序列表的抽象，在这里是指目录项的列表。) Tj
T*
() Tj
T*
(    #include <dirent.h>) Tj
T*
() Tj
T*
(    struct dirent *readdir\(DIR *dirp\);) Tj
T*
() Tj
T*
(    // 返回：若成功，则为指向下一个目录项的指针；) Tj
T*
(    //      若没有更多的目录项或出错，则为 NULL。) Tj
T*
() Tj
T*
(每次对 readdir 的调用返回的都是指向流 dirp 中下一个目录项的指针，或者，如果没有更多目录项则返回 NULL。每个目录项都是一个结构，其形式如下：) Tj
T*
() Tj
T*
(    struct dirent {) Tj
T*
(        ino_t d_ino;      /* inode number */) Tj
T*
(        char d_name[256]; /* Filename */) Tj
T*
(    };) Tj
T*
() Tj
T*
(虽然有些 Linux 版本包含了其他的结构成员，但是只有这两个对所有系统来说都是标准的。成员 d\\name 是文件名，d\\ino 是文件位置。) Tj
T*
() Tj
T*
(如果出错，则 readdir 返回 NULL，并设置 errno。可惜的是，唯一能区分错误和流结束情况的方法是检査自调用 readdir 以来 errno 是否被修改过。) Tj
T*
() Tj
T*
(    #include <dirent.h>) Tj
T*
() Tj
T*
(    int closedir\(DIR *dirp\);) Tj
T*
() Tj
T*
ET
endstream
endobj
551 0 obj
<< /Length 2583 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    // 返回：成功为 0；错误为 -1。) Tj
T*
() Tj
T*
(函数 closedir 关闭流并释放其所有的资源。图 10-11 展示了怎样用 readdir 来读取目录的内容。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        DIR *streamp;) Tj
T*
(        struct dirent *dep;) Tj
T*
() Tj
T*
(        streamp = Opendir\(argv[1]\);) Tj
T*
() Tj
T*
(        errno = 0;) Tj
T*
(        while \(\(dep = readdir\(streamp\)\) != NULL\) {) Tj
T*
(            printf\("Found file: %s\\n", dep->d_name\);) Tj
T*
(        }) Tj
T*
(        if \(errno != 0\)) Tj
T*
(            unix_error\("readdir error"\);) Tj
T*
() Tj
T*
(        Closedir\(streamp\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 10-11 读取目录的内容) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(10.8 共享文件) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(10.8 共享文件) Tj
T*
() Tj
T*
() Tj
T*
(可以用许多不同的方式来共享 Linux 文件。除非你很清楚内核是如何表示打开的文件，否则文件共享的概念相当难懂。内核用三个相关的数据结构来表示打开的文件：) Tj
T*
() Tj
T*
(* 描述符表（descriptor table）。每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向文件表中的一个表项。) Tj
T*
(* 文件表（file) Tj
T*
(table）。打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。每个文件表的表项组成（针对我们的目的）包括当前的文件位置、引用计数（reference) Tj
T*
(count）（即当前指向该表项的描述符表项数），以及一个指向 v-node) Tj
T*
(表中对应表项的指针。关闭一个描述符会减少相应的文件表表项中的引用计数。内核不会删除这个文件表表项，直到它的引用计数为零。) Tj
T*
(* v-node 表（v-node table）。同文件表一样，所有的进程共享这张 v-node 表。每个表项包含 stat 结构中的大多数信息，包括 st\\mode 和) Tj
T*
(st\\size 成员。) Tj
T*
() Tj
T*
(图 10-12 展示了一个示例，其中描述符 1 和 4 通过不同的打开文件表表项来引用两个不同的文件。这是一种典型的情况，没有共享文件，并且每个描述符对应一个不同的文件。) Tj
T*
() Tj
T*
ET
endstream
endobj
552 0 obj
<< /Length 2417 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
([Image: Image]) Tj
T*
() Tj
T*
(> 图 10-12 典型的打开文件的内核数据结构。在这个示例中，两个描述符引用不同的文件。没有共享) Tj
T*
() Tj
T*
(如图 10-13 所示，多个描述符也可以通过不同的文件表表项来引用同一个文件。例如，如果以同一个 filename 调用 open) Tj
T*
(函数两次，就会发生这种情况。关键思想是每个描述符都有它自己的文件位置，所以对不同描述符的读操作可以从文件的不同位置获取数据。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 10-13 文件共享。这个例子展示了两个描述符通过两个打开文件表表项共享同一个磁盘文件) Tj
T*
() Tj
T*
(我们也能理解父子进程是如何共享文件的。假设在调用 fork 之前，父进程有如图 10-12 所示的打开文件。然后，图 10-14 展示了调用 fork 后的情况。子进程有一个父进程) Tj
T*
(描述符表的副本。父子进程共享相同的打开文件表集合，因此共享相同的文件位置。一个很重要的结果就是，在内核删除相应文件表表项之前，父子进程必须都关闭了它们的描述符。) Tj
T*
() Tj
T*
([Image: &#x56FE; 10-14 &#x5B50;&#x8FDB;&#x7A0B;&#x5982;&#x4F55;&#x7EE7;&#x627F;&#x7236;&#x) Tj
T*
(8FDB;&#x7A0B;&#x7684;&#x6253;&#x5F00;&#x6587;&#x4EF6;&#x3002;&#x521D;&#x59CB;&#x72B6;&#x60) Tj
T*
(01;&#x5982;&#x56FE; 10-12 &#x6240;&#x793A;]) Tj
T*
() Tj
T*
(练习题 10.2) Tj
T*
() Tj
T*
() Tj
T*
(假设磁盘文件 foobar.txt 由 6 个 ASCII 码字符 “foobar” 组成。那么，下列程序的输出是什么？) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int fd1, fd2;) Tj
T*
(        char c;) Tj
T*
() Tj
T*
(        fd1 = Open\("foobar.txt", O_RDONLY, 0\);) Tj
T*
(        fd2 = Open\("foobar.txt", O_RDONLY, 0\);) Tj
T*
(        Read\(fd1, &c, 1\);) Tj
T*
(        Read\(fd2, &c, 1\);) Tj
T*
(        printf\("c = %c\\n", c\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(描述符 fd1 和 fd2 都有各自的打开文件表表项，所以每个描述符对于 foobar.txt 都有它自己的文件位置。因此，从 fd2 的读操作会读取 foobar.txt) Tj
T*
(的第一个字节，并输出) Tj
T*
() Tj
T*
(c = f) Tj
T*
() Tj
T*
(而不是像你开始可能想的) Tj
T*
() Tj
T*
(c = o) Tj
T*
ET
endstream
endobj
553 0 obj
<< /Length 1919 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(练习题 10.3) Tj
T*
() Tj
T*
() Tj
T*
(就像前面那样，假设磁盘文件 foobar.txt 由 6 个 ASCII 码字符 “foobar” 那么下列程序的输出是什么？) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int fd;) Tj
T*
(        char c;) Tj
T*
() Tj
T*
(        fd = Open\("foobar.txt", O_RDONLY, 0\);) Tj
T*
(        if \(Fork\(\) == 0\) {) Tj
T*
(            Read\(fd, &c, 1\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
(        Wait\(NULL\);) Tj
T*
(        Read\(fd, &c, 1\);) Tj
T*
(        printf\("c = %c\\n", c\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(回想一下，子进程会继承父进程的描述符表，以及所有进程共享的同一个打开文件表。因此，描述符 fd 在父子进程中都指向同一个打开文件表表项。当子进程读取文件的第一个字节时，文件位置加) Tj
T*
(1。因此，父进程会读取第二个字节，而输出就是) Tj
T*
() Tj
T*
(c = o) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(10.9 I/O 重定向) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(10.9 I/O 重定向) Tj
T*
() Tj
T*
() Tj
T*
(Linuxshell 提供了 I/O 重定向操作符，允许用户将磁盘文件和标准输入输出联系起来。例如，键入) Tj
T*
() Tj
T*
(    linux> ls > foo.txt) Tj
T*
() Tj
T*
(使得 shell 加载和执行 Is 程序，将标准输出重定向到磁盘文件 foo.txto 就如我们将在 11.5 节中看到的那样，当一个 Web 服务器代表客户端运行 CGI) Tj
T*
(程序时，它就执行一种相似类型的重定向。那么 I/O 重定向是如何工作的呢？一种方式是使用 dup2 函数。) Tj
T*
() Tj
T*
(    #include <unistd.h>) Tj
T*
() Tj
T*
ET
endstream
endobj
554 0 obj
<< /Length 2324 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    int dup2\(int oldfd, int newfd\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为非负的描述符，若出错则为 -1。) Tj
T*
() Tj
T*
(dup2 函数复制描述符表表项 oldfd 到描述符表表项 newfd，覆盖描述符表表项 newfd 以前的内容。如果 newfd 已经打开了，dup2 会在复制 oldfd) Tj
T*
(之前关闭 newfd。) Tj
T*
() Tj
T*
(假设在调用 dup2\\\(4,1\\\) 之前，我们的状态如图 10-12 所示，其中描述符 1（标准输出）对应于文件 A（比如一个终端），描述符 4 对应于文件) Tj
T*
(B（比如一个磁盘文件）。A 和 B 的引用计数都等于 1。图 10-15 显示了调用 dup2\\\(4,1\\\) 之后的情况。两个描述符现在都指向文件 B；文件 A) Tj
T*
(已经被关闭了，并且它的文件表和 v-node 表表项也已经被删除了；文件 B 的引用计数已经增加了。从此以后，任何写到标准输出的数据都被重定向到文件 B。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 10-15 通过调用 dup2\\\(4,1\\\) 重定向标准输出之后的内核数据结构。初始状态如图 10-12 所示) Tj
T*
() Tj
T*
(旁注 - 左边和右边的 hoinkies) Tj
T*
() Tj
T*
() Tj
T*
(为了避免和其他括号类型操作符比如 “\\]” 和 “\\[” 相混淆，我们总是将 shell 的 “&gt;” 操作符称为 “右 hoinky”，而将 “&lt;” 操作符称为 “左) Tj
T*
(hoinky"。) Tj
T*
() Tj
T*
(练习题 10.4) Tj
T*
() Tj
T*
() Tj
T*
(如何用 dup2 将标准输入重定向到描述符 5？) Tj
T*
() Tj
T*
(重定向标准输入（描述符 0）到描述符 5，我们将调用 dup2\\\(5, 0\\\) 或者等价的 dup2\\\(5, STDIN\\_FILENO\\\)。) Tj
T*
() Tj
T*
(练习题 10.5) Tj
T*
() Tj
T*
() Tj
T*
(假设磁盘文件 foobar.txt 由 6 个 ASCII 码字符 “foobar” 组成，那么下列程序的输出是什么？) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int fd1, fd2;) Tj
T*
(        char c;) Tj
T*
() Tj
T*
(        fd1 = Open\("foobar.txt", O_RDONLY, 0\);) Tj
T*
(        fd2 = Open\("foobar.txt", O_RDONLY, 0\);) Tj
T*
(        Read\(fd2, &c, 1\);) Tj
T*
(        Dup2\(fd2, fd1\);) Tj
T*
(        Read\(fd1, &c, 1\);) Tj
T*
(        printf\("c = %c\\n", c\);) Tj
T*
ET
endstream
endobj
555 0 obj
<< /Length 2630 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(第一眼你可能会想输出应该是) Tj
T*
() Tj
T*
(c = f) Tj
T*
() Tj
T*
(但是因为我们将 fd1 重定向到了 fd2，输出实际上是) Tj
T*
() Tj
T*
(c = o) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(10.10 标准 I/O) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(10.10 标准 I/O) Tj
T*
() Tj
T*
() Tj
T*
(C 语言定义了一组高级输入输出函数，称为标准 I/O 库，为程序员提供了 Unix I/O 的较高级别的替代。这个库（libc）提供了打开和关闭文件的函数（fopen 和) Tj
T*
(fclose）、读和写字节的函数（fread 和 fwrite）、读和写字符串的函数（fgets 和 fputs），以及复杂的格式化的 I/O 函数（scanf 和) Tj
T*
(printf）。) Tj
T*
() Tj
T*
(标准 I/O 库将一个打开的文件模型化为一个流。对于程序员而言，一个流就是一个指向 FILE 类型的结构的指针。每个 ANSI C 程序开始时都有三个打开的流) Tj
T*
(stdin、stdout 和 stderr，分别对应于标准输入、标准输出和标准错误：) Tj
T*
() Tj
T*
(    #include <stdio.h>) Tj
T*
(    extern FILE *stdin;    /* Standard input \(descriptor 0\) */) Tj
T*
(    extern FILE *stdout;   /* Standard output \(descriptor 1\) */) Tj
T*
(    extern FILE *stderr;   /* Standard error \(descriptor 2\) */) Tj
T*
() Tj
T*
(类型为 FILE 的流是对文件描述符和流缓冲区的抽象。流缓冲区的目的和 RIO 读缓冲区的一样：就是使开销较高的 Linux I/O) Tj
T*
(系统调用的数量尽可能得小。例如，假设我们有一个程序，它反复调用标准 I/O 的 getc 函数，每次调用返回文件的下一个字符。当第一次调用 getc 时，库通过调用一次 read) Tj
T*
(函数来填充流缓冲区，然后将缓冲区中的第一个字节返回给应用程序。只要缓冲区中还有未读的字节，接下来对 getc 的调用就能直接从流缓冲区得到服务。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(10.11 综合：我该使用哪些 I/O 函数？) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(10.11 综合：我该使用哪些 I/O 函数？) Tj
T*
() Tj
T*
() Tj
T*
(图 10-16 总结了我们在这一章里讨论过的各种 I/O 包。) Tj
T*
() Tj
T*
([Image: &#x56FE; 10-16 Unix I/O&#x3001;&#x6807;&#x51C6; I/O &#x548C; RIO) Tj
T*
ET
endstream
endobj
556 0 obj
<< /Length 4580 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(&#x4E4B;&#x95F4;&#x7684;&#x5173;&#x7CFB;]) Tj
T*
() Tj
T*
(Unix I/O 模型是在操作系统内核中实现的。应用程序可以通过诸如 open、close、lseek、read、write 和 stat 这样的函数来访问) Tj
T*
(UnixI/O。较高级别的 RIO 和标准 I/O 函数都是基于（使用）Unix I/O 函数来实现的。RIO 函数是专为本书开发的 read 和 write) Tj
T*
(的健壮的包装函数。它们自动处理不足值，并且为读文本行提供一种高效的带缓冲的方法。标准 I/O 函数提供了 Unix I/O 函数的一个更加完整的带缓冲的替代品，包括格式化的 I/O) Tj
T*
(例程，如 printf 和 scanf。) Tj
T*
() Tj
T*
(那么，在你的程序中该使用这些函数中的哪一个呢？下面是一些基本的指导原则：) Tj
T*
() Tj
T*
(* G1：只要有可能就使用标准 I/O。对磁盘和终端设备 I/O 来说，标准 I/O 函数是首选方法。大多数 C 程序员在其整个职业生涯中只使用标准 I/O，从不受较低级的) Tj
T*
(UnixI/O 函数的困扰（可能 stat 除外，因为在标准 I/O 库中没有与它对应的函数）。只要可能，我们建议你也这样做。) Tj
T*
(* G2：不要使用 scanf 或 rio\\readlineb 来读二进制文件。像 scanf 或 rio\\read-lineb) Tj
T*
(这样的函数是专门设普来读取文本文件的。学生通常会犯的一个错误就是用这些函数来读取二进制文件，这就使得他们的程序出现了诡异莫测的失败。比如，二进制文件可能散布着很多 Oxa) Tj
T*
(字节，而这些字节又与终止文本行无关。) Tj
T*
(* G3：对网络套接字的 I/O 使用 RIO 函数。不幸的是，当我们试着将标准 I/O 用于网络的输入输出时，出现了一些令人讨厌的问题。如同我们将在 11.4 节所见，Linux) Tj
T*
(对网络的抽象是一种称为套接字的文件类型。就像所有的 Linux) Tj
T*
(文件一样，套接字由文件描述符来引用，在这种情况下称为套接字描述符。应用程序进程通过读写套接字描述符来与运行在其他计算机的进程实现通信。) Tj
T*
() Tj
T*
(标准 I/O 流，从某种意义上而言是全双工的，因为程序能够在同一个流上执行输入和输出。然而，对流的限制和对套接字的限制，有时候会互相冲突，而又极少有文档描述这些现象：) Tj
T*
() Tj
T*
(* 限制 1：跟在输出函数之后的输入函数。如果中间没有插入对 fflush、fseek、fsetpos 或者 rewind) Tj
T*
(的调用，一个输入函数不能跟随在一个输出函数之后。fflush 函数清空与流相关的缓冲区。后三个函数使用 Unix I/O lseek 函数来重置当前的文件位置。) Tj
T*
(* 限制 2：跟在输入函数之后的输出函数。如果中间没有插入对 fseek、fsetpos 或者 rewind) Tj
T*
(的调用，一个输出函数不能跟随在一个输入函数之后，除非该输入函数遇到了一个文件结束。) Tj
T*
() Tj
T*
(这些限制给网络应用带来了一个问题，因为对套接字使用 lseek 函数是非法的。对流 I/O) Tj
T*
(的第一个限制能够通过采用在每个输入操作前刷新缓冲区这样的规则来满足。然而，要满足第二个限制的唯一办法是，对同一个打开的套接字描述符打开两个流，一个用来读，一个用来写：) Tj
T*
() Tj
T*
(    FILE *fpin, *fpout;) Tj
T*
() Tj
T*
(    fpin = fdopen\(sockfd, "r"\);) Tj
T*
(    fpout = fdopen\(sockfd, "w"\);) Tj
T*
() Tj
T*
(但是这种方法也有问题，因为它要求应用程序在两个流上都要调用 fclose，这样才能释放与每个流相关联的内存资源，避免内存泄漏：) Tj
T*
() Tj
T*
(    fclose\(fpin\);) Tj
T*
(    fclose\(fpout\);) Tj
T*
() Tj
T*
(这些操作中的每一个都试图关闭同一个底层的套接字描述符，所以第二个 close) Tj
T*
(操作就会失败。对顺序的程序来说，这并不是问题，但是在一个线程化的程序中关闭一个已经关闭了的描述符是会导致灾难的（见 12.7.4 节）。) Tj
T*
() Tj
T*
(因此，我们建议你在网络套接字上不要使用标准 I/O 函数来进行输入和输出，而要使用健壮的 RIO 函数。如果你需要格式化的输出，使用 sprintf) Tj
T*
(函数在内存中格式化一个字符串，然后用 rio\\writen 把它发送到套接口。如果你需要格式化输入，使用 rio\\readlineb 来读一个完整的文本行，然后用 sscanf) Tj
T*
(从文本行提取不同的字段。) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
557 0 obj
<< /Length 2515 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(================================================================================) Tj
T*
(10.12 小结) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(10.12 小结) Tj
T*
() Tj
T*
() Tj
T*
(Linux 提供了少量的基于 Unix I/O 模型的系统级函数，它们允许应用程序打开、关闭、读和写文件，提取文件的元数据，以及执行 I/O 重定向。Linux) Tj
T*
(的读和写操作会出现不足值，应用程序必须能正确地预计和处理这种情况。应用程序不应直接调用 Unix I/O 函数，而应该使用 RIO 包，RIO) Tj
T*
(包通过反复执行读写操作，直到传送完所有的请求数据，自动处理不足值。) Tj
T*
() Tj
T*
(Linux 内核使用三个相关的数据结构来表示打开的文件。描述符表中的表项指向打开文件表中的表项，而打开文件表中的表项又指向 v-node) Tj
T*
(表中的表项。每个进程都有它自己单独的描述符表，而所有的进程共享同一个打开文件表和 v-node 表。理解这些结构的一般组成就能使我们清楚地理解文件共享和 I/O 重定向。) Tj
T*
() Tj
T*
(标准 I/O 库是基于 Unix I/O 实现的，并提供了一组强大的高级 I/O 例程。对于大多数应用程序而言，标准 I/O 更简单，是优于 Unix I/O) Tj
T*
(的选择。然而，因为对标准 I/O 和网络文件的一些相互不兼容的限制，Unix I/O 比之标准 I/O 更该适用于网络应用程序。) Tj
T*
() Tj
T*
(参考文献说明) Tj
T*
() Tj
T*
() Tj
T*
(Kerrisk 撰写了关于 Unix I/O 和 Linux 文件系统的综述【62】。Stevens 编写了 Unix I/O 的标准参考文献【111】。Kernighan 和) Tj
T*
(Ritchie 对于标准 I/O 函数给出了清晰而完整的讨论【61】。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(家庭作业) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(家庭作业) Tj
T*
() Tj
T*
() Tj
T*
(练习题 10.6) Tj
T*
() Tj
T*
() Tj
T*
(下面程序的输出是什么？) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int fd1, fd2;) Tj
T*
() Tj
T*
(        fd1 = Open\("foo.txt", O_RDONLY, 0\);) Tj
T*
(        fd2 = Open\("bar.txt", O_RDONLY, 0\);) Tj
T*
(        Close\(fd2\);) Tj
T*
(        fd2 = Open\("baz.txt", O_RDONLY, 0\);) Tj
T*
ET
endstream
endobj
558 0 obj
<< /Length 1968 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        printf\("fd2 = %d\\n", fd2\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(练习题 10.7) Tj
T*
() Tj
T*
() Tj
T*
(修改图 10-5 中所示的 cpfile 程序，使得它用 RIO 函数从标准输入复制到标准输出，一次 MAX-BUF 个字节。) Tj
T*
() Tj
T*
(练习题 10.8) Tj
T*
() Tj
T*
() Tj
T*
(编写图 10-10 中的 statcheck 程序的一个版本，叫做 fstatcheck，它从命令行上取得一个描述符数字而不是文件名。) Tj
T*
() Tj
T*
(练习题 10.9) Tj
T*
() Tj
T*
() Tj
T*
(考虑下面对作业题 10.8 中的 fstatcheck 程序的调用：) Tj
T*
() Tj
T*
(    linux> fstatcheck 3 < foo.txt) Tj
T*
() Tj
T*
(你可能会预想这个对 fstatcheck 的调用将提取和显示文件 foo.txt 的元数据。然而，当我们在系统上运行它时，它将失败，返回“坏的文件描述符”。根据这种情况，填写出) Tj
T*
(shell 在 fork 和 execve 调用之间必须执行的伪代码：) Tj
T*
() Tj
T*
(    if \(Fork\(\) == 0\) { /* child */) Tj
T*
(        /* What code is the shell executing right here? */) Tj
T*
(        Execve\("fstatcheck", argv, envp\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(练习题 10.10) Tj
T*
() Tj
T*
() Tj
T*
(修改图 10-5 中的 cpfile 程序，使得它有一个可选的命令行参数 infile。如果给定了 infile，那么复制 infile) Tj
T*
(到标准输出，否则像以前那样复制标准输入到标准输出。一个要求是对于两种情况，你的解答都必须使用原来的复制循环（第 9 ~ 11) Tj
T*
(行）。只允许你插入代码，而不允许更改任何已经存在的代码。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(第 11 章：网络编程) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(第 11 章：网络编程) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
559 0 obj
<< /Length 3743 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(网络应用随处可见。任何时候浏览 Web、发送 email) Tj
T*
(信息或是玩在线游戏，你就正在使用网络应用程序。有趣的是，所有的网络应用都是基于相同的基本编程模型，有着相似的整体逻辑结构，并且依赖相同的编程接口。) Tj
T*
() Tj
T*
(网络应用依赖于很多在系统研究中已经学习过的概念。例如，进程、信号、字节顺序、内存映射以及动态内存分配，都扮演着重要的角色。还有一些新概念要掌握。我们需要理解基本的客户端 -) Tj
T*
(服务器编程模型，以及如何编写使用因特网提供的服务的客户端—服务器程序。最后，我们将把所有这些概念结合起来，开发一个虽小但功能齐全的 Web 服务器，能够为真实的 Web) Tj
T*
(浏览器提供静态和动态的文本和图形内容。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(11.1 客户端—服务器编程模型) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(11.1 客户端—服务器编程模型) Tj
T*
() Tj
T*
() Tj
T*
(每个网络应用都是基于客户端—服务器模型的。釆用这个模型，一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务。) Tj
T*
(例如，一个 Web 服务器管理着一组磁盘文件，它会代表客户端进行检索和执行。一个 FTP) Tj
T*
(服务器管理着一组磁盘文件，它会为客户端进行存储和检索。相似地，一个电子邮件服务器管理着一些文件，它为客户端进行读和更新。) Tj
T*
() Tj
T*
(客户端—服务器模型中的基本操作是事务（transaction）（见图 11-1）。) Tj
T*
() Tj
T*
([Image: &#x56FE; 11-1) Tj
T*
(&#x4E00;&#x4E2A;&#x5BA2;&#x6237;&#x7AEF;&#x2014;&#x670D;&#x52A1;&#x5668;&#x4E8B;&#x52A1;]) Tj
T*
() Tj
T*
(一个客户端—服务器事务由以下四步组成。) Tj
T*
() Tj
T*
(1. 当一个客户端需要服务时，它向服务器发送一个请求，发起一个事务。例如，当 Web 浏览器需要一个文件时，它就发送一个请求给 Web 服务器。) Tj
T*
(2. 服务器收到请求后，解释它，并以适当的方式操作它的资源。例如，当 Web 服务器收到浏览器发出的请求后，它就读一个磁盘文件。) Tj
T*
(3. 服务器给客户端发送一个响应，并等待下一个请求。例如，Web 服务器将文件发送回客户端。) Tj
T*
(4. 客户端收到响应并处理它。例如，当 Web 浏览器收到来自服务器的一页后，就在屏幕上显示此页。) Tj
T*
() Tj
T*
(认识到客户端和服务器是进程，而不是常提到的机器或者主机，这是很重要的。一台主机可以同时运行许多不同的客户端和服务器，而且一个客户端和服务器的事务可以在同一台或是不同的主机上。无论客) Tj
T*
(户端和服务器是怎样映射到主机上的，客户端—服务器模型都是相同的。) Tj
T*
() Tj
T*
(客户端—服务器事务与数据库事务) Tj
T*
() Tj
T*
(客户端—服务器事务不是数据库事务，没有数据库事务的任何特性，例如原子性。在我们的上下文中，事务仅仅是客户端和服务器执行的一系列歩骤。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(11.2 网络) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(11.2 网络) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
560 0 obj
<< /Length 5005 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(客户端和服务器通常运行在不同的主机上，并且通过计算机网络的硬件和软件资源来通信。网络是很复杂的系统，在这里我们只想了解一点皮毛。我们的目标是从程序员的角度给你一个切实可行的思维模型) Tj
T*
(。) Tj
T*
() Tj
T*
(对主机而言，网络只是又一种 I/O 设备，是数据源和数据接收方，如图 11-2 所示。) Tj
T*
() Tj
T*
([Image: &#x56FE; 11-2) Tj
T*
(&#x4E00;&#x4E2A;&#x7F51;&#x7EDC;&#x4E3B;&#x673A;&#x7684;&#x786C;&#x4EF6;&#x7EC4;&#x6210;]) Tj
T*
() Tj
T*
(一个插到 I/O 总线扩展槽的适配器提供了到网络的物理接口。从网络上接收到的数据从适配器经过 I/O 和内存总线复制到内存，通常是通过 DMA) Tj
T*
(传送。相似地，数据也能从内存复制到网络。) Tj
T*
() Tj
T*
(物理上而言，网络是一个按照地理远近组成的层次系统。最低层是 LAN（Local Area) Tj
T*
(Network，局域网），在一个建筑或者校园范围内。迄今为止，最流行的局域网技术是以太网（Ethernet），它是由施乐公司帕洛阿尔托研究中心（Xerox PARC）在 20 世纪) Tj
T*
(70 年代中期提出的。以太网技术被证明是适应力极强的，从 3 Mb/s 演变到 10 Gb/s。) Tj
T*
() Tj
T*
(一个以太网段（Ethernet segment）包括一些电缆（通常是双绞线）和一个叫做集线器的小盒子，如图 11-3) Tj
T*
(所示。以太网段通常跨越一些小的区域，例如某建筑物的一个房间或者一个楼层。每根电缆都有相同的最大位带宽，通常是 100 Mb/s 或者 1 Gb/s。) Tj
T*
() Tj
T*
([Image: &#x56FE; 11-3 &#x4EE5;&#x592A;&#x7F51;&#x6BB5;]) Tj
T*
() Tj
T*
(一端连接到主机的适配器，而另一端则连接到集线器的一个端口上。集线器不加分辨地将从一个端口上收到的每个位复制到其他所有的端口上。因此，每台主机都能看到每个位。) Tj
T*
() Tj
T*
(每个以太网适配器都有一个全球唯一的 48 位地址，它存储在这个适配器的非易失性存储器上。一台主机可以发送一段位（称为帧（frame））到这个网段内的其他任何主机。每个帧包括一些固定) Tj
T*
(数量的头部（header）位，用来标识此帧的源和目的地址以及此帧的长度，此后紧随的就是数据位的有效载荷（payload）。每个主机适配器都能看到这个帧，但是只有目的主机实际读取它。) Tj
T*
() Tj
T*
(使用一些电缆和叫做网桥（bridge）的小盒子，多个以太网段可以连接成较大的局域网，称为桥接以太网（bridged Ethernet），如图 11-4 所示。桥接以太网能够跨越整个) Tj
T*
(建筑物或者校区。在一个桥接以太网里，一些电缆连接网桥与网桥，而另外一些连接网桥和集线器。这些电缆的带宽可以是不同的。在我们的示例中，网桥与网桥之间的电缆有 1 Gb/s) Tj
T*
(的带宽，而四根网桥和集线器之间电缆的带宽却是 100 Mb/s。) Tj
T*
() Tj
T*
([Image: &#x56FE; 11-4 &#x6865;&#x63A5;&#x4EE5;&#x592A;&#x7F51;]) Tj
T*
() Tj
T*
(网桥比集线器更充分地利用了电缆带宽。利用一种聪明的分配算法，它们随着时间自动学习哪个主机可以通过哪个端口可达，然后只在有必要时，有选择地将帧从一个端口复制到另一个端口。例如，如果主) Tj
T*
(机 A 发送一个帧到同网段上的主机 B，当该帧到达网桥 X 的输入端口时，X 就将丢弃此帧，因而节省了其他网段上的带宽。然而，如果主机 A 发送一个帧到一个不同网段上的主机) Tj
T*
(C，那么网桥 X 只会把此帧复制到和网桥 Y 相连的端口上，网桥 Y 会只把此帧复制到与主机 C 的网段连接的端口。) Tj
T*
() Tj
T*
(为了简化局域网的表示，我们将把集线器和网桥以及连接它们的电缆画成一根水平线，如图 11-5 所示。) Tj
T*
() Tj
T*
([Image: &#x56FE; 11-5 &#x5C40;&#x57DF;&#x7F51;&#x7684;&#x6982;&#x5FF5;&#x89C6;&#x56FE;]) Tj
T*
() Tj
T*
(在层次的更高级别中，多个不兼容的局域网可以通过叫做路由器（router）的特殊计算机连接起来，组成一个) Tj
T*
(internet（互联网络）。每台路由器对于它所连接到的每个网络都有一个适配器（端口）。路由器也能连接高速点到点电话连接，这是称为 WAN（Wide-Area) Tj
T*
(Network，广域网）的网络示例，之所以这么叫是因为它们覆盖的地理范围比局域网的大。一般而言，路由器可以用来由各种局域网和广域网构建互联网络。例如，图 11-6) Tj
T*
(展示了一个互联网络的示例，3 台路由器连接了一对局域网和一对广域网。) Tj
T*
() Tj
T*
([Image: &#x56FE; 11-6 &#x4E00;&#x4E2A;&#x5C0F;&#x578B;&#x7684;&#x4E92;&#x8054;&#x7F51;&#x7) Tj
T*
(EDC;&#x3002;&#x4E09;&#x53F0;&#x8DEF;&#x7531;&#x5668;&#x8FDE;&#x63A5;&#x8D77;&#x4E24;&#x4E2) Tj
T*
ET
endstream
endobj
561 0 obj
<< /Length 4336 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(A;&#x5C40;&#x57DF;&#x7F51;&#x548C;&#x4E24;&#x4E2A;&#x5E7F;&#x57DF;&#x7F51;]) Tj
T*
() Tj
T*
(旁注 - Internet 和 internet) Tj
T*
() Tj
T*
() Tj
T*
(我们总是用小写字母的 internet 描述一般概念，而用大写字母的 Internet 来描述一种具体的实现，也就是所谓的全球 IP 因特网。) Tj
T*
() Tj
T*
(互联网络至关重要的特性是，它能由采用完全不同和不兼容技术的各种局域网和广域网组成。每台主机和其他每台主机都是物理相连的，但是如何能够让某台源主机跨过所有这些不兼容的网络发送数据位到) Tj
T*
(另一台目的主机呢？) Tj
T*
() Tj
T*
(解决办法是一层运行在每台主机和路由器上的协议软件，它消除了不同网络之间的差异。这个软件实现一种协议，这种协议控制主机和路由器如何协同工作来实现数据传输。这种协议必须提供两种基本能力) Tj
T*
(：) Tj
T*
() Tj
T*
(* 命名机制。不同的局域网技术有不同和不兼容的方式来为主机分配地址。互联网络协议通过定义一种一致的主机地址格式消除了这些差异。每台主机会被分配至少一个这种互联网络地址（intern) Tj
T*
(etaddress），这个地址唯一地标识了这台主机。) Tj
T*
(* 传送机制。在电缆上编码位和将这些位封装成帧方面，不同的联网技术有不同的和不兼容的方式。互联网络协议通过定义一种把数据位捆扎成不连续的片（称为包）的统一方式，从而消除了这些差异。) Tj
T*
(一个包是由包头和有效载荷组成的，其中包头包括包的大小以及源主机和目的主机的地址，有效载荷包括从源主机发出的数据位。) Tj
T*
() Tj
T*
(图 11-7 展示了主机和路由器如何使用互联网络协议在不兼容的局域网间传送数据的一个示例。这个互联网络示例由两个局域网通过一台路由器连接而成。一个客户端运行在主机 A 上，主机 A) Tj
T*
(与 LAN1 相连，它发送一串数据字节到运行在主机 B 上的服务器端，主机 B 则连接在 LAN2 上。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 11-7 在互联网络上，数据是如何从一台主机传送到另一台主机的) Tj
T*
(>) Tj
T*
(> （PH：互联网络包头；FH1：LAN1 的帧头；FH2：LAN2 的帧头）) Tj
T*
() Tj
T*
(这个过程有 8 个基本步骤：) Tj
T*
() Tj
T*
(1. 运行在主机 A 上的客户端进行一个系统调用，从客户端的虚拟地址空间复制数据到内核缓冲区中。) Tj
T*
(2. 主机 A 上的协议软件通过在数据前附加互联网络包头和 LAN1 帧头，创建了一个 LAN1 的帧。互联网络包头寻址到互联网络主机 B。LAN1) Tj
T*
(帧头寻址到路由器。然后它传送此帧到适配器。注意，LAN1 帧的有效载荷是一个互联网络包，而互联网络包的有效载荷是实际的用户数据。这种封装是基本的网络互联方法之一。) Tj
T*
(3. LAN1 适配器复制该帧到网络上。) Tj
T*
(4. 当此帧到达路由器时，路由器的 LAN1 适配器从电缆上读取它，并把它传送到协议软件。) Tj
T*
(5. 路由器从互联网络包头中提取出目的互联网络地址，并用它作为路由表的索引，确定向哪里转发这个包，在本例中是 LAN2。路由器剥落旧的 LAN1 的帧头，加上寻址到主机 B 的新的) Tj
T*
(LAN2 帧头，并把得到的帧传送到适配器。) Tj
T*
(6. 路由器的 LAN2 适配器复制该帧到网络上。) Tj
T*
(7. 当此帧到达主机 B 时，它的适配器从电缆上读到此帧，并将它传送到协议软件。) Tj
T*
(8. 最后，主机 B 上的协议软件剥落包头和帧头。当服务器进行一个读取这些数据的系统调用时，协议软件最终将得到的数据复制到服务器的虚拟地址空间。) Tj
T*
() Tj
T*
(当然，在这里我们掩盖了许多很难的问题。如果不同的网络有不同帧大小的最大值，该怎么办呢？路由器如何知道该往哪里转发帧呢？当网络拓扑变化时，如何通知路由器？如果一个包丢失了又会如何呢？) Tj
T*
(虽然如此，我们的示例抓住了互联网络思想的精髓，封装是关键。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
562 0 obj
<< /Length 4010 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(================================================================================) Tj
T*
(11.3 全球 IP 因特网) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(11.3 全球 IP 因特网) Tj
T*
() Tj
T*
() Tj
T*
(全球 IP 因特网是最著名和最成功的互联网络实现。从 1969 年起，它就以这样或那样的形式存在了。虽然因特网的内部体系结构复杂而且不断变化，但是自从 20 世纪 80) Tj
T*
(年代早期以来，客户端 - 服务器应用的组织就一直保持着相当的稳定。图 11-8 展示了一个因特网客户端—服务器应用程序的基本硬件和软件组织。) Tj
T*
() Tj
T*
([Image: &#x56FE; 11-8 &#x4E00;&#x4E2A;&#x56E0;&#x7279;&#x7F51;&#x5E94;&#x7528;&#x7A0B;&#x5) Tj
T*
(E8F;&#x7684;&#x786C;&#x4EF6;&#x548C;&#x8F6F;&#x4EF6;&#x7EC4;&#x7EC7;]) Tj
T*
() Tj
T*
(每台因特网主机都运行实现 TCP/IP 协议（Transmission Control Protocol / Internet) Tj
T*
(Protocol，传输控制协议/互联网络协议）的软件，几乎每个现代计算机系统都支持这个协议。因特网的客户端和服务器混合使用套接字接口函数和 Unix I/O) Tj
T*
(函数来进行通信（我们将在 11.4 节中介绍套接字接口）。通常将套接字函数实现为系统调用，这些系统调用会陷入内核，并调用各种内核模式的 TCP/IP 函数。) Tj
T*
() Tj
T*
(TCP/IP 实际是一个协议族，其中每一个都提供不同的功能。例如，IP) Tj
T*
(协议提供基本的命名方法和递送机制，这种递送机制能够从一台因特网主机往其他主机发送包，也叫做数据报（datagram）。IP) Tj
T*
(机制从某种意义上而言是不可靠的，因为，如果数据报在网络中丢失或者重复，它并不会试图恢复。UDP（Unreliable Datagram) Tj
T*
(Protocol，不可靠数据报协议）稍微扩展了 IP 协议，这样一来，包可以在进程间而不是在主机间传送。TCP 是一个构建在 IP) Tj
T*
(之上的复杂协议，提供了进程间可靠的全双工（双向的）连接。为了简化讨论，我们将 TCP/IP 看做是一个单独的整体协议。我们将不讨论它的内部工作，只讨论 TCP 和 IP) Tj
T*
(为应用程序提供的某些基本功能。我们将不讨论 UDP。) Tj
T*
() Tj
T*
(从程序员的角度，我们可以把因特网看做一个世界范围的主机集合，满足以下特性：) Tj
T*
() Tj
T*
(* 主机集合被映射为一组 32 位的 IP 地址。) Tj
T*
(* 这组 IP 地址被映射为一组称为因特网域名（Internet domain name）的标识符。) Tj
T*
(* 因特网主机上的进程能够通过连接（connection）和任何其他因特网主机上的进程通信。) Tj
T*
() Tj
T*
(接下来三节将更详细地讨论这些基本的因特网概念。) Tj
T*
() Tj
T*
(旁注 - IPv4 和 IPv6) Tj
T*
() Tj
T*
() Tj
T*
(最初的因特网协议，使用 32 位地址，称为因特网协议版本 4（Internet Protocol Version 4，IPv4）01996 年，因特网工程任务组织（Internet) Tj
T*
(Engineering Task Force，IETF）提出了一个新版本的 IP，称为因特网协议版本 6（IPv6），它使用的是 128 位地址，意在替代 IPv4。但是直到) Tj
T*
(2015 年，大约 20 年后，因特网流量的绝大部分还是由 IPv4 网络承载的。例如，只有 4% 的访问 Google 服务的用户使用 IPv6【42】。) Tj
T*
() Tj
T*
(因为 IPv6 的使用率较低，本书不会讨论 IPv6 的细节，而只是集中注意力于 IPv4 背后的概念。当我们谈论因特网时，我们指的是基于 IPv4) Tj
T*
(的因特网。但是，本章后面介绍的书写客户端和服务器的技术是基于现代接口的，与任何特殊的协议无关。) Tj
T*
() Tj
T*
(11.3.1 IP 地址) Tj
T*
() Tj
T*
() Tj
T*
(一个 IP 地址就是一个 32 位无符号整数。网络程序将 IP 地址存放在如图 11-9 所示的 IP 地址结构中。) Tj
T*
ET
endstream
endobj
563 0 obj
<< /Length 2943 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(    /* IP address structure */) Tj
T*
(    struct in_addr {) Tj
T*
(        uint32_t s_addr; /* Address in network byte order \(big-endian\) */) Tj
T*
(    };) Tj
T*
() Tj
T*
(> 图 11-9 IP 地址结构) Tj
T*
() Tj
T*
(把一个标量地址存放在结构中，是套接字接口早期实现的不幸产物。为 IP 地址定义一个标量类型应该更有意义，但是现在更改已经太迟了，因为已经有大量应用是基于此的。) Tj
T*
() Tj
T*
(因为因特网主机可以有不同的主机字节顺序，TCP/IP 为任意整数数据项定义了统一的网络字节顺序（network byte order）（大端字节顺序），例如 IP) Tj
T*
(地址，它放在包头中跨过网络被携带。在 IP 地址结构中存放的地址总是以（大端法）网络字节顺序存放的，即使主机字节顺序（host byte order）是小端法。Unix) Tj
T*
(提供了下面这样的函数在网络和主机字节顺序间实现转换。) Tj
T*
() Tj
T*
(    #include <arpa/inet.h>) Tj
T*
() Tj
T*
(    uint32_t htonl\(uint32_t hostlong\);) Tj
T*
(    uint16_t htons\(uint16_t hostshort\);) Tj
T*
(    // 返回：按照网络字节顺序的值。) Tj
T*
() Tj
T*
(    uint32_t ntohl\(uint32_t netlong\);) Tj
T*
(    uint16_t ntohs\(unit16_t netshort\);) Tj
T*
(    // 返回：按照主机字节顺序的值。) Tj
T*
() Tj
T*
(hotnl 函数将 32 位整数由主机字节顺序转换为网络字节顺序。ntohl 函数将 32 位整数从网络字节顺序转换为主机字节。htons 和 ntohs 函数为 16) Tj
T*
(位无符号整数执行相应的转换。注意，没有对应的处理 64 位值的函数。) Tj
T*
() Tj
T*
(IP 地址通常是以一种称为点分十进制表示法来表示的，这里，每个字节由它的十进制值表示，并且用句点和其他字节间分开。例如，128.2.194.242 就是地址 0x8002c2f2) Tj
T*
(的点分十进制表示。在 Linux 系统上，你能够使用 HOSTNAME 命令来确定你自己主机的点分十进制地址：) Tj
T*
() Tj
T*
(    linux> hostname -i) Tj
T*
(    128.2.210.175) Tj
T*
() Tj
T*
(应用程序使用 inet\\pton 和 inet\\ntop 函数来实现 IP 地址和点分十进制串之间的转换。) Tj
T*
() Tj
T*
(    #include <arpa/inet.h>) Tj
T*
() Tj
T*
(    int inet_pton\(AF_INET, const char *src, void *dst\);) Tj
T*
(    // 返回：若成功则为 1，若 src 为非法点分十进制地址则为 0，若出错则为 -1。) Tj
T*
() Tj
T*
(    const char *inet_ntop\(AF_INET, const void *src, char *dst,) Tj
T*
(    socklen_t size\);) Tj
T*
(    // 返回：若成功则指向点分十进制字符串的指针，若出错则为 NULL。) Tj
T*
() Tj
T*
(在这些函数名中，“n” 代表网络，“p” 代表表示。它们可以处理 32 位 IPv4 地址（AF\\INET）（就像这里展示的那样），或者 128 位 IPv6) Tj
T*
(地址（AF\\INET6）（这部分我们不讲）。) Tj
T*
ET
endstream
endobj
564 0 obj
<< /Length 1878 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(inet\\pton 函数将一个点分十进制串（src）转换为一个二进制的网络字节顺序的 IP 地址（dst）o 如果 src 没有指向一个合法的点分十进制字符串，那么该函数就返回) Tj
T*
(0。任何其他错误会返回 -1，并设置 errno。相似地，inet\\ntop 函数将一个二进制的网络字节顺序的 IP 地址（src）转换为它所对应的点分十进制表示，并把得到的以) Tj
T*
(null 结尾的字符串的最多 size 个字节复制到 dst。) Tj
T*
() Tj
T*
(练习题 11.1) Tj
T*
() Tj
T*
() Tj
T*
(完成下表：) Tj
T*
() Tj
T*
(| 十六进制地址 | 点分十进制地址 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| 0x0 |  |) Tj
T*
(| 0xffffffff |  |) Tj
T*
(| 0x7f000001 |  |) Tj
T*
(|  | 205.188.160.121 |) Tj
T*
(|  | 64.12.149.13 |) Tj
T*
(|  | 205.188.146.23 |) Tj
T*
() Tj
T*
(| 十六进制地址 | 点分十进制地址 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| 0x0 | 0.0.0.0 |) Tj
T*
(| 0xffffffff | 255.255.255.255 |) Tj
T*
(| 0x7f000001 | 127.0.0.1 |) Tj
T*
(| 0xcdbca079 | 205.188.160.121 |) Tj
T*
(| 0x400c950d | 64.12.149.13 |) Tj
T*
(| 0xcdbc9217 | 205.188,146.23 |) Tj
T*
() Tj
T*
(练习题 11.2) Tj
T*
() Tj
T*
() Tj
T*
(编写程序 hex2dd.c，将它的十六进制参数转换为点分十进制串并打印出结果。例如) Tj
T*
() Tj
T*
(    linux> ./hex2dd 0x8002c2f2) Tj
T*
(    128.2.194.242) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(int argc, char**argv\)) Tj
T*
(    {) Tj
T*
(        struct in_addr inaddr;  /* Address in network byte order */) Tj
T*
(        uint32_t addr;          /* Address in host byte order */) Tj
T*
(        char buf[MAXBUF];       /* Buffer for dotted-decimal string */) Tj
T*
() Tj
T*
(        if \(argc != 2\) {) Tj
T*
(            fprintf\(stderr, "usage: %s <hex number>\\n", argv[0]\);) Tj
T*
ET
endstream
endobj
565 0 obj
<< /Length 2002 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            exit\(0\);) Tj
T*
(        }) Tj
T*
(        sscanf\(argv[1], "%x", &addr\);) Tj
T*
(        inaddr.s_addr = htonl\(addr\);) Tj
T*
() Tj
T*
(        if \(!inet_ntop\(AF_INET, &inaddr, buf, MAXBUF\)\)) Tj
T*
(            unix_error\("inet_ntop" \);) Tj
T*
(        printf\("%s\\n", buf\);) Tj
T*
() Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(练习题 11.3) Tj
T*
() Tj
T*
() Tj
T*
(编写程序 dd2hex.c，将它的点分十进制参数转换为十六进制数并打印出结果。例如) Tj
T*
() Tj
T*
(    linux> ./dd2hex 128.2.194.242) Tj
T*
(    0x8002c2f2) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        struct in_addr inaddr;/* Address in network byte order */) Tj
T*
(        int rc;) Tj
T*
() Tj
T*
(        if \(argc != 2\) {) Tj
T*
(            fprintf\(stderr, "usage: %s <dotted-decimal>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        rc = inet_pton\(AF_INET, argv[1], &inaddr\);) Tj
T*
(        if \(rc == 0\)) Tj
T*
(            app_error\("inet_pton error: invalid dotted-decimal address"\);) Tj
T*
(        else if \(rc < 0\)) Tj
T*
(            unix_error\("inet_pton error" \);) Tj
T*
() Tj
T*
(        printf\("0x%x\\n", ntohl\(inaddr.s_addr\)\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(因特网客户端和服务器互相通信时使用的是 IP 地址。然而，对于人们而言，大整数是很难记住的，所以因特网也定义了一组更加人性化的域名（domain name），以及一种将域名映射到) Tj
T*
(IP 地址的机制。域名是一串用句点分隔的单词（字母、数字和破折号），例如 whaleshark.ics.cs.emu.edu。) Tj
T*
() Tj
T*
(域名集合形成了一个层次结构，每个域名编码了它在这个层次中的位置。通过一个示例你将很容易理解这点。图 11-10 展示了域名层次结构的一部分。) Tj
T*
ET
endstream
endobj
566 0 obj
<< /Length 3043 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
([Image: &#x56FE; 11-10 &#x56E0;&#x7279;&#x7F51;&#x57DF;&#x540D;&#x5C42;&#x6B21;&#x7ED3;&#x) Tj
T*
(6784;&#x7684;&#x4E00;&#x90E8;&#x5206;]) Tj
T*
() Tj
T*
(层次结构可以表示为一棵树。树的节点表示域名，反向到根的路径形成了域名。子树称为子域（subdomain）。层次结构中的第一层是一个未命名的根节点。下一层是一组一级域名（first-) Tj
T*
(level domain name），由非营利组织 ICANN（Internet Corporation for Assigned Namesand) Tj
T*
(Numbers，因特网分配名字数字协会）定义。常见的第一层域名包括 com、edu、gov、org 和 net。) Tj
T*
() Tj
T*
(下一层是二级（second-level）域名，例如 cmu.edu，这些域名是由 ICANN) Tj
T*
(的各个授权代理按照先到先服务的基础分配的。一旦一个组织得到了一个二级域名，那么它就可以在这个子域中创建任何新的域名了，例如 cs.cmu.edu。) Tj
T*
() Tj
T*
(因特网定义了域名集合和 IP 地址集合之间的映射。直到 1988 年，这个映射都是通过一个叫做 HOSTS.TXT) Tj
T*
(的文本文件来手工维护的。从那以后，这个映射是通过分布世界范围内的数据库（称为 DNS（Domain Name System，域名系统））来维护的。从概念上而言，DNS) Tj
T*
(数据库由上百万的主机条目结构（host entry structure）组成，其中每条定义了一组域名和一组 IP 地址之间的映射。从数学意义上讲，可以认为每条主机条目就是一个域名和) Tj
T*
(IP 地址的等价类。我们可以用 Linux 的 NSLOOKUP 程序来探究 DNS 映射的一些属性，这个程序能展示与某个 IP 地址对应的域名。✦) Tj
T*
() Tj
T*
(✦：我们重新调整了 NSLOOKUP 的输出以提高可读性。) Tj
T*
() Tj
T*
(每台因特网主机都有本地定义的域名 localhost，这个域名总是映射为回送地址（loopback address）127.0.0.1：) Tj
T*
() Tj
T*
(    linux> nslookup localhost) Tj
T*
(    Address: 127.0.0.1) Tj
T*
() Tj
T*
(localhost 字为引用运行在同一台机器上的客户端和服务器提供了一种便利和可移植的方式，这对调试相当有用。我们可以使用 HOSTNAME 来确定本地主机的实际域名：) Tj
T*
() Tj
T*
(    linux> hostname) Tj
T*
(    whaleshark.ics.cs.cmu.edu) Tj
T*
() Tj
T*
(在最简单的情况中，一个域名和一个 IP 地址之间是一一映射：) Tj
T*
() Tj
T*
(    linux> nslookup whaleshark.ics.cs.cmu.edu) Tj
T*
(    Address: 128.2.210.175) Tj
T*
() Tj
T*
(然而，在某些情况下，多个域名可以映射为同一个 IP 地址：) Tj
T*
() Tj
T*
(    linux> nslookup cs.mit.edu) Tj
T*
(    Address: 18.62.1.6) Tj
T*
() Tj
T*
(    linux> nslookup eecs.mit.edu) Tj
T*
(    Address: 18.62.1.6) Tj
T*
() Tj
T*
(在最通常的情况下，多个域名可以映射到同一组的多个 IP 地址：) Tj
T*
() Tj
T*
(    linux> nslookup www.twitter.com) Tj
T*
(    Address: 199.16.156.6) Tj
T*
(    Address: 199.16.156.70) Tj
T*
ET
endstream
endobj
567 0 obj
<< /Length 3217 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    Address: 199.16.156.102) Tj
T*
(    Address: 199.16.156.230) Tj
T*
() Tj
T*
(    linux> nslookup twitter.com) Tj
T*
(    Address: 199.16.156.102) Tj
T*
(    Address: 199.16.156.230) Tj
T*
(    Address: 199.16.156.6) Tj
T*
(    Address: 199.16.156.70) Tj
T*
() Tj
T*
(最后，我们注意到某些合法的域名没有映射到任何 IP 地址：) Tj
T*
() Tj
T*
(    linux> nslookup edu) Tj
T*
(    *** Can’t find edu: No answer) Tj
T*
() Tj
T*
(    linux> nslookup ics.cs.cmu.edu) Tj
T*
(    *** Can’t find ics.cs.cmu.edu: No answer) Tj
T*
() Tj
T*
(旁注 - 有多少因特网主机？) Tj
T*
() Tj
T*
(因特网软件协会（Internet Software Consortium，www.isc.org）自从 1987) Tj
T*
(年以后，每年进行两次因特网域名调查。这个调查通过计算已经分配给一个域名的 IP 地址的数量来估算因特网主机的数量，展示了一种令人吃惊的趋势。自从 1987 年以来，当时一共大约有) Tj
T*
(20 000 台因特网主机，主机的数量已经在指数性增长。到 2015 年，已经有大约  1000 000 000 台因特网主机了。) Tj
T*
() Tj
T*
(11.3.3 因特网连接) Tj
T*
() Tj
T*
(因特网客户端和服务器通过在连接上发送和接收字节流来通信。从连接一对进程的意义上而言，连接是点对点的。从数据可以同时双向流动的角度来说，它是全双工的。并且从（除了一些如粗心的耕锄机操) Tj
T*
(作员切断了电缆引起灾难性的失败以外）由源进程发出的字节流最终被目的进程以它发出的顺序收到它的角度来说，它也是可靠的。) Tj
T*
() Tj
T*
(一个套接字是连接的一个端点。每个套接字都有相应的套接字地址，是由一个因特网地址和一个 16 位的整数✦端口✦组成的，用“地址：端口”来表示。) Tj
T*
() Tj
T*
(✦端口✦：这些软件端口与网络中交换机和路由器的硬件端口没有关系。) Tj
T*
() Tj
T*
(当客户端发起一个连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为临时端口（ephemeral) Tj
T*
(port）.然而，服务器套接字地址中的端口通常是某个知名端口，是和这个服务相对应的。例如，Web 服务器通常使用端口 80，而电子邮件服务器使用端口) Tj
T*
(25。每个具有知名端口的服务都有一个对应的知名的服务名。例如，Web 服务的知名名字是 http，email 的知名名字是 smtp。文件 /etc/services) Tj
T*
(包含一张这台机器提供的知名名字和知名端口之间的映射。) Tj
T*
() Tj
T*
(一个连接是由它两端的套接字地址唯一确定的。这对套接字地址叫做套接字对（socket pair），由下列元组来表示：) Tj
T*
() Tj
T*
(\\\(cliaddr:cliport, servaddr:servport\\\)) Tj
T*
() Tj
T*
(其中 cliaddr 是客户端的 IP 地址，cliport 是客户端的端口，servaddr 是服务器的 IP 地址，而 servport 是服务器的端口。例如，图 11-11) Tj
T*
(展示了一个 Web 客户端和一个 Web 服务器之间的连接。) Tj
T*
() Tj
T*
([Image: &#x56FE; 11-11 &#x56E0;&#x7279;&#x7F51;&#x8FDE;&#x63A5;&#x5206;&#x6790;]) Tj
T*
() Tj
T*
ET
endstream
endobj
568 0 obj
<< /Length 3553 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(在这个示例中，Web 客户端的套接字地址是) Tj
T*
() Tj
T*
(128.2.194.242:51213) Tj
T*
() Tj
T*
(其中端口号 51213 是内核分配的临时端口号。Web 服务器的套接字地址是) Tj
T*
() Tj
T*
(208.216.181.15:80) Tj
T*
() Tj
T*
(其中端口号 80 是和 Web 服务相关联的知名端口号。给定这些客户端和服务器套接字地址，客户端和服务器之间的连接就由下列套接字对唯一确定了：) Tj
T*
() Tj
T*
(\\\(128.2.194.242:51213, 208.216.181.15:80\\\)) Tj
T*
() Tj
T*
(旁注 - 因特网的起源) Tj
T*
() Tj
T*
() Tj
T*
(因特网是政府、学校和工业界合作的最成功的示例之一。它成功的因素很多，但是我们认为有两点尤其重要：美国政府 30 年持续不变的投资，以及充满激情的研究人员对麻省理工学院的 Dave) Tj
T*
(Clarke 提出的“粗略一致和能用的代码”的投入。) Tj
T*
() Tj
T*
(因特网的种子是在 1957 年播下的，其时正值冷战的高峰，苏联发射) Tj
T*
(Sputnik，第一颗人造地球卫星，震惊了世界。作为响应，美国政府创建了高级研究计划署（ARPA），其任务就是重建美国在科学与技术上的领导地位。1967 年，ARPA 的) Tj
T*
(Lawrence Roberts 提出了一个计划，建立一个叫做 ARPANET 的新网络。第一个 ARPANET 节点是在 1969 年建立并运行的。到 1971 年，已有 13) Tj
T*
(个 ARPANET 节点，而且 email 作为第一个重要的网络应用涌现出来。) Tj
T*
() Tj
T*
(1972 年，Robert Kahn 概括了网络互联的一般原则：一组互相连接的网络，通过叫做“路由器”的黑盒子按照“以尽力传送作为基础”在互相独立处理的网络间实现通信。1974) Tj
T*
(年，Kahn 和 Vinton Cerf 发表了 TCP/IP 协议的第一本详细资料，到 1982 年它成为了 ARPANET 的标准网络互联协议。1983 年 1 月 1) Tj
T*
(日，ARPANET 的每个节点都切换到 TCP/IP，标志着全球 IP 因特网的诞生。) Tj
T*
() Tj
T*
(1985 年，Paul Mockapetris 发明了 DNS，有 1000 多台因特网主机。1986 年，国家科学基金会（NSF）用 56 KB/s 的电话线连接了 13) Tj
T*
(个节点，构建了 NSFNET 的骨干网。其后在 1988 年升级到 1.5 MB/s T1 的连接速率，1991 年为 45 MB/s T3 的连接速率。到 1988 年，有超过) Tj
T*
(50 000 台主机。1989 年，原始的 ARPANET 正式退休了。1995 年，已经有几乎 10 000 000 台因特网主机了，NSF 取消了) Tj
T*
(NSFNET，并且用基于由公众网络接入点连接的私有商业骨干网的现代因特网架构取代了它。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(11.4 套接字接口) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(11.4 套接字接口) Tj
T*
() Tj
T*
() Tj
T*
(套接字接口（socket interface）是一组函数，它们和 Unix I/O 函数结合起来，用以创建网络应用。大多数现代系统上都实现套接字接口，包括所有的 Unix) Tj
T*
(变种、Windows 和 Macintosh 系统。图 11-12 给岀了一个典型的客户端—服务器事务的上下文中的套接字接口概述。当讨论各个函数时，你可以使用这张图来作为向导图。) Tj
T*
() Tj
T*
([Image: &#x56FE; 11-12 &#x57FA;&#x4E8E;&#x5957;&#x63A5;&#x5B57;&#x63A5;&#x53E3;&#x7684;&#x) Tj
T*
(7F51;&#x7EDC;&#x5E94;&#x7528;&#x6982;&#x8FF0;]) Tj
T*
() Tj
T*
ET
endstream
endobj
569 0 obj
<< /Length 3119 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(旁注 - 套接字接口的起源) Tj
T*
() Tj
T*
() Tj
T*
(套接字接口是加州大学伯克利分校的研究人员在 20 世纪 80) Tj
T*
(年代早期提出的。因为这个原因，它也经常被叫做伯克利套接字。伯克利的研究者使得套接字接口适用于任何底层的协议。第一个实现的就是针对 TCP/IP 协议的，他们把它包括在 Unix) Tj
T*
(4.2 BSD 的内核里，并且分发给许多学校和实验室。这在因特网的历史上是一个重大事件。几乎一夜之间，成千上万的人们接触到了 TCP/IP) Tj
T*
(和它的源代码。它引起了巨大的轰动，并激发了新的网络和网络互联研究的浪潮。) Tj
T*
() Tj
T*
(11.4.1 套接字地址结构) Tj
T*
() Tj
T*
() Tj
T*
(从 Linux 内核的角度来看，一个套接字就是通信的一个端点。从 Linux 程序的角度来看，套接字就是一个有相应描述符的打开文件。) Tj
T*
() Tj
T*
(因特网的套接字地址存放在如图 11-13 所示的类型为 sockaddr\\in 的 16 字节结构中。对于因特网应用，sin\\family 成员是 AF\\INET，sin\\port) Tj
T*
(成员是一个 16 位的端口号，而 sin\\_addr 成员就是一个 32 位的 IP 地址。IP 地址和端口号总是以网络字节顺序（大端法）存放的。) Tj
T*
() Tj
T*
(    /* IP socket address structure */) Tj
T*
(    struct sockaddr_in {) Tj
T*
(        uint16_t       sin_family;   /* Protocol family \(always AF_INET\) */) Tj
T*
(        uint16_t       sin_port;     /* Port number in network byte order */) Tj
T*
(        struct in_addr sin_addr;     /* IP address in network byte order */) Tj
T*
(        unsigned char  sin_zero[8];  /* Pad to sizeof\(struct sockaddr\) */) Tj
T*
(    };) Tj
T*
() Tj
T*
(    /* Generic socket address structure \(for connect, bind, and accept\) */) Tj
T*
(    struct sockaddr {) Tj
T*
(        uint16_t  sa_family;    /* Protocol family */) Tj
T*
(        char      sa_data[14];  /* Address data */) Tj
T*
(    };) Tj
T*
() Tj
T*
(> 图 11-13 套接字地址结构) Tj
T*
() Tj
T*
(旁注 - \\_in后缀意味着什么？) Tj
T*
() Tj
T*
() Tj
T*
(in 后缀是互联网络（internet）的缩写，而不是输入（input）的缩写。) Tj
T*
() Tj
T*
(connect、bind 和 accept) Tj
T*
(函数要求一个指向与协议相关的套接字地址结构的指针。套接字接口的设计者面临的问题是，如何定义这些函数，使之能接受各种类型的套接字地址结构。今天我们可以使用通用的 void\\*) Tj
T*
(指针，但是那时在 C 中并不存在这种类型的指针。解决办法是定义套接字函数要求一个指向通用 sockaddr 结构（图) Tj
T*
(11-13）的指针，然后要求应用程序将与协议特定的结构的指针强制转换成这个通用结构。为了简化代码示例，我们跟随 Steven 的指导，定义下面的类型：) Tj
T*
() Tj
T*
(    typedef struct sockaddr SA;) Tj
T*
() Tj
T*
(然后无论何时需要将 sockaddr\\_in 结构强制转换成通用 sockaddr 结构时，我们都使用这个类型。) Tj
T*
() Tj
T*
ET
endstream
endobj
570 0 obj
<< /Length 2477 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(11.4.2 socket 函数) Tj
T*
() Tj
T*
() Tj
T*
(客户端和服务器使用 socket 函数来创建一个套接字描述符（socket descriptor）。) Tj
T*
() Tj
T*
(    #include <sys/types.h>) Tj
T*
(    #include <sys/socket.h>) Tj
T*
() Tj
T*
(    int socket\(int domain, int type, int protocol\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为非负描述符，若出错则为 -1。) Tj
T*
() Tj
T*
(如果想要使套接字成为连接的一个端点，就用如下硬编码的参数来调用 socket 函数：) Tj
T*
() Tj
T*
(    clientfd = Socket\(AF_INET, SOCK_STREAM, 0\);) Tj
T*
() Tj
T*
(其中，AF\\INET 表明我们正在使用 32 位 IP 地址，而 SOCK\\STREAM 表示这个套接字是连接的一个端点。不过最好的方法是用 getaddrinfo) Tj
T*
(函数（11.4.7 节）来自动生成这些参数，这样代码就与协议无关了。我们会在 11.4.8 节中向你展示如何配合 socket 函数来使用 getaddrinfo。) Tj
T*
() Tj
T*
(socket 返回的 clientfd) Tj
T*
(描述符仅是部分打开的，还不能用于读写。如何完成打开套接字的工作，取决于我们是客户端还是服务器。下一节描述当我们是客户端时如何完成打开套接字的工作。) Tj
T*
() Tj
T*
(11.4.3 connect 函数) Tj
T*
() Tj
T*
() Tj
T*
(客户端通过调用 connect 函数来建立和服务器的连接。) Tj
T*
() Tj
T*
(    #include <sys/socket.h>) Tj
T*
() Tj
T*
(    int connect\(int clientfd, const struct sockaddr *addr,) Tj
T*
(                socklen_t addrlen\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为 0，若出错则为 -1。) Tj
T*
() Tj
T*
(connect 函数试图与套接字地址为 addr 的服务器建立一个因特网连接，其中 addrlen 是 sizeof\\\(sockaddr\\_in\\\)。connect) Tj
T*
(函数会阻塞，一直到连接成功建立或是发生错误。如果成功，clientfd 描述符现在就准备好可以读写了，并且得到的连接是由套接字对) Tj
T*
() Tj
T*
(\\\(x:y, addr.sin\\addr:addr.sin\\port\\\)) Tj
T*
() Tj
T*
(刻画的，其中 x 表示客户端的 IP 地址，而 y 表示临时端口，它唯一地确定了客户端主机上的客户端进程。对于 socket，最好的方法是用 getaddrinfo 来为) Tj
T*
(connect 提供参数（见 11.4.8 节）。) Tj
T*
() Tj
T*
(11.4.4 bind 函数) Tj
T*
() Tj
T*
() Tj
T*
(剩下的套接字函数——bind、listen 和 accept，服务器用它们来和客户端建立连接。) Tj
T*
ET
endstream
endobj
571 0 obj
<< /Length 2865 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(    #include <sys/socket.h>) Tj
T*
() Tj
T*
(    int bind\(int sockfd, const struct sockaddr *addr,) Tj
T*
(             socklen_t addrlen\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为 0，若出错则为 -1。) Tj
T*
() Tj
T*
(bind 函数告诉内核将 addr 中的服务器套接字地址和套接字描述符 sockfd 联系起来。参数 addrlen 就是 sizeof\\\(sockaddr\\_in\\\)。对于) Tj
T*
(socket 和 connect，最好的方法是用 getaddrinfo 来为 bind 提供参数（见 11.4.8 节）。) Tj
T*
() Tj
T*
(11.4.5 listen 函数) Tj
T*
() Tj
T*
() Tj
T*
(客户端是发起连接请求的主动实体。服务器是等待来自客户端的连接请求的被动实体。默认情况下，内核会认为 socket 函数创建的描述符对应于主动套接字（active) Tj
T*
(socket），它存在于一个连接的客户端。服务器调用 listen 函数告诉内核，描述符是被服务器而不是客户端使用的。) Tj
T*
() Tj
T*
(    #include <sys/socket.h>) Tj
T*
() Tj
T*
(    int listen\(int sockfd, int backlog\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为 0，若出错则为 -1。) Tj
T*
() Tj
T*
(listen 函数将 sockfd 从一个主动套接字转化为一个监听套接字（listening socket），该套接字可以接受来自客户端的连接请求。backlog) Tj
T*
(参数暗示了内核在开始拒绝连接请求之前，队列中要排队的未完成的连接请求的数量。backlog 参数的确切含义要求对 TCP/IP) Tj
T*
(协议的理解，这超出了我们讨论的范围。通常我们会把它设置为一个较大的值，比如 1024。) Tj
T*
() Tj
T*
(11.4.6 accept 函数) Tj
T*
() Tj
T*
() Tj
T*
(服务器通过调用 accept 函数来等待来自客户端的连接请求。) Tj
T*
() Tj
T*
(    #include <sys/socket.h>) Tj
T*
() Tj
T*
(    int accept\(int listenfd, struct sockaddr *addr, int *addrlen\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为非负连接描述符，若出错则为 -1。) Tj
T*
() Tj
T*
(accept 函数等待来自客户端的连接请求到达侦听描述符 listenfd，然后在 addr 中填写客户端的套接字地址，并返回一个已连接描述符（connected) Tj
T*
(descriptor），这个描述符可被用来利用 Unix I/O 函数与客户端通信。) Tj
T*
() Tj
T*
(监听描述符和已连接描述符之间的区别使很多人感到迷惑。监听描述符是作为客户端连接请求的一个端点。它通常被创建一次，并存在于服务器的整个生命周期。已连接描述符是客户端和服务器之间已经建) Tj
T*
(立起来了的连接的一个端点。服务器每次接受连接请求时都会创建一次，它只存在于服务器为一个客户端服务的过程中。) Tj
T*
() Tj
T*
(图 11-14 描绘了监听描述符和已连接描述符的角色。) Tj
T*
() Tj
T*
ET
endstream
endobj
572 0 obj
<< /Length 3174 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
([Image: &#x56FE; 11-14 &#x76D1;&#x542C;&#x63CF;&#x8FF0;&#x7B26;&#x548C;&#x5DF2;&#x8FDE;&#x) Tj
T*
(63A5;&#x63CF;&#x8FF0;&#x7B26;&#x7684;&#x89D2;&#x8272;]) Tj
T*
() Tj
T*
(在第一步中，服务器调用 accept，等待连接请求到达监听描述符，具体地我们设定为描述符 3。回忆一下，描述符 0 ~ 2 是预留给了标准文件的。) Tj
T*
() Tj
T*
(在第二步中，客户端调用 connect 函数，发送一个连接请求到 listenfd。第三步，accept 函数打开了一个新的已连接描述符 connfd（我们假设是描述符 4），在) Tj
T*
(clientfd 和 connfd 之间建立连接，并且随后返回 connfd 给应用程序。客户端也从 connect 返回，在这一点以后，客户端和服务器就可以分别通过读和写) Tj
T*
(clientfd 和 connfd 来回传送数据了。) Tj
T*
() Tj
T*
(旁注 - 为何要有监听描述符和已连接描述符之间的区别？) Tj
T*
() Tj
T*
() Tj
T*
(你可能很想知道为什么套接字接口要区别监听描述符和已连接描述符。乍一看，这像是不必要的复杂化。然而，区分这两者被证明是很有用的，因为它使得我们可以建立并发服务器，它能够同时处理许多客) Tj
T*
(户端连接。例如，每次一个连接请求到达监听描述符时，我们可以派生（fork）—个新的进程，它通过已连接描述符与客户端通信。在第 12 章中将介绍更多关于并发服务器的内容。) Tj
T*
() Tj
T*
(11.4.7 主机和服务的转换) Tj
T*
() Tj
T*
() Tj
T*
(Linux 提供了一些强大的函数（称为 getaddrinfo 和) Tj
T*
(getnameinfo）实现二进制套接字地址结构和主机名、主机地址、服务名和端口号的字符串表示之间的相互转化。当和套接字接口一起使用时，这些函数能使我们编写独立于任何特定版本的) Tj
T*
(IP 协议的网络程序。) Tj
T*
() Tj
T*
(1. getaddrinfo 函数) Tj
T*
() Tj
T*
() Tj
T*
(getaddrinfo 函数将主机名、主机地址、服务名和端口号的字符串表示转化成套接字地址结构。它是已弃用的 gethostbyname 和 getservbyname) Tj
T*
(函数的新的替代品。和以前的那些函数不同，这个函数是可重入的（见 12.7.2 节），适用于任何协议。) Tj
T*
() Tj
T*
(    #include <sys/types.h>) Tj
T*
(    #include <sys/socket.h>) Tj
T*
(    #include <netdb.h>) Tj
T*
() Tj
T*
(    int getaddrinfo\(const char *host, const char *service,) Tj
T*
(                    const struct addrinfo *hints,) Tj
T*
(                    struct addrinfo **result\);) Tj
T*
(    // 返回：如果成功则为 0，如果错误则为非零的错误代码。) Tj
T*
() Tj
T*
(    void freeaddrinfo\(struct addrinfo *result\);) Tj
T*
(    // 返回：无。) Tj
T*
() Tj
T*
(    const char *gai_strerror\(int errcode\);) Tj
T*
(    // 返回：错误消息。) Tj
T*
() Tj
T*
(给定 host 和 service（套接字地址的两个组成部分），getaddrinfo 返回 result，result 一个指向 addrinfo) Tj
T*
(结构的链表，其中每个结构指向一个对应于 host 和 service 的套接字地址结构（图 11-15）。) Tj
T*
() Tj
T*
ET
endstream
endobj
573 0 obj
<< /Length 4485 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
([Image: &#x56FE; 11-15 getaddrinfo) Tj
T*
(&#x8FD4;&#x56DE;&#x7684;&#x6570;&#x636E;&#x7ED3;&#x6784;]) Tj
T*
() Tj
T*
(在客户端调用了 getaddrinfo 之后，会遍历这个列表，依次尝试每个套接字地址，直到调用 socket 和 connect) Tj
T*
(成功，建立起连接。类似地，服务器会尝试遍历列表中的每个套接字地址，直到调用 socket 和 bind) Tj
T*
(成功，描述符会被绑定到一个合法的套接字地址。为了避免内存泄漏，应用程序必须在最后调用 freeaddrinfo，释放该链表。如果 getaddrinfo) Tj
T*
(返回非零的错误代码，应用程序可以调用 gai\\_streeror，将该代码转换成消息字符串。) Tj
T*
() Tj
T*
(getaddrinfo 的 host 参数可以是域名，也可以是数字地址（如点分十进制 IP 地址）。service 参数可以是服务名（如) Tj
T*
(http），也可以是十进制端口号。如果不想把主机名转换成地址，可以把 host 设置为 NULL。对 service 来说也是一样。但是必须指定两者中至少一个。) Tj
T*
() Tj
T*
(可选的参数 hints 是一个 addrinfo 结构（见图 11-16），它提供对 getaddrinfo 返回的套接字地址列表的更好的控制。) Tj
T*
() Tj
T*
(    struct addrinfo {) Tj
T*
(        int             ai_flags;      /* Hints argument flags */) Tj
T*
(        int             ai_family;     /* First arg to socket function */) Tj
T*
(        int             ai_socktype;   /* Second arg to socket function */) Tj
T*
(        int             ai_protocol;   /* Third arg to socket function */) Tj
T*
(        char            *ai_canonname; /* Canonical hostname */) Tj
T*
(        size_t          ai_addrlen;    /* Size of ai_addr struct */) Tj
T*
(        struct sockaddr *ai_addr;      /* Ptr to socket address structure */) Tj
T*
(        struct addrinfo *ai_next;      /* Ptr to next item in linked list */) Tj
T*
(    };) Tj
T*
() Tj
T*
(> 图 11-16 getaddrinfo 使用的 addrinfo 结构) Tj
T*
() Tj
T*
(如果要传递 hints 参数，只能设置下列字段：ai\\family、ai\\socktype、ai\\protocol 和 ai\\flags 字段。其他字段必须设置为 0（或) Tj
T*
(NULL）。实际中，我们用 memset 将整个结而清零，然后有选择地设置一些字段：) Tj
T*
() Tj
T*
(* getaddrinfo 默认可以返回 IPv4 和 IPv6 套接字地址。ai\\family 设置为 AF\\INET 会将列表限制为 IPv4 地址；设置为 AF\\_INET6) Tj
T*
(则限制为 IPv6 地址。) Tj
T*
(* 对于 host 关联的每个地址，getaddrinfo 函数默认最多返回三个 addrinfo 结构，每个的 ai\\socktype) Tj
T*
(字段不同：一个是连接，一个是数据报（本书未讲述），一个是原始套接字（本书未讲述）。ai\\socktype 设置为 SOCK\\_STREAM 将列表限制为对每个地址最多一个) Tj
T*
(addrinfo 结构，该结构的套接字地址可以作为连接的一个端点。这是所有示例程序所期望的行为。) Tj
T*
(* ai\\_flags 字段是一个位掩码，可以进一步修改默认行为。可以把各种值用 OR 组合起来得到该掩码。下面是一些我们认为有用的值：) Tj
T*
(  * AI\\_ADDRCONFIG。如果在使用连接，就推荐使用这个标志【34】。它要求只有当本地主机被配置为 IPv4 时，getaddrinfo 返回 IPv4 地址。对) Tj
T*
(  IPv6 也是类似。) Tj
T*
(  * AI\\CANONNAME。ai\\canonname 字段默认为 NULL。如果设置了该标志，就是告诉 getaddrinfo 将列表中第一个 addrinfo 结构的) Tj
T*
(  ai\\_canonname 字段指向 host 的权威（官方）名字（见图 11-15）。) Tj
T*
(  * AI\\_NUMERICSERV。参数 service 默认可以是服务名或端口号。这个标志强制参数 service 为端口号。) Tj
T*
(  * AI\\_PASSIVE。getaddrinfo 默认返回套接字地址，客户端可以在调用 connect) Tj
T*
(  时用作主动套接字。这个标志告诉该函数，返回的套接字地址可能被服务器用作监听套接字。在这种情况中，参数 host 应该为) Tj
T*
(  NULL。得到的套接字地址结构中的地址字段会是通配符地址（wildcard address），告诉内核这个服务器会接受发送到该主机所有 IP) Tj
T*
(  地址的请求。这是所有示例服务器所期望的行为。) Tj
T*
() Tj
T*
(当 getaddrinfo 创建输出列表中的 addrinfo 结构时，会填写每个字段，除了 ai\\flags。ai\\addr 字段指向一个套接字地址结构，ai\\addrlen) Tj
T*
ET
endstream
endobj
574 0 obj
<< /Length 3134 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(字段给出这个套接字地址结构的大小，而 ai\\next 字段指向列表中下一个 addrinfo 结构。其他字段描述这个套接字地址的各种属性。) Tj
T*
() Tj
T*
(getaddrinfo 一个很好的方面是 addrinfo) Tj
T*
(结构中的字段是不透明的，即它们可以直接传递给套接字接口中的函数，应用程序代码无需再做任何处理。例如，ai\\family、ai\\socktype 和 ai\\protocol) Tj
T*
(可以直接传递给 socket。类似地，ai\\addr 和 ai\\_addrlen 可以直接传递给 connect 和) Tj
T*
(bind。这个强大的属性使得我们编写的客户端和服务器能够独立于某个特殊版本的 IP 协议。) Tj
T*
() Tj
T*
(2. getnameinfo 函数) Tj
T*
() Tj
T*
() Tj
T*
(getnameinfo 函数和 getaddrinfo 是相反的，将一个套接字地址结构转换成相应的主机和服务名字符串。它是已弃用的 gethostbyaddr 和) Tj
T*
(getservbyport 函数的新的替代品，和以前的那些函数不同，它是可重入和与协议无关的。) Tj
T*
() Tj
T*
(    #include <sys/socket.h>) Tj
T*
(    #include <netdb.h>) Tj
T*
() Tj
T*
(    int getnameinfo\(const struct sockaddr *sa, socklen_t salen,) Tj
T*
(                    char *host, size_t hostlen,) Tj
T*
(                    char *service, size_t servlen, int flags\);) Tj
T*
() Tj
T*
(    // 返回：如果成功则为 0，如果错误则为非零的错误代码。) Tj
T*
() Tj
T*
(参数 sa 指向大小为 salen 字节的套接字地址结构，host 指向大小为 hostlen 字节的缓冲区，service 指向大小为 servlen) Tj
T*
(字节的缓冲区。getnameinfo 函数将套接字地址结构 sa 转换成对应的主机和服务名字符串，并将它们复制到 host 和 serveice 缓冲区。如果) Tj
T*
(getnameinfo 返回非零的错误代码，应用程序可以调用 gai\\_strerror 把它转化成字符串。) Tj
T*
() Tj
T*
(如果不想要主机名，可以把 host 设置为 NULL，hostlen 设置为 0。对服务字段来说也是一样。不过，两者必须设置其中之一。) Tj
T*
() Tj
T*
(参数 flags 是一个位掩码，能够修改默认的行为。可以把各种值用 OR 组合起来得到该掩码。下面是两个有用的值：) Tj
T*
() Tj
T*
(* NI\\_NUMERICHOST。getnameinfo 默认试图返回 host 中的域名。设置该标志会使该函数返回一个数字地址字符串。) Tj
T*
(* NI\\_NUMERICSERV。getnameinfo 默认会检查) Tj
T*
(/etc/services，如果可能，会返回服务名而不是端口号。设置该标志会使该函数跳过査找，简单地返回端口号。) Tj
T*
() Tj
T*
(图 11-17 给出了一个简单的程序，称为 HOSTINFO，它使用 getaddrinfo 和 getnameinfo 展示出域名到和它相关联的 IP) Tj
T*
(地址之间的映射。该程序类似于 11.3.2 节中的 NSLOOKUP 程序。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        struct addrinfo *p, *listp, hints;) Tj
T*
(        char buf[MAXLINE];) Tj
T*
(        int rc, flags;) Tj
T*
() Tj
T*
(        if \(argc != 2\) {) Tj
T*
ET
endstream
endobj
575 0 obj
<< /Length 2300 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            fprintf\(stderr, "usage: %s <domain name>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Get a list of addrinfo records */) Tj
T*
(        memset\(&hints, 0, sizeof\(struct addrinfo\)\);) Tj
T*
(        hints.ai_family = AF_INET;       /* IPv4 only */) Tj
T*
(        hints.ai_socktype = SOCK_STREAM; /* Connections only */) Tj
T*
(        if \(\(rc = getaddrinfo\(argv[1], NULL, &hints, &listp\)\) != 0\) {) Tj
T*
(            fprintf\(stderr, "getaddrinfo error: %s\\n", gai_strerror\(rc\)\);) Tj
T*
(            exit\(1\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Walk the list and display each IP address */) Tj
T*
(        flags = NI_NUMERICHOST; /* Display address string instead of domain name */) Tj
T*
(        for \(p = listp; p; p = p->ai_next\) {) Tj
T*
(            Getnameinfo\(p->ai_addr, p->ai_addrlen, buf, MAXLINE, NULL, 0, flags\);) Tj
T*
(            printf\("%s\\n", buf\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Clean up */) Tj
T*
(        Freeaddrinfo\(listp\);) Tj
T*
() Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-17 HOSTINFO 展示出域名到和它相关联的 IP 地址之间的映射) Tj
T*
() Tj
T*
(首先，初始化 hints 结构，使 getaddrinfo 返回我们想要的地址。在这里，我们想查找 32 位的 IP 地址（第 16 行），用作连接的端点（第 17 行）。因为只想) Tj
T*
(getaddrinfo 转换域名，所以用 service 参数为 NULL 来调用它。) Tj
T*
() Tj
T*
(调用 getaddrinfo 之后，会遍历 addrinfo 结构，用 getnameinfo 将每个套接字地址转换成点分十进制地址字符串。遍历完列表之后，我们调用) Tj
T*
(freeaddrinfo小心地释放这个列表（虽然对于这个简单的程序来说，并不是严格需要这样做的）。) Tj
T*
() Tj
T*
(运行 HOSTINFO 时，我们看到 twitter.com 映射到了四个 IP 地址，和 11.3.2 节用 NSLOOKUP 的结果一样。) Tj
T*
() Tj
T*
(    linux> ./hostinfo twitter.com) Tj
T*
(    199.16.156.102) Tj
T*
(    199.16.156.230) Tj
T*
(    199.16.156.6) Tj
T*
(    199.16.156.70) Tj
T*
() Tj
T*
(练习题 11.4) Tj
T*
() Tj
T*
() Tj
T*
(函数 getaddrinfo 和 getnameinfo 分别包含了 inet\\pton 和 inet\\ntop) Tj
T*
ET
endstream
endobj
576 0 obj
<< /Length 2262 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(的功能，提供了更高级别的、独立于任何特殊地址格式的抽象。想看看这到底有多方便，编写 HOSTINFO（图 11-17）的一个版本，用 inet\\_pton 而不是) Tj
T*
(getnameinfo 将毎个套接字地址转换成点分十进制地址字符串。) Tj
T*
() Tj
T*
(下面是解决方案。注意，使用 inet\\_ntop 要困难多少，它要求很麻烦的强制类型转换和深层嵌套结构引用。getnameinfo 函数要简单许多，因为它为我们完成了这些工作。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        struct addrinfo *p, *listp, hints;) Tj
T*
(        struct sockaddr_in *sockp;) Tj
T*
(        char buf[MAXLINE];) Tj
T*
(        int rc;) Tj
T*
() Tj
T*
(        if \(argc != 2\) {) Tj
T*
(            fprintf\(stderr, "usage: %s <domain name>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Get a list of addrinfo records */) Tj
T*
(        memset\(&hints, 0, sizeof\(struct addrinfo\)\);) Tj
T*
(        hints.ai_family = AF_INET;       /* IPv4 only */) Tj
T*
(        hints.ai_socktype = SOCK_STREAM; /* Connections only */) Tj
T*
(        if \(\(rc = getaddrinfo\(argv[1], NULL, &hints, &listp\)\) != 0\) {) Tj
T*
(            fprintf\(stderr, "getaddrinfo error: %s\\n", gai_strerror\(rc\)\);) Tj
T*
(            exit\(1\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Walk the list and display each associated IP address */) Tj
T*
(        for \(p = listp; p; p = p->ai_next\) {) Tj
T*
(            sockp = \(struct sockaddr_in *\)p->ai_addr;) Tj
T*
(            Inet_ntop\(AF_INET, &\(sockp->sin_addr\), buf, MAXLINE\);) Tj
T*
(            printf\("%s\\n", buf\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Clean up */) Tj
T*
(        Freeaddrinfo\(listp\);) Tj
T*
() Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(11.4.8 套接字接口的辅助函数) Tj
T*
() Tj
T*
() Tj
T*
(初学时，getnameinfo 函数和套接字接口看上去有些可怕。用高级的辅助函数包装一下会方便很多，称为 open\\clientfd 和) Tj
T*
(open\\listenfd，客户端和服务器互相通信时可以使用这些函数。) Tj
T*
ET
endstream
endobj
577 0 obj
<< /Length 2198 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(1. open\\_clientfd 函数) Tj
T*
() Tj
T*
() Tj
T*
(客户端调用 open\\_clientfd 建立与服务器的连接。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int open_clientfd\(char *hostname, char *port\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为描述符，若出错则为 -1。) Tj
T*
() Tj
T*
(open\\clientfd 函数建立与服务器的连接，该服务器运行在主机 hostname 上，并在端口号 port) Tj
T*
(上监听连接请求。它返回一个打开的套接字描述符，该描述符准备好了，可以用 Unix I/O 函数做输入和输出。图 11-18 给出了 open\\clientfd 的代码。) Tj
T*
() Tj
T*
(    int open_clientfd\(char *hostname, char *port\) {) Tj
T*
(        int clientfd;) Tj
T*
(        struct addrinfo hints, *listp, *p;) Tj
T*
() Tj
T*
(        /* Get a list of potential server addresses */) Tj
T*
(        memset\(&hints, 0, sizeof\(struct addrinfo\)\);) Tj
T*
(        hints.ai_socktype = SOCK_STREAM;  /* Open a connection */) Tj
T*
(        hints.ai_flags = AI_NUMERICSERV;  /* ... using a numeric port arg. */) Tj
T*
(        hints.ai_flags |= AI_ADDRCONFIG;  /* Recommended for connections */) Tj
T*
(        Getaddrinfo\(hostname, port, &hints, &listp\);) Tj
T*
() Tj
T*
(        /* Walk the list for one that we can successfully connect to */) Tj
T*
(        for \(p = listp; p; p = p->ai_next\) {) Tj
T*
(            /* Create a socket descriptor */) Tj
T*
(            if \(\(clientfd = socket\(p->ai_family, p->ai_socktype, p->ai_protocol\)\) < 0\)) Tj
T*
(                continue; /* Socket failed, try the next */) Tj
T*
() Tj
T*
(            /* Connect to the server */) Tj
T*
(            if \(connect\(clientfd, p->ai_addr, p->ai_addrlen\) != -1\)) Tj
T*
(                break; /* Success */) Tj
T*
(            Close\(clientfd\); /* Connect failed, try another */) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Clean up */) Tj
T*
(        Freeaddrinfo\(listp\);) Tj
T*
(        if \(!p\) /* All connects failed */) Tj
T*
(            return -1;) Tj
T*
(        else    /* The last connect succeeded */) Tj
T*
(            return clientfd;) Tj
T*
(    }) Tj
T*
() Tj
T*
ET
endstream
endobj
578 0 obj
<< /Length 2828 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(> 图 11-18 open\\_clientfd：和服务器建立连接的辅助函数。它是可重入和与协议无关的) Tj
T*
() Tj
T*
(我们调用 getaddrinfo，它返回 addrinfo 结构的列表，每个结构指向一个套接字地址结构，可用于建立与服务器的连接，该服务器运行在 hostname 上并监听) Tj
T*
(port 端口。然后遍历该列表，依次尝试列表中的每个条目，直到调用 socket 和 connect 成功。如果 connect) Tj
T*
(失败，在尝试下一个条目之前，要小心地关闭套接字描述符。如果 connect 成功，我们会释放列表内存，并把套接字描述符返回给客户端，客户端可以立即开始用 Unix I/O) Tj
T*
(与服务器通信了。) Tj
T*
() Tj
T*
(注意，所有的代码都与任何版本的 IP 无关。socket 和 connect 的参数都是用 getaddrinfo 自动产生的，这使得我们的代码干净可移植。) Tj
T*
() Tj
T*
(2. open\\_listenfd 函数) Tj
T*
() Tj
T*
() Tj
T*
(调用 open\\_listenfd 函数，服务器创建一个监听描述符，准备好接收连接请求。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int open_listenfd\(char *port\);) Tj
T*
() Tj
T*
(    // 返回：若成功则为描述符，若出错则为 -1。) Tj
T*
() Tj
T*
(open\\listenfd 函数打开和返回一个监听描述符，这个描述符准备好在端口 port\\h 接收连接请求。图 11-19 展示了 open\\_listenfd 的代码。) Tj
T*
() Tj
T*
(    int open_listenfd\(char *port\)) Tj
T*
(    {) Tj
T*
(        struct addrinfo hints, *listp, *p;) Tj
T*
(        int listenfd, optval = 1;) Tj
T*
() Tj
T*
(        /* Get a list of potential server addresses */) Tj
T*
(        memset\(&hints, 0, sizeof\(struct addrinfo\)\);) Tj
T*
(        hints.ai_socktype = SOCK_STREAM;             /* Accept connections */) Tj
T*
(        hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG; /* ... on any IP address */) Tj
T*
(        hints.ai_flags |= AI_NUMERICSERV;            /* ... using port number */) Tj
T*
(        Getaddrinfo\(NULL, port, &hints, &listp\);) Tj
T*
() Tj
T*
(        /* Walk the list for one that we can bind to */) Tj
T*
(        for \(p = listp; p; p = p->ai_next\) {) Tj
T*
(            /* Create a socket descriptor */) Tj
T*
(            if \(\(listenfd = socket\(p->ai_family, p->ai_socktype, p->ai_protocol\)\) < 0\)) Tj
T*
(                continue; /* Socket failed, try the next */) Tj
T*
() Tj
T*
(            /* Eliminates "Address already in use" error from bind */) Tj
T*
(            Setsockopt\(listenfd, SOL_SOCKET, SO_REUSEADDR,) Tj
T*
(                       \(const void *\)&optval , sizeof\(int\)\);) Tj
T*
() Tj
T*
(            /* Bind the descriptor to the address */) Tj
T*
(            if \(bind\(listenfd, p->ai_addr, p->ai_addrlen\) == 0\)) Tj
T*
ET
endstream
endobj
579 0 obj
<< /Length 2332 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(                break; /* Success */) Tj
T*
(            Close\(listenfd\); /* Bind failed, try the next */) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Clean up */) Tj
T*
(        Freeaddrinfo\(listp\);) Tj
T*
(        if \(!p\) /* No address worked */) Tj
T*
(            return -1;) Tj
T*
() Tj
T*
(        /* Make it a listening socket ready to accept connection requests */) Tj
T*
(        if \(listen\(listenfd, LISTENQ\) < 0\) {) Tj
T*
(            Close\(listenfd\);) Tj
T*
(            return -1;) Tj
T*
(        }) Tj
T*
(        return listenfd;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-19 open\\_listenfd：打开并返回监听描述符的辅助函数。它是可重入和与协议无关的) Tj
T*
() Tj
T*
(open\\listenfd 的风格类似于 open\\clientfd。调用 getaddrinfo，然后遍历结果列表，直到调用 socket 和 bind 成功。注意，在第 20) Tj
T*
(行，我们使用 setsockopt 函数（本书中没有讲述）来配置服务器，使得服务器能够被终止、重启和立即开始接收连接请求。一个重启的服务器默认将在大约 30) Tj
T*
(秒内拒绝客户端的连接请求，这严重地阻碍了调试。) Tj
T*
() Tj
T*
(因为我们调用 getaddrinfo 时，使用了 AI\\_PASSIVE 标志并将 host 参数设置为) Tj
T*
(NULL，每个套接字地址结构中的地址字段会被设置为通配符地址，这告诉内核这个服务器会接收发送到本主机所有 IP 地址的请求。) Tj
T*
() Tj
T*
(最后，我们调用 listen 函数，将 listenfd 转换为一个监听描述符，并返回给调用者。如果 listen 失败，我们要小心地避免内存泄漏，在返回前关闭描述符。) Tj
T*
() Tj
T*
(11.4.9 echo 客户端和服务器的示例) Tj
T*
() Tj
T*
() Tj
T*
(学习套接字接口的最好方法是研究示例代码。图 11-20 展示了一个 echo 客户端的代码。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        int clientfd;) Tj
T*
(        char *host, *port, buf[MAXLINE];) Tj
T*
(        rio_t rio;) Tj
T*
() Tj
T*
(        if \(argc != 3\) {) Tj
T*
(            fprintf\(stderr, "usage: %s <host> <port>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
(        host = argv[1];) Tj
T*
ET
endstream
endobj
580 0 obj
<< /Length 2442 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        port = argv[2];) Tj
T*
() Tj
T*
(        clientfd = Open_clientfd\(host, port\);) Tj
T*
(        Rio_readinitb\(&rio, clientfd\);) Tj
T*
() Tj
T*
(        while \(Fgets\(buf, MAXLINE, stdin\) != NULL\) {) Tj
T*
(            Rio_writen\(clientfd, buf, strlen\(buf\)\);) Tj
T*
(            Rio_readlineb\(&rio, buf, MAXLINE\);) Tj
T*
(            Fputs\(buf, stdout\);) Tj
T*
(        }) Tj
T*
(        Close\(clientfd\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-20 echo 客户端的主程序) Tj
T*
() Tj
T*
(在和服务器建立连接之后，客户端进入一个循环，反复从标准输入读取文本行，发送文本行给服务器，从服务器读取回送的行，并输出结果到标准输出。当 fgets 在标准输入上遇到 EOF) Tj
T*
(时，或者因为用户在键盘上键入 Ctrl+D，或者因为在一个重定向的输入文件中用尽了所有的文本行时，循环就终止。) Tj
T*
() Tj
T*
(循环终止之后，客户端关闭描述符。这会导致发送一个 EOF 通知到服务器，当服务器从它的 reo\\_readlineb) Tj
T*
(函数收到一个为零的返回码时，就会检测到这个结果。在关闭它的描述符后，客户端就终止了。既然客户端内核在一个进程终止时会自动关闭所有打开的描述符，第 24 行的 close) Tj
T*
(就没有必要了。不过，显式地关闭已经打开的任何描述符是一个良好的编程习惯。) Tj
T*
() Tj
T*
(图 11-21 展示了 echo 服务器的主程序。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void echo\(int connfd\);) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        int listenfd, connfd;) Tj
T*
(        socklen_t clientlen;) Tj
T*
(        struct sockaddr_storage clientaddr; /* Enough space for any address */) Tj
T*
(        char client_hostname[MAXLINE], client_port[MAXLINE];) Tj
T*
() Tj
T*
(        if \(argc != 2\) {) Tj
T*
(            fprintf\(stderr, "usage: %s <port>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        listenfd = Open_listenfd\(argv[1]\);) Tj
T*
(        while \(1\) {) Tj
T*
(            clientlen = sizeof\(struct sockaddr_storage\);) Tj
T*
(            connfd = Accept\(listenfd, \(SA *\)&clientaddr, &clientlen\);) Tj
T*
(            Getnameinfo\(\(SA *\) &clientaddr, clientlen, client_hostname, MAXLINE,) Tj
T*
ET
endstream
endobj
581 0 obj
<< /Length 2987 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(                        client_port, MAXLINE, 0\);) Tj
T*
(            printf\("Connected to \(%s, %s\)\\n", client_hostname, client_port\);) Tj
T*
(            echo\(connfd\);) Tj
T*
(            Close\(connfd\);) Tj
T*
(        }) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-21 迭代 echo 服务器的主程序) Tj
T*
() Tj
T*
(在打开监听描述符后，它进入一个无限循环。每次循环都等待一个来自客户端的连接请求，输出已连接客户端的域名和 IP 地址，并调用 echo 函数为这些客户端服务。在 echo) Tj
T*
(程序返回后，主程序关闭已连接描述符。一旦客户端和服务器关闭了它们各自的描述符，连接也就终止了。) Tj
T*
() Tj
T*
(第 9 行的 clientaddr 变量是一个套接字地址结构，被传递给 accept。在 accept 返回之前，会在 clientaddr) Tj
T*
(中填上连接另一端客户端的套接字地址。注意，我们将 clientaddr 声明为 struct sockaddr\\storage 类型，而不是 struct sockaddr\\in) Tj
T*
(类型。根据定义，sockaddr\\_storage 结构足够大能够装下任何类型的套接字地址，以保持代码的协议无关性。) Tj
T*
() Tj
T*
(注意，简单的 echo 服务器一次只能处理一个客户端。这种类型的服务器一次一个地在客户端间迭代，称为迭代服务器（iterative server）。在第 12) Tj
T*
(章中，我们将学习如何建立更加复杂的并发服务器（concurrent server），它能够同时处理多个客户端。) Tj
T*
() Tj
T*
(最后，图 11-22 展示了 echo 程序的代码，该程序反复读写文本行，直到 rio\\_readlineb 函数在第 10 行遇到 EOF。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void echo\(int connfd\)) Tj
T*
(    {) Tj
T*
(        size_t n;) Tj
T*
(        char buf[MAXLINE];) Tj
T*
(        rio_t rio;) Tj
T*
() Tj
T*
(        Rio_readinitb\(&rio, connfd\);) Tj
T*
(        while \(\(n = Rio_readlineb\(&rio, buf, MAXLINE\)\) != 0\) {) Tj
T*
(            printf\("server received %d bytes\\n", \(int\)n\);) Tj
T*
(            Rio_writen\(connfd, buf, n\);) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-22 读和回送文本行的 echo 函数) Tj
T*
() Tj
T*
(旁注 - 在连接中 EOF 意味什么？) Tj
T*
() Tj
T*
() Tj
T*
(EOF 的概念常常使人们感到迷惑，尤其是在因特网连接的上下文中。首先，我们需要理解其实并没有像 EOF 字符这样的一个东西。进一步来说，EOF) Tj
T*
(是由内核检测到的一种条件。应用程序在它接收到一个由 read 函数返回的零返回码时，它就会发现出 EOF 条件。对于磁盘文件，当前文件位置超出文件长度时，会发生) Tj
T*
(EOF。对于因特网连接，当一个进程关闭连接它的那一端时，会发生 EOF。连接另一端的进程在试图读取流中最后一个字节之后的字节时，会检测到 EOF。) Tj
T*
() Tj
T*
ET
endstream
endobj
582 0 obj
<< /Length 3649 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(================================================================================) Tj
T*
(11.5 Web 服务器) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(11.5 Web 服务器) Tj
T*
() Tj
T*
() Tj
T*
(迄今为止，我们已经在一个简单的 echo 服务器的上下文中讨论了网络编程。在这一节里，我们将向你展示如何利用网络编程的基本概念，来创建你自己的虽小但功能齐全的 Web 服务器。) Tj
T*
() Tj
T*
(11.5.1 Web 基础) Tj
T*
() Tj
T*
() Tj
T*
(Web 客户端和服务器之间的交互用的是一个基于文本的应用级协议，叫做 HTTP（hypertext Transfer Protocol，超文本传输协议）。HTTP) Tj
T*
(是一个简单的协议。一个 Web 客户端（即浏览器）打开一个到服务器的因特网连接，并且请求某些内容。服务器响应所请求的内容，然后关闭连接。浏览器读取这些内容，并把它显示在屏幕上。) Tj
T*
() Tj
T*
(Web 服务和常规的文件检索服务（例如 FTP）有什么区别呢？主要的区别是 Web 内容可以用一种叫做 HTML（Hypertext) Tj
T*
(MarkupLanguage，超文本标记语言）的语言来编写。一个 HTML 程序（页）包含指令（标记），它们告诉浏览器如何显示这页中的各种文本和图形对象。例如，代码) Tj
T*
() Tj
T*
(    <b> Make me bold! </b>) Tj
T*
() Tj
T*
(告诉浏览器用粗体字类型输出 &lt;b&gt; 和 &lt;/b&gt; 标记之间的文本。然而，HTML) Tj
T*
(真正的强大之处在于一个页面可以包含指针（超链接），这些指针可以指向存放在任何因特网主机上的内容。例如，一个格式如下的 HTML 行) Tj
T*
() Tj
T*
(    <a href="http://www.cmu.edu/index.html">Carnegie Mellon</a>) Tj
T*
() Tj
T*
(告诉浏览器高亮显示文本对象 “Carnegie Mellon”，并且创建一个超链接，它指向存放在 CMU Web 服务器上叫做 index.html 的 HTML) Tj
T*
(文件。如果用户单击了这个高亮文本对象，浏览器就会从 CMU 服务器中请求相应的 HTML 文件并显示它。) Tj
T*
() Tj
T*
(旁注 - 万维网的起源) Tj
T*
() Tj
T*
() Tj
T*
(万维网是 Tim Berners-Lee 发明的，他是一位在瑞典物理实验室 CERN（欧洲粒子物理研究所）工作的软件工程师。1989 年，Berners-Lee) Tj
T*
(写了一个内部备忘录，提出了一个分布式超文本系统，它能连接“用链接组成的笔记的网（web of notes with links）”。提出这个系统的目的是帮助 CERN) Tj
T*
(的科学家共享和管理信息。在接下来的两年多里，Berners-Lee 实现了第一个 Web 服务器和 Web 浏览器之后，在 CERN 内部以及其他一些网站中，Web) Tj
T*
(发展出了小规模的拥护者。1993 年一个关键事件发生了，Marc Andreesen（他后来创建了 Netscape）和他在 NCSA 的同事发布了一种图形化的浏览器，叫做) Tj
T*
(MOSAIC，可以在三种主要的平台上所使用：Unix、Windows 和 Macintosh。在 MOSAIC 发布后，对 Web 的兴趣爆发了，Web 网站以每年 10) Tj
T*
(倍或更高的数量增长。到 2015 年，世界上已经有超过 975 000 000 个 Web 网站了（源自 Netcraft Web Survey）。) Tj
T*
() Tj
T*
(11.5.2 Web 内容) Tj
T*
() Tj
T*
() Tj
T*
(对于 Web 客户端和服务器而言，内容是与一个 MIME（Multipurpose Internet Mail) Tj
T*
(Extensions，多用途的网际邮件扩充协议）类型相关的字节序列。图 11-23 展示了一些常用的 MIME 类型。) Tj
T*
() Tj
T*
(| MIME类型 | 描述 |) Tj
T*
ET
endstream
endobj
583 0 obj
<< /Length 3212 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(| :--- | :--- |) Tj
T*
(| text/html | HTML 页面 |) Tj
T*
(| text/plain | 无格式文本 |) Tj
T*
(| application/postscript | Postscript 文档 |) Tj
T*
(| image/gif | GIF 格式编码的二进制图像 |) Tj
T*
(| image/png | PNG 格式编码的二进制图像 |) Tj
T*
(| image/jpeg | JPEG 格式编码的二进制图像 |) Tj
T*
() Tj
T*
(> 图 11-23 MIME 类型示例) Tj
T*
() Tj
T*
(Web 服务器以两种不同的方式向客户端提供内容：) Tj
T*
() Tj
T*
(* 取一个磁盘文件，并将它的内容返回给客户端。磁盘文件称为静态内容（static content），而返回文件给客户端的过程称为服务静态内容（serving static) Tj
T*
(content）。) Tj
T*
(* 运行一个可执行文件，并将它的输出返回给客户端。运行时可执行文件产生的输出称为动态内容（dynamic) Tj
T*
(content），而运行程序并返回它的输出到客户端的过程称为服务动态内容（serving dynamic content）。) Tj
T*
() Tj
T*
(每条由 Web 服务器返回的内容都是和它管理的某个文件相关联的。这些文件中的每一个都有一个唯一的名字，叫做 URL（Universal Resource) Tj
T*
(Locator，通用资源定位符）。例如，URL) Tj
T*
() Tj
T*
(http://www.google.com:80/index.html) Tj
T*
() Tj
T*
(表示因特网主机 www.google.com 上一个称为 /index.html 的 HTML 文件，它是由一个监听端口 80 的 Web) Tj
T*
(服务器管理的。端口号是可选的，默认为知名的 HTTP 端口 80。可执行文件的 URL 可以在文件名后包括程序参数。“?” 字符分隔文件名和参数，而且每个参数都用 “&”) Tj
T*
(字符分隔开。例如，URL) Tj
T*
() Tj
T*
(http://bluefish.ics.cs.cmu.edu:8000/cgi-bin/adder?15000&213) Tj
T*
() Tj
T*
(标识了一个叫做 /cgi-bin/adder 的可执行文件，会带两个参数字符串 15000 和 213 来调用它。在事务过程中，客户端和服务器使用的是 URL) Tj
T*
(的不同部分。例如，客户端使用前缀) Tj
T*
() Tj
T*
(http://www.google.com:80) Tj
T*
() Tj
T*
(来决定与哪类服务器联系，服务器在哪里，以及它监听的端口号是多少。服务器使用后缀) Tj
T*
() Tj
T*
(/index.html) Tj
T*
() Tj
T*
(来发现在它文件系统中的文件，并确定请求的是静态内容还是动态内容。) Tj
T*
() Tj
T*
(关于服务器如何解释一个 URL 的后缀，有几点需要理解：) Tj
T*
() Tj
T*
(* 确定一个 URL 指向的是静态内容还是动态内容没有标准的规则。每个服务器对它所管理的文件都有自己的规则。一种经典的（老式的）方法是，确定一组目录，例如 cgi-) Tj
T*
(bin，所有的可执行性文件都必须存放这些目录中。) Tj
T*
(* 后缀中的最开始的那个 “/” 不表示 Linux 的根目录。相反，它表示的是被请求内容类型的主目录。例如，可以将一个服务器配置成这样：所有的静态内容存放在目录) Tj
T*
(/usr/httpd/html 下，而所有的动态内容都存放在目录 /usr/httpd/cgi-bin 下。) Tj
T*
(* 最小的 URL 后缀是 “/” 字符，所有服务器将其扩展为某个默认的主页，例如) Tj
T*
ET
endstream
endobj
584 0 obj
<< /Length 3466 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(/index.html。这解释了为什么简单地在浏览器中键入一个域名就可以取出一个网站的主页。浏览器在 URL 后添加缺失的 “/”，并将之传递给服务器，服务器又把 “/”) Tj
T*
(扩展到某个默认的文件名。) Tj
T*
() Tj
T*
(11.5.3 HTTP 事务) Tj
T*
() Tj
T*
() Tj
T*
(因为 HTTP 是基于在因特网连接上传送的文本行的，我们可以使用 Linux 的 TELNET 程序来和因特网上的任何 Web) Tj
T*
(服务器执行事务。对于调试在连接上通过文本行来与客户端对话的服务器来说，TELNET 程序是非常便利的。例如，图 11-24 使用 TELNET 向 AOL Web 服务器请求主页。) Tj
T*
() Tj
T*
(    linux> telnet www.aol.com 80            # Client: open connection to server) Tj
T*
(    Trying 205.188.146.23...                # Telnet prints 3 lines to the terminal) Tj
T*
(    Connected to aol.com.) Tj
T*
(    Escape character is '^]'.) Tj
T*
(    GET / HTTP/1.1                          # Client: request line) Tj
T*
(    Host: www.aol.com                       # Client: required HTTP/1.1 header) Tj
T*
(                                            # Client: empty line terminates headers) Tj
T*
(    HTTP/1.0 200 OK                         # Server: response line) Tj
T*
(    MIME-Version: 1.0                       # Server: followed by five response headers) Tj
T*
(    Date: Mon, 8 Jan 2010 4:59:42 GMT) Tj
T*
(    Server: Apache-Coyote/1.1) Tj
T*
(    Content-Type: text/html                 # Server: expect HTML in the response body) Tj
T*
(    Content-Length: 42092                   # Server: expect 42,092 bytes in the response) Tj
T*
(    body) Tj
T*
(                                            # Server: empty line terminates response) Tj
T*
(                                            headers) Tj
T*
(    <html>                                  # Server: first HTML line in response body) Tj
T*
(    ...                                     # Server: 766 lines of HTML not shown) Tj
T*
(    </html>                                 # Server: last HTML line in response body) Tj
T*
(    Connection closed by foreign host.      # Server: closes connection) Tj
T*
(    linux>                                  # Client: closes connection and terminate) Tj
T*
() Tj
T*
(> 图 11-24 一个服务静态内容的 HTTP 事务) Tj
T*
() Tj
T*
(在第 1 行，我们从 Linux shell 运行 TELNET，要求它打开一个到 AOL Web 服务器的连接。TELNET) Tj
T*
(向终端打印三行输出，打开连接，然后等待我们输入文本（第 5 行）。每次输入一个文本行，并键入回车键，TELNET 会读取该行，在后面加上回车和换行符号（在 C 的表示中为) Tj
T*
(“\\r\\n”），并且将这一行发送到服务器。这是和 HTTP 标准相符的，HTTP 标准要求每个文本行都由一对回车和换行符来结束。为了发起事务，我们输入一个 HTTP 请求（第 5) Tj
T*
(~ 7 行）。服务器返回 HTTP 响应（第 8 ~ 17 行），然后关闭连接（第 18 行）。) Tj
T*
() Tj
T*
(1. HTTP 请求) Tj
T*
() Tj
T*
() Tj
T*
(一个 HTTP 请求的组成是这样的：一个请求行（request line）（第 5 行），后面跟随零个或更多个请求报头（request header）（第 6) Tj
T*
(行），再跟随一个空的文本行来终止报头列表（第 7 行）。一个请求行的形式是) Tj
T*
() Tj
T*
(method URI version) Tj
T*
() Tj
T*
ET
endstream
endobj
585 0 obj
<< /Length 3825 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(HTTP 支持许多不同的方法，包括 GET、POST、OPTIONS、HEAD、PUT、DELETE 和 TRACE。我们将只讨论广为应用的 GET 方法，大多数 HTTP) Tj
T*
(请求都是这种类型的。GET 方法指导服务器生成和返回 URI（Uniform Resource Identifier，统一资源标识符）标识的内容。URI 是相应的 URL) Tj
T*
(的后缀，包括文件名和可选的参数。✦) Tj
T*
() Tj
T*
(✦：实际上，只有当浏览器请求内容时，这才是真的。如果代理服务器请求内容，那么这个 URI 必须是完整的 URL。) Tj
T*
() Tj
T*
(请求行中的 version 字段表明了该请求遵循的 HTTP 版本。最新的 HTTP 版本是 HTTP/1.1【37】。HTTP/1.0 是从 1996) Tj
T*
(年沿用至今的老版本【6】。HTTP/1.1 定义了一些附加的报头，为诸如缓冲和安全等高级特性提供支持，它还支持一种机制，允许客户端和服务器在同一条持久连接（persistent) Tj
T*
(connection）上执行多个事务。在实际中，两个版本是互相兼容的，因为 HTTP/1.0 的客户端和服务器会简单地忽略 HTTP/1.1 的报头。) Tj
T*
() Tj
T*
(总的来说，第 5 行的请求行要求服务器取出并返回 HTML 文件 /index.html。它也告知服务器请求剩下的部分是 HTTP/1.1 格式的。) Tj
T*
() Tj
T*
(请求报头为服务器提供了额外的信息，例如浏览器的商标名，或者浏览器理解的 MIME 类型。请求报头的格式为) Tj
T*
() Tj
T*
(header-name: header-data) Tj
T*
() Tj
T*
(针对我们的目的，唯一需要关注的报头是 Host 报头（第 6 行），这个报头在 HTTP/1.1 请求中是需要的，而在 HTTP/1.0 请求中是不需要的。代理缓存（proxy) Tj
T*
(cache）会使用 Host 报头，这个代理缓存有时作为浏览器和管理被请求文件的原始服务器（origin) Tj
T*
(server）的中介。客户端和原始服务器之间，可以有多个代理，即所谓的代理链（proxy chain）。Host) Tj
T*
(报头中的数据指示了原始服务器的域名，使得代理链中的代理能够判断它是否可以在本地缓存中拥有一个被请求内容的副本。) Tj
T*
() Tj
T*
(继续图 11-24 中的示例，第 7 行的空文本行（通过在键盘上键入回车键生成的）终止了报头，并指示服务器发送被请求的 HTML 文件。) Tj
T*
() Tj
T*
(2. HTTP 响应) Tj
T*
() Tj
T*
() Tj
T*
(HTTP 响应和 HTTP 请求是相似的。一个 HTTP 响应的组成是这样的：一个响应行（response line）（第 8) Tj
T*
(行），后面跟随着零个或更多的响应报头（response header）（第 9 ~ 13 行），再跟随一个终止报头的空行（第 14 行），再跟随一个响应主体（response) Tj
T*
(body）（第 15 ~ 17 行）。一个响应行的格式是) Tj
T*
() Tj
T*
(version status-code status-message) Tj
T*
() Tj
T*
(version 字段描述的是响应所遵循的 HTTP 版本。状态码（status-code）是一个 3 位的正整数，指明对请求的处理。状态消息（status) Tj
T*
(message）给出与错误代码等价的英文描述。图 11-25 列出了一些常见的状态码，以及它们相应的消息。) Tj
T*
() Tj
T*
(| 状态代码 | 状态消息 | 描述 |) Tj
T*
(| :---: | :--- | :--- |) Tj
T*
(| 200 | 成功 | 处理请求无误 |) Tj
T*
(| 301 | 永久移动 | 内容已移动到 location 头中指明的主机上 |) Tj
T*
(| 400 | 错误请求 | 服务器不能理解请求 |) Tj
T*
(| 403 | 禁止 | 服务器无权访问所请求的文件 |) Tj
T*
(| 404 | 未发现 | 服务器不能找到所请求的文件 |) Tj
T*
(| 501 | 未实现 | 服务器不支持请求的方法 |) Tj
T*
(| 505 | HTTP 版本不支持 | 服务器不支持请求的版本 |) Tj
T*
() Tj
T*
(> 图 11-25 一些 HTTP 状态码) Tj
T*
ET
endstream
endobj
586 0 obj
<< /Length 2771 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(第 9 ~ 13 行的响应报头提供了关于响应的附加信息。针对我们的目的，两个最重要的报头是 Content-Type（第 12 行），它告诉客户端响应主体中内容的 MIME) Tj
T*
(类型；以及 Content-Length（第 13 行），用来指示响应主体的字节大小。) Tj
T*
() Tj
T*
(第 14 行的终止响应报头的空文本行，其后跟随着响应主体，响应主体中包含着被请求的内容。) Tj
T*
() Tj
T*
(11.5.4 服务动态内容) Tj
T*
() Tj
T*
() Tj
T*
(如果我们停下来考虑一下，一个服务器是如何向客户端提供动态内容的，就会发现一些问题。例如，客户端如何将程序参数传递给服务器？服务器如何将这些参数传递给它所创建的子进程？服务器如何将子) Tj
T*
(进程生成内容所需要的其他信息传递给子进程？子进程将它的输出发送到哪里？一个称为 CGI（Common Gateway) Tj
T*
(Interface，通用网关接口）的实际标准的出现解决了这些问题。) Tj
T*
() Tj
T*
(1. 客户端如何将程序参数传递给服务器) Tj
T*
() Tj
T*
() Tj
T*
(GET 请求的参数在 URI 中传递。正如我们看到的，一个 “?” 字符分隔了文件名和参数，而每个参数都用一个 “&” 字符分隔开。参数中不允许有空格，而必须用字符串 “％20”) Tj
T*
(来表示。对其他特殊字符，也存在着相似的编码。) Tj
T*
() Tj
T*
(旁注 - 在 HTTP POST 请求中传递参数) Tj
T*
() Tj
T*
() Tj
T*
(HTTP POST 请求的参数是在请求主体中而不是 URI 中传递的。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(2. 服务器如何将参数传递给子进程) Tj
T*
() Tj
T*
() Tj
T*
(在服务器接收一个如下的请求后) Tj
T*
() Tj
T*
(    GET /cgi-bin/adder?15000&213 HTTP/1.1) Tj
T*
() Tj
T*
(它调用 fork 来创建一个子进程，并调用 execve 在子进程的上下文中执行 /cgi-bin/adder 程序。像 adder 这样的程序，常常被称为 CGI) Tj
T*
(程序，因为它们遵守 CGI 标准的规则。而且，因为许多 CGI 程序是用 Perl 脚本编写的，所以 CGI 程序也常被称为 CGI 脚本。在调用 execve 之前，子进程将) Tj
T*
(CGI 环境变量 QUERY\\_STRING 设置为 “15000&213”，adder 程序在运行时可以用 Linux getenv 函数来引用它。) Tj
T*
() Tj
T*
(3. 服务器如何将其他信息传递给子进程) Tj
T*
() Tj
T*
() Tj
T*
(CGI 定义了大量的其他环境变量，一个 CGI 程序在它运行时可以设置这些环境变量。图 11-26 给出了其中的一部分。) Tj
T*
() Tj
T*
(| 环境变量 | 描述 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| QUERY\\_STRING | 程序参数 |) Tj
T*
(| SERVER\\_PORT | 父进程侦听的端口 |) Tj
T*
ET
endstream
endobj
587 0 obj
<< /Length 2275 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(| REQUEST\\_METHOD | GET 或 POST |) Tj
T*
(| REMOTE\\_HOST | 客户端的域名 |) Tj
T*
(| REMOTE\\_ADDR | 客户端的点分十进制 IP 地址 |) Tj
T*
(| CONTENT\\_TYPE | 只对 POST 而言：请求体的 MIME 类型 |) Tj
T*
(| CONTENT\\_LENGTH | 只对 POST 而言：请求体的字节大小 |) Tj
T*
() Tj
T*
(> 图 11-26 CGI 环境变量示例) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(4. 子进程将它的输出发送到哪里) Tj
T*
() Tj
T*
() Tj
T*
(一个 CGI 程序将它的动态内容发送到标准输出。在子进程加载并运行 CGI 程序之前，它使用 Linux dup2 函数将标准输出重定向到和客户端相关联的已连接描述符。因此，任何) Tj
T*
(CGI 程序写到标准输出的东西都会直接到达客户端。) Tj
T*
() Tj
T*
(注意，因为父进程不知道子进程生成的内容的类型或大小，所以子进程就要负责生成 Content-type 和 Content-length 响应报头，以及终止报头的空行。) Tj
T*
() Tj
T*
(图 11-27 展示了一个简单的 CGI 程序，它对两个参数求和，并返回带结果的 HTML 文件给客户端。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    int main\(void\) {) Tj
T*
(        char *buf, *p;) Tj
T*
(        char arg1[MAXLINE], arg2[MAXLINE], content[MAXLINE];) Tj
T*
(        int n1 = 0, n2 = 0;) Tj
T*
() Tj
T*
(        /* Extract the two arguments */) Tj
T*
(        if \(\(buf = getenv\("QUERY_STRING"\)\) != NULL\) {) Tj
T*
(            p = strchr\(buf, ’&’\);) Tj
T*
(            *p = ’\\0’;) Tj
T*
(            strcpy\(arg1, buf\);) Tj
T*
(            strcpy\(arg2, p + 1\);) Tj
T*
(            n1 = atoi\(arg1\);) Tj
T*
(            n2 = atoi\(arg2\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        /* Make the response body */) Tj
T*
(        sprintf\(content, "QUERY_STRING=%s", buf\);) Tj
T*
(        sprintf\(content, "Welcome to add.com: "\);) Tj
T*
(        sprintf\(content, "%sTHE Internet addition portal.\\r\\n<p>", content\);) Tj
T*
(        sprintf\(content, "%sThe answer is: %d + %d = %d\\r\\n<p>",) Tj
T*
(                content, n1, n2, n1 + n2\);) Tj
T*
(        sprintf\(content, "%sThanks for visiting!\\r\\n", content\);) Tj
T*
() Tj
T*
(        /* Generate the HTTP response */) Tj
T*
ET
endstream
endobj
588 0 obj
<< /Length 2498 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        printf\("Connection: close\\r\\n"\);) Tj
T*
(        printf\("Content-length: %d\\r\\n", \(int\)strlen\(content\)\);) Tj
T*
(        printf\("Content-type: text/html\\r\\n\\r\\n"\);) Tj
T*
(        printf\("%s", content\);) Tj
T*
(        fflush\(stdout\);) Tj
T*
() Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-27 对两个整数求和的 CGI 程序) Tj
T*
() Tj
T*
(图 11-28 展示了一个 HTTP 事务，它根据 adder 程序提供动态内容。) Tj
T*
() Tj
T*
(    linux> telnet kittyhawk.cmcl.cs.cmu.edu 8000        # Client: open connection) Tj
T*
(    Trying 128.2.194.242...) Tj
T*
(    Connected to kittyhawk.cmcl.cs.cmu.edu.) Tj
T*
(    Escape character is ’^]’.) Tj
T*
(    GET /cgi-bin/adder?15000&213 HTTP/1.0               # Client: request line) Tj
T*
(                                                        # Client: empty line terminates) Tj
T*
(                                                        headers) Tj
T*
(    HTTP/1.0 200 OK                                     # Server: response line) Tj
T*
(    Server: Tiny Web Server                             # Server: identify server) Tj
T*
(    Content-length: 115                                 # Adder: expect 115 bytes in) Tj
T*
(    response body) Tj
T*
(    Content-type: text/html                             # Adder: expect HTML in response) Tj
T*
(    body) Tj
T*
(                                                        # Adder: empty line terminates) Tj
T*
(                                                        headers) Tj
T*
(    Welcome to add.com: THE Internet addition portal.   # Adder: first HTML line) Tj
T*
(    <p>The answer is: 15000 + 213 = 15213               # Adder: second HTML line in) Tj
T*
(    response body) Tj
T*
(    <p>Thanks for visiting!                             # Adder: third HTML line in) Tj
T*
(    response body) Tj
T*
(    Connection closed by foreign host.                  # Server: closes connection) Tj
T*
(    linux>                                              # Client: closes connection and) Tj
T*
(    terminates) Tj
T*
() Tj
T*
(> 图 11-28 一个提供动态 HTML 内容的 HTTP 事务) Tj
T*
() Tj
T*
(旁注 - 将 HTTP POST 请求中的参数传递给 CGI 程序) Tj
T*
() Tj
T*
() Tj
T*
(对于 POST 请求，子进程也需要重定向标准输入到已连接描述符。然后，CGI 程序会从标准输入中读取请求主体中的参数。) Tj
T*
() Tj
T*
(练习题 11.5) Tj
T*
() Tj
T*
ET
endstream
endobj
589 0 obj
<< /Length 2923 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(在 10.11 节中，我们警告过你关于在网络应用中使用 C 标准 I/O 函数的危险。然而，图 11-27 中的 CGI 程序却能没有任何问题地使用标准 I/O。为什么呢？) Tj
T*
() Tj
T*
(标准 I/O 能在 CGI 程序里工作的原因是，在子进程中运行的 CGI 程序不需要显式地关闭它的输入输出流。当子进程终止时，内核会自动关闭所有描述符。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(11.6 综合：TINY Web 服务器) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(11.6 综合：TINY Web 服务器) Tj
T*
() Tj
T*
() Tj
T*
(我们通过开发一个虽小但功能齐全的称为 TINY 的 Web 服务器来结束对网络编程的讨论。TINY 是一个有趣的程序。在短短 250) Tj
T*
(行代码中，它结合了许多我们已经学习到的思想，例如进程控制、Unix I/O、套接字接口和 HTTP。虽然它缺乏一个实际服务器所具备的功能性、健壮性和安全性，但是它足够用来为实际的) Tj
T*
(Web 浏览器提供静态和动态的内容。我们鼓励你研究它，并且自己实现它。将一个实际的浏览器指向你自己的服务器，看着它显示一个复杂的带有文本和图片的 Web) Tj
T*
(页面，真是非常令人兴奋（甚至对我们这些作者来说，也是如此！）。) Tj
T*
() Tj
T*
(1. TINY 的 main 程序) Tj
T*
() Tj
T*
() Tj
T*
(图 11-29 展示了 TINY 的主程序。TINY 是一个迭代服务器，监听在命令行中传递来的端口上的连接请求。在通过调用 open\\_listenfd) Tj
T*
(函数打开一个监听套接字以后，TINY 执行典型的无限服务器循环，不断地接受连接请求（第 32 行），执行事务（第 36 行），并关闭连接的它那一端（第 37 行）。) Tj
T*
() Tj
T*
(    /*) Tj
T*
(    * tiny.c - A simple, iterative HTTP/1.0 Web server that uses the) Tj
T*
(    * GET method to serve static and dynamic content) Tj
T*
(    */) Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void doit\(int fd\);) Tj
T*
(    void read_requesthdrs\(rio_t *rp\);) Tj
T*
(    int parse_uri\(char *uri, char *filename, char *cgiargs\);) Tj
T*
(    void serve_static\(int fd, char *filename, int filesize\);) Tj
T*
(    void get_filetype\(char *filename, char *filetype\);) Tj
T*
(    void serve_dynamic\(int fd, char *filename, char *cgiargs\);) Tj
T*
(    void clienterror\(int fd, char *cause, char *errnum,) Tj
T*
(                     char *shortmsg, char *longmsg\);) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        int listenfd, connfd;) Tj
T*
(        char hostname[MAXLINE], port[MAXLINE];) Tj
T*
(        socklen_t clientlen;) Tj
T*
(        struct sockaddr_storage clientaddr;) Tj
T*
() Tj
T*
ET
endstream
endobj
590 0 obj
<< /Length 1843 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        /* Check command-line args */) Tj
T*
(        if \(argc != 2\) {) Tj
T*
(            fprintf\(stderr, "usage: %s <port>\\n", argv[0]\);) Tj
T*
(            exit\(1\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        listenfd = Open_listenfd\(argv[1]\);) Tj
T*
(        while \(1\) {) Tj
T*
(            clientlen = sizeof\(clientaddr\);) Tj
T*
(            connfd = Accept\(listenfd, \(SA *\)&clientaddr, &clientlen\);) Tj
T*
(            Getnameinfo\(\(SA *\) &clientaddr, clientlen, hostname, MAXLINE,) Tj
T*
(                        port, MAXLINE, 0\);) Tj
T*
(            printf\("Accepted connection from \(%s, %s\)\\n", hostname, port\);) Tj
T*
(            doit\(connfd\);) Tj
T*
(            Close\(connfd\);) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-29 TINY Web 服务器) Tj
T*
() Tj
T*
(2. doit 函数) Tj
T*
() Tj
T*
() Tj
T*
(图 11-30 中的 doit 函数处理一个 HTTP 事务。) Tj
T*
() Tj
T*
(    void doit\(int fd\)) Tj
T*
(    {) Tj
T*
(        int is_static;) Tj
T*
(        struct stat sbuf;) Tj
T*
(        char buf[MAXLINE], method[MAXLINE], uri[MAXLINE], version[MAXLINE];) Tj
T*
(        char filename[MAXLINE], cgiargs[MAXLINE];) Tj
T*
(        rio_t rio;) Tj
T*
() Tj
T*
(        /* Read request line and headers */) Tj
T*
(        Rio_readinitb\(&rio, fd\);) Tj
T*
(        Rio_readlineb\(&rio, buf, MAXLINE\);) Tj
T*
(        printf\("Request headers:\\n"\);) Tj
T*
(        printf\("%s", buf\);) Tj
T*
(        sscanf\(buf, "%s %s %s", method, uri, version\);) Tj
T*
(        if \(strcasecmp\(method, "GET"\)\) {) Tj
T*
(            clienterror\(fd, method, "501", "Not implemented",) Tj
T*
(                        "Tiny does not implement this method"\);) Tj
T*
(            return;) Tj
T*
(        }) Tj
T*
(        read_requesthdrs\(&rio\);) Tj
T*
() Tj
T*
ET
endstream
endobj
591 0 obj
<< /Length 3060 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        /* Parse URI from GET request */) Tj
T*
(        is_static = parse_uri\(uri, filename, cgiargs\);) Tj
T*
(        if \(stat\(filename, &sbuf\) < 0\) {) Tj
T*
(            clienterror\(fd, filename, "404", "Not found",) Tj
T*
(                        "Tiny couldn’t find this file"\);) Tj
T*
(            return;) Tj
T*
(        }) Tj
T*
() Tj
T*
(        if \(is_static\) { /* Serve static content */) Tj
T*
(            if \(!\(S_ISREG\(sbuf.st_mode\)\) || !\(S_IRUSR & sbuf.st_mode\)\) {) Tj
T*
(                clienterror\(fd, filename, "403", "Forbidden",) Tj
T*
(                            "Tiny couldn’t read the file"\);) Tj
T*
(                return;) Tj
T*
(            }) Tj
T*
(            serve_static\(fd, filename, sbuf.st_size\);) Tj
T*
(        }) Tj
T*
(        else { /* Serve dynamic content */) Tj
T*
(            if \(!\(S_ISREG\(sbuf.st_mode\)\) || !\(S_IXUSR & sbuf.st_mode\)\) {) Tj
T*
(                clienterror\(fd, filename, "403", "Forbidden",) Tj
T*
(                            "Tiny couldn’t run the CGI program"\);) Tj
T*
(                return;) Tj
T*
(            }) Tj
T*
(            serve_dynamic\(fd, filename, cgiargs\);) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-30 TINY doit 处理一个 HTTP 事务) Tj
T*
() Tj
T*
(首先，我们读和解析请求行（第 11 ~ 14 行）。注意，我们使用图 11-8 中的 rio\\_readlineb 函数读取请求行。) Tj
T*
() Tj
T*
(TINY 只支持 GET 方法。如果客户端请求其他方法（比如 POST），我们发送给它一个错误信息，并返回到主程序（第 15 ~ 19) Tj
T*
(行），主程序随后关闭连接并等待下一个连接请求。否则，我们读并且（像我们将要看到的那样）忽略任何请求报头（第 20 行）。) Tj
T*
() Tj
T*
(然后，我们将 URI 解析为一个文件名和一个可能为空的 CGI 参数字符串，并且设置一个标志，表明请求的是静态内容还是动态内容（第 23) Tj
T*
(行）。如果文件在磁盘上不存在，我们立即发送一个错误信息给客户端并返回。) Tj
T*
() Tj
T*
(最后，如果请求的是静态内容，我们就验证该文件是一个普通文件，而我们是有读权限的（第 31 行）。如果是这样，我们就向客户端提供静态内容（第 36) Tj
T*
(行）。相似地，如果请求的是动态内容，我们就验证该文件是可执行文件（第 39 行），如果是这样，我们就继续，并且提供动态内容（第 44 行）。) Tj
T*
() Tj
T*
(3. clienterror 函数) Tj
T*
() Tj
T*
() Tj
T*
(TINY 缺乏一个实际服务器的许多错误处理特性。然而，它会检査一些明显的错误，并把它们报告给客户端。图 11-31 中的 clienterror 函数发送一个 HTTP) Tj
T*
(响应到客户端，在响应行中包含相应的状态码和状态消息，响应主体中包含一个 HTML 文件，向浏览器的用户解释这个错误。) Tj
T*
() Tj
T*
(    void clienterror\(int fd, char *cause, char *errnum,) Tj
T*
ET
endstream
endobj
592 0 obj
<< /Length 2297 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(                     char *shortmsg, char *longmsg\)) Tj
T*
(    {) Tj
T*
(        char buf[MAXLINE], body[MAXBUF];) Tj
T*
() Tj
T*
(        /* Build the HTTP response body */) Tj
T*
(        sprintf\(body, "<html><title>Tiny Error</title>"\);) Tj
T*
(        sprintf\(body, "%s<body bgcolor=""ffffff"">\\r\\n", body\);) Tj
T*
(        sprintf\(body, "%s%s: %s\\r\\n", body, errnum, shortmsg\);) Tj
T*
(        sprintf\(body, "%s<p>%s: %s\\r\\n", body, longmsg, cause\);) Tj
T*
(        sprintf\(body, "%s<hr><em>The Tiny Web server</em>\\r\\n", body\);) Tj
T*
() Tj
T*
(        /* Print the HTTP response */) Tj
T*
(        sprintf\(buf, "HTTP/1.0 %s %s\\r\\n", errnum, shortmsg\);) Tj
T*
(        Rio_writen\(fd, buf, strlen\(buf\)\);) Tj
T*
(        sprintf\(buf, "Content-type: text/html\\r\\n"\);) Tj
T*
(        Rio_writen\(fd, buf, strlen\(buf\)\);) Tj
T*
(        sprintf\(buf, "Content-length: %d\\r\\n\\r\\n", \(int\)strlen\(body\)\);) Tj
T*
(        Rio_writen\(fd, buf, strlen\(buf\)\);) Tj
T*
(        Rio_writen\(fd, body, strlen\(body\)\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-31 TINY clienterror 向客户端发送一个出错消息) Tj
T*
() Tj
T*
(回想一下，HTML 响应应该指明主体中内容的大小和类型。因此，我们选择创建 HTML 内容为一个字符串，这样一来我们可以简单地确定它的大小。还有，请注意我们为所有的输出使用的都是图) Tj
T*
(10-4 中健壮的 rio\\_writen 函数。) Tj
T*
() Tj
T*
(4. read\\_requesthdrs 函数) Tj
T*
() Tj
T*
() Tj
T*
(TINY 不使用请求报头中的任何信息。它仅仅调用图 11-32 中的 read\\_requesthdrs) Tj
T*
(函数来读取并忽略这些报头。注意，终止请求报头的空文本行是由回车和换行符对组成的，我们在第 6 行中检査它。) Tj
T*
() Tj
T*
(    void read_requesthdrs\(rio_t *rp\)) Tj
T*
(    {) Tj
T*
(        char buf[MAXLINE];) Tj
T*
() Tj
T*
(        Rio_readlineb\(rp, buf, MAXLINE\);) Tj
T*
(        while \(strcmp\(buf, "\\r\\n"\)\) {) Tj
T*
(            Rio_readlineb\(rp, buf, MAXLINE\);) Tj
T*
(            printf\("%s", buf\);) Tj
T*
(        }) Tj
T*
(        return;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-32 TINY read\\_requesthdrs 读取并忽略请求报头) Tj
T*
() Tj
T*
ET
endstream
endobj
593 0 obj
<< /Length 2411 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(5. parse\\_uri 函数) Tj
T*
() Tj
T*
() Tj
T*
(TINY 假设静态内容的主目录就是它的当前目录，而可执行文件的主目录是 ./cgi-bin。任何包含字符串 cgi-bin 的 URI) Tj
T*
(都会被认为表示的是对动态内容的请求。默认的文件名是 ./home.html。) Tj
T*
() Tj
T*
(图 11-33 中的 parse\\_uri 函数实现了这些策略。它将 URI 解析为一个文件名和一个可选的 CGI 参数字符串。如果请求的是静态内容（第 5 行），我们将清除) Tj
T*
(CGI 参数字符串（第 6 行），然后将 URI 转换为一个 Linux 相对路径名，例如 ./index.html（第 7 ~ 8 行）。如果 URI 是用结尾的（第 9) Tj
T*
(行），我们将把默认的文件名加在后面（第 10 行）。另一方面，如果请求的是动态内容（第 13 行），我们就会抽取出所有的 CGI 参数（第 14 ~ 20 行），并将 URI) Tj
T*
(剩下的部分转换为一个 Linux 相对文件名（第 21 ~ 22 行）。) Tj
T*
() Tj
T*
(    int parse_uri\(char *uri, char *filename, char *cgiargs\)) Tj
T*
(    {) Tj
T*
(        char *ptr;) Tj
T*
() Tj
T*
(        if \(!strstr\(uri, "cgi-bin"\)\) { /* Static content */) Tj
T*
(            strcpy\(cgiargs, ""\);) Tj
T*
(            strcpy\(filename, "."\);) Tj
T*
(            strcat\(filename, uri\);) Tj
T*
(            if \(uri[strlen\(uri\) - 1] == ’ / ’\)) Tj
T*
(                strcat\(filename, "home.html"\);) Tj
T*
(            return 1;) Tj
T*
(        }) Tj
T*
(        else { /* Dynamic content */) Tj
T*
(            ptr = index\(uri, ’ ? ’\);) Tj
T*
(            if \(ptr\) {) Tj
T*
(                strcpy\(cgiargs, ptr + 1\);) Tj
T*
(                *ptr = ’\\0’;) Tj
T*
(            }) Tj
T*
(            else) Tj
T*
(                strcpy\(cgiargs, ""\);) Tj
T*
(            strcpy\(filename, "."\);) Tj
T*
(            strcat\(filename, uri\);) Tj
T*
(            return 0;) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-33 TINY parse\\_uri 解析一个 HTTP URI) Tj
T*
() Tj
T*
(6. serve\\_static 函数) Tj
T*
() Tj
T*
() Tj
T*
(TINY 提供五种常见类型的静态内容：HTML 文件、无格式的文本文件，以及编码为 GIF、PNG 和 JPG 格式的图片。) Tj
T*
() Tj
T*
(图 11-34 中的 serve\\_static 函数发送一个 HTTP 响应，其主体包含一个本地文件的内容。) Tj
T*
() Tj
T*
ET
endstream
endobj
594 0 obj
<< /Length 2374 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    void serve_static\(int fd, char *filename, int filesize\)) Tj
T*
(    {) Tj
T*
(        int srcfd;) Tj
T*
(        char *srcp, filetype[MAXLINE], buf[MAXBUF];) Tj
T*
() Tj
T*
(        /* Send response headers to client */) Tj
T*
(        get_filetype\(filename, filetype\);) Tj
T*
(        sprintf\(buf, "HTTP/1.0 200 OK\\r\\n"\);) Tj
T*
(        sprintf\(buf, "%sServer: Tiny Web Server\\r\\n", buf\);) Tj
T*
(        sprintf\(buf, "%sConnection: close\\r\\n", buf\);) Tj
T*
(        sprintf\(buf, "%sContent-length: %d\\r\\n", buf, filesize\);) Tj
T*
(        sprintf\(buf, "%sContent-type: %s\\r\\n\\r\\n", buf, filetype\);) Tj
T*
(        Rio_writen\(fd, buf, strlen\(buf\)\);) Tj
T*
(        printf\("Response headers:\\n"\);) Tj
T*
(        printf\("%s", buf\);) Tj
T*
() Tj
T*
(        /* Send response body to client */) Tj
T*
(        srcfd = Open\(filename, O_RDONLY, 0\);) Tj
T*
(        srcp = Mmap\(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0\);) Tj
T*
(        Close\(srcfd\);) Tj
T*
(        Rio_writen\(fd, srcp, filesize\);) Tj
T*
(        Munmap\(srcp, filesize\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /*) Tj
T*
(    * get_filetype - Derive file type from filename) Tj
T*
(    */) Tj
T*
(    void get_filetype\(char *filename, char *filetype\)) Tj
T*
(    {) Tj
T*
(        if \(strstr\(filename, ".html"\)\)) Tj
T*
(            strcpy\(filetype, "text/html"\);) Tj
T*
(        else if \(strstr\(filename, ".gif"\)\)) Tj
T*
(            strcpy\(filetype, "image/gif"\);) Tj
T*
(        else if \(strstr\(filename, ".png"\)\)) Tj
T*
(            strcpy\(filetype, "image/png"\);) Tj
T*
(        else if \(strstr\(filename, ".jpg"\)\)) Tj
T*
(            strcpy\(filetype, "image/jpeg"\);) Tj
T*
(        else) Tj
T*
(            strcpy\(filetype, "text/plain"\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-34 TINY serve\\_static 为客户端提供静态内容) Tj
T*
() Tj
T*
(首先，我们通过检査文件名的后缀来判断文件类型（第 7 行），并且发送响应行和响应报头给客户端（第 8 ~ 13 行）。注意用一个空行终止报头。) Tj
T*
() Tj
T*
(接着，我们将被请求文件的内容复制到已连接描述符 fd 来发送响应主体。这里的代码是比较微妙的，需要仔细研究。第 18 行以读方式打开 filename，并获得它的描述符。在第 19) Tj
T*
ET
endstream
endobj
595 0 obj
<< /Length 3412 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(行，Linux mmap 函数将被请求文件映射到一个虚拟内存空间。回想我们在第 9.8 节中对 remap 的讨论，调用 mmap 将文件 srcfd 的前 filesize) Tj
T*
(个字节映射到一个从地址 srcp 开始的私有只读虚拟内存区域。) Tj
T*
() Tj
T*
(一旦将文件映射到内存，就不再需要它的描述符了，所以我们关闭这个文件（第 20 行）。执行这项任务失败将导致潜在的致命的内存泄漏。第 21) Tj
T*
(行执行的是到客户端的实际文件传送。rio\\_writen 函数复制从 srcp 位置开始的 filesize) Tj
T*
(个字节（它们当然已经被映射到了所请求的文件）到客户端的已连接描述符。最后，第 22 行释放了映射的虚拟内存区域。这对于避免潜在的致命的内存泄漏是很重要的。) Tj
T*
() Tj
T*
(7. serve\\_dynamic 函数) Tj
T*
() Tj
T*
() Tj
T*
(TINY 通过派生一个子进程并在子进程的上下文中运行一个 CGI 程序，来提供各种类型的动态内容。) Tj
T*
() Tj
T*
(图 11-35 中的 serve\\_dynamic 函数一开始就向客户端发送一个表明成功的响应行，同时还包括带有信息的 Server 报头。CGI) Tj
T*
(程序负责发送响应的剩余部分。注意，这并不像我们可能希望的那样健壮，因为它没有考虑到 CGI 程序会遇到某些错误的可能性。) Tj
T*
() Tj
T*
(    void serve_dynamic\(int fd, char *filename, char *cgiargs\)) Tj
T*
(    {) Tj
T*
(        char buf[MAXLINE], *emptylist[] = { NULL };) Tj
T*
() Tj
T*
(        /* Return first part of HTTP response */) Tj
T*
(        sprintf\(buf, "HTTP/1.0 200 OK\\r\\n"\);) Tj
T*
(        Rio_writen\(fd, buf, strlen\(buf\)\);) Tj
T*
(        sprintf\(buf, "Server: Tiny Web Server\\r\\n"\);) Tj
T*
(        Rio_writen\(fd, buf, strlen\(buf\)\);) Tj
T*
() Tj
T*
(        if \(Fork\(\) == 0\) { /* Child */) Tj
T*
(            /* Real server would set all CGI vars here */) Tj
T*
(            setenv\("QUERY_STRING", cgiargs, 1\);) Tj
T*
(            Dup2\(fd, STDOUT_FILENO\); /* Redirect stdout to client */) Tj
T*
(            Execve\(filename, emptylist, environ\); /* Run CGI program */) Tj
T*
(        }) Tj
T*
(        Wait\(NULL\); /* Parent waits for and reaps child */) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 11-35 TINY serve\\_dynamic 为客户端提供动态内容) Tj
T*
() Tj
T*
(在发送了响应的第一部分后，我们会派生一个新的子进程（第 11 行）。子进程用来自请求 URI 的 CGI 参数初始化 QUERY\\_STRING 环境变量（第 13) Tj
T*
(行）。注意，一个真正的服务器还会在此处设置其他的 CGI 环境变量。为了简短，我们省略了这一步。) Tj
T*
() Tj
T*
(接下来，子进程重定向它的标准输出到已连接文件描述符（第 14 行），然后加载并运行 CGI 程序（第 15 行）。因为 CGI 程序运行在子进程的上下文中，它能够访问所有在调用) Tj
T*
(ex¬ecve 函数之前就存在的打开文件和环境变量。因此，CGI 程序写到标准输出上的任何东西都将直接送到客户端进程，不会受到任何来自父进程的干涉。其间，父进程阻塞在对 wait) Tj
T*
(的调用中，等待当子进程终止的时候，回收操作系统分配给子进程的资源（第 17 行）。) Tj
T*
() Tj
T*
(旁注 - 处理过早关闭的连接) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
596 0 obj
<< /Length 4309 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(尽管一个 Web 服务器的基本功能非常简单，但是我们不想给你一个假象，以为编写一个实际的 Web 服务器是非常简单的。构造一个长时间运行而不崩溃的健壮的 Web) Tj
T*
(服务器是一件困难的任务，比起在这里我们已经学习了的内容，它要求对 Linux) Tj
T*
(系统编程有更加深入的理解。例如，如果一个服务器写一个已经被客户端关闭了的连接（比如，因为你在浏览器上单击了 “Stop”) Tj
T*
(按钮），那么第一次这样的写会正常返回，但是第二次写就会引起发送 SIGPIPE 信号，这个信号的默认行为就是终止这个进程。如果捕获或者忽略 SIGPIPE) Tj
T*
(信号，那么第二次写操作会返回值 -1，并将 errno 设置为 EPIPE。strerr 和 perror 函数将 EPIPE 错误报告为 “Broken) Tj
T*
(pipe”，这是一个迷惑了很多人的不太直观的信息。总的来说，一个健壮的服务器必须捕获这些 SIGPIPE 信号，并且检查 write 函数调用是否有 EPIPE 错误。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(11.7 小结) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(11.7 小结) Tj
T*
() Tj
T*
() Tj
T*
(每个网络应用都是基于客户端—服务器模型的。根据这个模型，一个应用是由一个服务器和一个或多个客户端组成的。服务器管理资源，以某种方式操作资源，为它的客户端提供服务。客户端—服务器模型) Tj
T*
(中的基本操作是客户端—服务器事务，它是由客户端请求和跟随其后的服务器响应组成的。) Tj
T*
() Tj
T*
(客户端和服务器通过因特网这个全球网络来通信。从程序员的观点来看，我们可以把因特网看成是一个全球范围的主机集合，具有以下几个属性：) Tj
T*
() Tj
T*
(1. 每个因特网主机都有一个唯一的 32 位名字，称为它的 IP 地址。) Tj
T*
(2. IP 地址的集合被映射为一个因特网域名的集合。) Tj
T*
(3. 不同因特网主机上的进程能够通过连接互相通信。) Tj
T*
() Tj
T*
(客户端和服务器通过使用套接字接口建立连接。一个套接字是连接的一个端点，连接以文件描述符的形式提供给应用程序。套接字接口提供了打开和关闭套接字描述符的函数。客户端和服务器通过读写这些) Tj
T*
(描述符来实现彼此间的通信。) Tj
T*
() Tj
T*
(Web 服务器使用 HTTP 协议和它们的客户端（例如浏览器）彼此通信。浏览器向服务器请求静态或者动态的内容。对静态内容的请求是通过从服务器磁盘取得文件并把它返回给客户端来服务的。) Tj
T*
(对动态内容的请求是通过在服务器上一个子进程的上下文中运行一个程序并将它的输出返回给客户端来服务的。CGI) Tj
T*
(标准提供了一组规则，来管理客户端如何将程序参数传递给服务器，服务器如何将这些参数以及其他信息传递给子进程，以及子进程如何将它的输岀发送回客户端。只用几百行 C) Tj
T*
(代码就能实现一个简单但是有功效的 Web 服务器，它既可以提供静态内容，也可以提供动态内容。) Tj
T*
() Tj
T*
(参考文献说明) Tj
T*
() Tj
T*
() Tj
T*
(有关因特网的官方信息源被保存在一系列的可免费获取的带编号的文档中，称为 RFC（Requests for Comments，请求注解，Internet) Tj
T*
(标准（草案））。在以下网站可获得可搜索的 RFC 的索引：) Tj
T*
() Tj
T*
(http://rfc-editor.org) Tj
T*
() Tj
T*
(RFC 通常是为因特网基础设施的开发者编写的，因此，对于普通读者来说，往往过于详细了。然而，要想获得权威信息，没有比它更好的信息来源了。HTTP/1.1 协议记录在 RFC2616) Tj
T*
(中。MIME 类型的权威列表保存在：) Tj
T*
() Tj
T*
(http://www.iana.org/assignments/media-types) Tj
T*
() Tj
T*
(Kerrisk 是全面 Linux 编程的圣经，提供了现代网络编程的详细讨论【62】。关于计算机网络互联有大量很好的通用文献【65，84，114 】。伟大的科技作家 W.) Tj
T*
ET
endstream
endobj
597 0 obj
<< /Length 2272 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(Richard Stevens 编写了一系列相关的经典文献，如髙级 Unix 编程【111】、因特网协议【109，120，107】，以及 Unix) Tj
T*
(网络编程【108，110】。认真学习 Unix 系统编程的学生会想要研究所有这些内容。不幸的是，Stevens 在 1999 年 9 月 1 日逝世。我们会永远纪住他的贡献。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(家庭作业) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(家庭作业) Tj
T*
() Tj
T*
() Tj
T*
(练习题 11.6) Tj
T*
() Tj
T*
() Tj
T*
(A. 修改 TINY 使得它会原样返回每个请求行和请求报头。) Tj
T*
() Tj
T*
(B. 使用你喜欢的浏览器向 TINY 发送一个对静态内容的请求。把 TINY 的输出记录到一个文件中。) Tj
T*
() Tj
T*
(C. 检查 TINY 的输出，确定你的浏览器使用的 HTTP 的版本。) Tj
T*
() Tj
T*
(D. 参考 RFC 2616 中的 HTTP/1.1 标准，确定你的浏览器的 HTTP 请求中每个报头的含义。你可以从 www.rfc-editor.org/rfc.html 获得) Tj
T*
(RFC 2616。) Tj
T*
() Tj
T*
(练习题 11.7) Tj
T*
() Tj
T*
() Tj
T*
(扩展 TINY，使得它可以提供 MPG 视频文件。用一个真正的浏览器来检验你的工作。) Tj
T*
() Tj
T*
(练习题 11.8) Tj
T*
() Tj
T*
() Tj
T*
(修改 TINY，使得它在 SIGCHLD 处理程序中回收操作系统分配给 CGI 子进程的资源，而不是显式地等待它们终止。) Tj
T*
() Tj
T*
(练习题 11.9) Tj
T*
() Tj
T*
() Tj
T*
(修改 TINY，使得当它服务静态内容时，使用 malloc、rio\\readn 和而不是 mmap 和 rio\\writen 来复制被请求文件到已连接描述符。) Tj
T*
() Tj
T*
(练习题 11.10) Tj
T*
() Tj
T*
() Tj
T*
(A. 写出图 11-27 中 CGI adder 函数的 HTML 表单。你的表单应謗包括两个文本框，用户将需要相加的两个数字填在这两个文本框中。你的表单应该使用 GET) Tj
T*
(方法请求内容。) Tj
T*
() Tj
T*
(B. 用这样的方法来检查你的程序：使用一个真正的浏览器向 TINY 请求表单，向 TINY 提交填写好的表单，然后显示 adder 生成的动态内容。) Tj
T*
() Tj
T*
ET
endstream
endobj
598 0 obj
<< /Length 4000 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(练习题 11.11) Tj
T*
() Tj
T*
() Tj
T*
(扩展 TINY，以支持 HTTP HEAD 方法。使用 TELNET 作为 Web 客户端来验证你的工作。) Tj
T*
() Tj
T*
(练习题 11.12) Tj
T*
() Tj
T*
() Tj
T*
(扩展 TINY，使得它服务以 HTTP POST 方式请求的动态内容。用你喜欢的 Web 浏览器来验证你的工作。) Tj
T*
() Tj
T*
(练习题 11.13) Tj
T*
() Tj
T*
() Tj
T*
(修改 TINY，使得它可以干净地处理（而不是终止）在 write 函数试图写一个过早关闭的连接时发生的 SIGPIPE 信号和 EPIPE 错误。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(第 12 章：并发编程) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(第 12 章：并发编程) Tj
T*
() Tj
T*
() Tj
T*
(正如我们在第 8 章学到的，如果逻辑控制流在时间上重叠，那么它们就是并发的（concurrent）。这种常见的现象称为并发（concurrency），出现在计算机系统的许多不同层面) Tj
T*
(上。硬件异常处理程序、进程和 Linux 信号处理程序都是大家很熟悉的例子。) Tj
T*
() Tj
T*
(到目前为止，我们主要将并发看做是一种操作系统内核用来运行多个应用程序的机制。但是，并发不仅仅局限于内核。它也可以在应用程序中扮演重要角色。例如，我们已经看到 Linux) Tj
T*
(信号处理程序如何允许应用响应异步事件，例如用户键入 Ctrl+C，或者程序访问虚拟内存的一个未定义的区域。应用级并发在其他情况下也是很有用的：) Tj
T*
() Tj
T*
(* 访问慢速 I/O 设备。当一个应用正在等待来自慢速 I/O 设备（例如磁盘）的数据到达时，内核会运行其他进程，使 CPU 保持繁忙。每个应用都可以按照类似的方式，通过交替执行) Tj
T*
(I/O 请求和其他有用的工作来利用并发。) Tj
T*
(* 与人交互。和计算机交互的人要求计算机有同时执行多个任务的能力。例如，他们在打印一个文档时，可能想要调整一个窗口的大小。现代视窗系统利用并发来提供这种能力。每次用户请求某种操作（) Tj
T*
(比如通过单击鼠标）时，一个独立的并发逻辑流被创建来执行这个操作。) Tj
T*
(* 通过推迟工作以降低延迟。有时，应用程序能够通过推迟其他操作和并发地执行它们，利用并发来降低某些操作的延迟。比如，一个动态内存分配器可以通过推迟合并，把它放到一个运行在较低优先级) Tj
T*
(上的并发 “合并” 流中，在有空闲的 CPU 周期时充分利用这些空闲周期，从而降低单个 free 操作的延迟。) Tj
T*
(* 服务多个网络客户端。我们在第 11 章中学习的迭代网络服务器是不现实的，因为它们一次只能为一个客户端提供服务。因此，一个慢速的客户端可能会导致服务器拒绝为所有其他客户端服务。对) Tj
T*
(于一个真正的服务器来说，可能期望它每秒为成百上千的客户端提供服务，由于一个慢速客户端导致拒绝为其他客户端服务，这是不能接受的。一个更好的方法是创建一个并发服务器，它为每个客户端创建) Tj
T*
(一个单独的逻辑流。这就允许服务器同时为多个客户端服务，并且也避免了慢速客户端独占服务器。) Tj
T*
(* 在多核机器上进行并行计算。许多现代系统都配备多核处理器，多核处理器中包含有多个) Tj
T*
(CPU。被划分成并发流的应用程序通常在多核机器上比在单处理器机器上运行得快，因为这些流会并行执行，而不是交错执行。) Tj
T*
() Tj
T*
(使用应用级并发的应用程序称为并发程序（concurrent program）。现代操作系统提供了三种基本的构造并发程序的方法：) Tj
T*
ET
endstream
endobj
599 0 obj
<< /Length 4023 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(* 进程。用这种方法，每个逻辑控制流都是一个进程，由内核来调度和维护。因为进程有独立的虚拟地址空间，想要和其他流通信，控制流必须使用某种显式的进程间通信（interprocessc) Tj
T*
(ommunication，IPC）机制。) Tj
T*
(* I/O 多路复用。在这种形式的并发编程中，应用程序在一个进程的上下文中显式地调度它们自己的逻辑流。逻辑流被模型化为状态机，数据到达文件描述符后，主程序显式地从一个状态转换到另一) Tj
T*
(个状态。因为程序是一个单独的进程，所以所有的流都共享同一个地址空间。) Tj
T*
(* 线程。线程是运行在一个单一进程上下文中的逻辑流，由内核进行调度。你可以把线程看成是其他两种方式的混合体，像进程流一样由内核进行调度，而像) Tj
T*
(I/。多路复用流一样共享同一个虚拟地址空间。) Tj
T*
() Tj
T*
(本章研究这三种不同的并发编程技术。为了使我们的讨论比较具体，我们始终以同一个应用为例——11.4.9 节中的迭代 echo 服务器的并发版本。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(12.1 基于进程的并发编程) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(12.1 基于进程的并发编程) Tj
T*
() Tj
T*
() Tj
T*
(构造并发程序最简单的方法就是用进程，使用那些大家都很熟悉的函数，像 fork、exec 和) Tj
T*
(waitpid。例如，一个构造并发服务器的自然方法就是，在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个新客户端提供服务。) Tj
T*
() Tj
T*
(为了了解这是如何工作的，假设我们有两个客户端和一个服务器，服务器正在监听一个监听描述符（比如指述符 3）上的连接请求。现在假设服务器接受了客户端 1) Tj
T*
(的连接请求，并返回一个已连接描述符（比如指述符 4），如图 12-1) Tj
T*
(所示。在接受连接请求之后，服务器派生一个子进程，这个子进程获得服务器描述符表的完整副本。子进程关闭它的副本中的监听描述符 3，而父进程关闭它的已连接描述符 4) Tj
T*
(的副本，因为不再需要这些描述符了。) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-1 &#x7B2C;&#x4E00;&#x6B65;&#xFF1A;&#x670D;&#x52A1;&#x5668;&#x63A5;&#x5) Tj
T*
(3D7;&#x5BA2;&#x6237;&#x7AEF;&#x7684;&#x8FDE;&#x63A5;&#x8BF7;&#x6C42;]) Tj
T*
() Tj
T*
(这就得到了图 12-2 中的状态，其中子进程正忙于为客户端提供服务。) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-2 &#x7B2C;&#x4E8C;&#x6B65;&#xFF1A;&#x670D;&#x52A1;&#x5668;&#x6D3E;&#x7) Tj
T*
(51F;&#x4E00;&#x4E2A;&#x5B50;&#x8FDB;&#x7A0B;&#x4E3A;&#x8FD9;&#x4E2A;&#x5BA2;&#x6237;&#x7AE) Tj
T*
(F;&#x670D;&#x52A1;]) Tj
T*
() Tj
T*
(因为父、子进程中的已连接描述符都指向同一个文件表表项，所以父进程关闭它的已连接描述符的副本是至关重要的。否则，将永不会释放已连接描述符 4) Tj
T*
(的文件表条目，而且由此引起的内存泄漏将最终消耗光可用的内存，使系统崩溃。) Tj
T*
() Tj
T*
(现在，假设在父进程为客户端 1 创建了子进程之后，它接受一个新的客户端 2 的连接请求，并返回一个新的已连接描述符（比如描述符 5），如图 12-3 所示。) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-3 &#x7B2C;&#x4E09;&#x6B65;&#xFF1A;&#x670D;&#x52A1;&#x5668;&#x63A5;&#x5) Tj
T*
(3D7;&#x53E6;&#x4E00;&#x4E2A;&#x8FDE;&#x63A5;&#x8BF7;&#x6C42;]) Tj
T*
() Tj
T*
(然后，父进程又派生另一个子进程，这个子进程用已连接描述符 5 为它的客户端提供服务，如图 12-4) Tj
T*
(所示。此时，父进程正在等待下一个连接请求，而两个子进程正在并发地为它们各自的客户端提供服务。) Tj
T*
() Tj
T*
ET
endstream
endobj
600 0 obj
<< /Length 1950 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
([Image: &#x56FE; 12-4 &#x7B2C;&#x56DB;&#x6B65;&#xFF1A;&#x670D;&#x52A1;&#x5668;&#x6D3E;&#x7) Tj
T*
(51F;&#x53E6;&#x4E00;&#x4E2A;&#x5B50;&#x8FDB;&#x7A0B;&#x4E3A;&#x65B0;&#x7684;&#x5BA2;&#x623) Tj
T*
(7;&#x7AEF;&#x670D;&#x52A1;]) Tj
T*
() Tj
T*
(12.1.1 基于进程的并发服务器) Tj
T*
() Tj
T*
() Tj
T*
(图 12-5 展示了一个基于进程的并发 echo 服务器的代码。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    void echo\(int connfd\);) Tj
T*
() Tj
T*
(    void sigchld_handler\(int sig\)) Tj
T*
(    {) Tj
T*
(        while \(waitpid\(-1, 0, WNOHANG\) > 0\)) Tj
T*
(            ;) Tj
T*
(        return;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        int listenfd, connfd;) Tj
T*
(        socklen_t clientlen;) Tj
T*
(        struct sockaddr_storage clientaddr;) Tj
T*
() Tj
T*
(        if \(argc != 2\) {) Tj
T*
(            fprintf\(stderr, "usage: %s <port>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
() Tj
T*
(        Signal\(SIGCHLD, sigchld_handler\);) Tj
T*
(        listenfd = Open_listenfd\(argv[1]\);) Tj
T*
(        while \(1\) {) Tj
T*
(            clientlen = sizeof\(struct sockaddr_storage\);) Tj
T*
(            connfd = Accept\(listenfd, \(SA *\) &clientaddr, &clientlen\);) Tj
T*
(            if \(Fork\(\) == 0\) {) Tj
T*
(                Close\(listenfd\); /* Child closes its listening socket */) Tj
T*
(                echo\(connfd\);    /* Child services client */) Tj
T*
(                Close\(connfd\);   /* Child closes connection with client */) Tj
T*
(                exit\(0\);         /* Child exits */) Tj
T*
(            }) Tj
T*
(            Close\(connfd\); /* Parent closes connected socket \(important!\) */) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-5 基于进程的并发 echo 服务器。父进程派生一个子进程来处理每个新的连接请求) Tj
T*
ET
endstream
endobj
601 0 obj
<< /Length 3734 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(第 29 行调用的 echo 函数来自于图 11-21。关于这个服务器，有几点重要内容需要说明：) Tj
T*
() Tj
T*
(* 首先，通常服务器会运行很长的时间，所以我们必须要包括一个 SIGCHLD 处理程序，来回收僵死（zombie）子进程的资源（第 4~9 行）。因为当 SIGCHLD) Tj
T*
(处理程序执行时，SIGCHLD 信号是阻塞的，而 Linux 信号是不排队的，所以 SIGCHLD 处理程序必须准备好回收多个僵死子进程的资源。) Tj
T*
(* 其次，父子进程必须关闭它们各自的 connfd（分别为第 33 行和第 30) Tj
T*
(行）副本。就像我们已经提到过的，这对父进程而言尤为重要，它必须关闭它的已连接描述符，以避免内存泄漏。) Tj
T*
(* 最后，因为套接字的文件表表项中的引用计数，直到父子进程的 connfd 都关闭了，到客户端的连接才会终止。) Tj
T*
() Tj
T*
(12.1.2 进程的优劣) Tj
T*
() Tj
T*
() Tj
T*
(对于在父、子进程间共享状态信息，进程有一个非常清晰的模型：共享文件表，但是不共享用户地址空间。进程有独立的地址空间既是优点也是缺点。这样一来，一个进程不可能不小心覆盖另一个进程的虚) Tj
T*
(拟内存，这就消除了许多令人迷惑的错误一一这是一个明显的优点。) Tj
T*
() Tj
T*
(另一方面，独立的地址空间使得进程共享状态信息变得更加困难。为了共享信息，它们必须使用显式的) Tj
T*
(IPC（进程间通信）机制。（参见下面的旁注。）基于进程的设计的另一个缺点是，它们往往比较慢，因为进程控制和 IPC 的开销很高。) Tj
T*
() Tj
T*
(旁注 - Unix IPC) Tj
T*
() Tj
T*
() Tj
T*
(在本书中，你已经遇到好几个 IPC 的例子了。第 8 章中的 waitpid 函数和信号是基本的 IPC 机制，它们允许进程发送小消息到同一主机上的其他进程。第 11) Tj
T*
(章的套接字接口是 IPC 的一种重要形式，它允许不同主机上的进程交换任意的字节流。然而，术语 UnixIPC) Tj
T*
(通常指的是所有允许进程和同一台主机上其他进程进行通信的技术。其中包括管道、先进先出（FIFO）、系统 V 共享内存，以及系统 V) Tj
T*
(信号量（semaphore）。这些机制超出了我们的讨论范围。Kerrisk 的著作【62】是很好的参考资料。) Tj
T*
() Tj
T*
(练习题 12.1) Tj
T*
() Tj
T*
() Tj
T*
(在图 12-5 中，并发服务器的第 33 行上，父进程关闭了已连接描述符后，子进程仍然能够使用该描述符和客户端通信。为什么？) Tj
T*
() Tj
T*
(当父进程派生子进程时，它得到一个已连接描述符的副本，并将相关文件表中的引用计数从 1 增加到 2。当父进程关闭它的描述符副本时，引用计数就从 2 减少到) Tj
T*
(1。因为内核不会关闭一个文件，直到文件表中它的引用计数值变为零，所以子进程这边的连接端将保持打开。) Tj
T*
() Tj
T*
(练习题 12.2) Tj
T*
() Tj
T*
() Tj
T*
(如果我们要删除图 12-5 中关闭已连接描述符的第 30 行，从没有内存泄漏的角度来说，代码将仍然是正确的。为什么？) Tj
T*
() Tj
T*
(当一个进程因为某种原因终止时，内核将关闭所有打开的描述符。因此，当子进程退出时，它的已连接文件描述符的副本也将被自动关闭。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(12.2 基于 I/O 多路复用的并发编程) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
ET
endstream
endobj
602 0 obj
<< /Length 3708 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(12.2 基于 I/O 多路复用的并发编程) Tj
T*
() Tj
T*
() Tj
T*
(假设要求你编写一个 echo 服务器，它也能对用户从标准输入键入的交互命令做出响应。在这种情况下，服务器必须响应两个互相独立的 I/O) Tj
T*
(事件：1）网络客户端发起连接请求，2）用户在键盘上键入命令行。我们先等待哪个事件呢？没有哪个选择是理想的。如果在 accept) Tj
T*
(中等待一个连接请求，我们就不能响应输入的命令。类似地，如果在 read 中等待一个输入命令，我们就不能响应任何连接请求。) Tj
T*
() Tj
T*
(针对这种困境的一个解决办法就是 I/O 多路复用（I/O multiplexing）技术。基本的思路就是使用 select 函数，要求内核挂起进程，只有在一个或多个I/O) Tj
T*
(事件发生后，才将控制返回给应用程序，就像在下面的示例中一样：) Tj
T*
() Tj
T*
(* 当集合 {0，4} 中任意描述符准备好读时返回。) Tj
T*
(* 当集合 {1，2，7} 中任意描述符准备好写时返回。) Tj
T*
(* 如果在等待一个 I/O 事件发生时过了 152.13 秒，就超时。) Tj
T*
() Tj
T*
(select 是一个复杂的函数，有许多不同的使用场景。我们将只讨论第一种场景：等待一组描述符准备好读。全面的讨论请参考【62，110】。) Tj
T*
() Tj
T*
(    #include <sys/select.h>) Tj
T*
() Tj
T*
(    int select\(int n, fd_set *fdset, NULL, NULL, NULL\);) Tj
T*
(    // 返回已准备好的描述符的非零的个数，若出错则为 -1。) Tj
T*
() Tj
T*
(    FD_ZERO\(fd_set *fdset\);           /* Clear all bits in fdset */) Tj
T*
(    FD_CLR\(int fd, fd_set *fdset\);    /* Clear bit fd in fdset */) Tj
T*
(    FD_SET\(int fd, fd_set *fdset\);    /* Turn on bit fd in fdset */) Tj
T*
(    FD_ISSET\(int fd, fd_set *fdset\);  /* Is bit fd in fdset on? */) Tj
T*
(    // 处理描述符集合的宏。) Tj
T*
() Tj
T*
(select 函数处理类型为 fd\\_set 的集合，也叫做描述符集合。逻辑上，我们将描述符集合看成一个大小为 n 的位向量（在 2.1 节中介绍过）：) Tj
T*
() Tj
T*
($$) Tj
T*
(b{n-1},\\cdots,b1,b_0) Tj
T*
($$) Tj
T*
() Tj
T*
(每个位$$\\small bk$$对应于描述符 k。当且仅当$$\\small bk = 1$$，描述符 k) Tj
T*
(才表明是描述符集合的一个元素。只允许你对描述符集合做三件事：1）分配它们，2）将一个此种类型的变量赋值给另一个变量，3）用 FD\\ZERO、FD\\SET、FD\\CLR 和) Tj
T*
(FD\\ISSET 宏来修改和检查它们。) Tj
T*
() Tj
T*
(针对我们的目的，select 函数有两个输入：一个称为读集合的描述符集合（fdset）和该读集合的基数（n）（实际上是任何描述符集合的最大基数）。select) Tj
T*
(函数会一直阻塞，直到读集合中至少有一个描述符准备好可以读。当且仅当一个从该描述符读取一个字节的请求不会阻塞时，描述符 k 就表示准备好可以读了。select) Tj
T*
(有一个副作用，它修改参数 fdset 指向的 fd\\_set，指明读集合的一个子集，称为准备好集合（ready) Tj
T*
(set），这个集合是由读集合中准备好可以读了的描述符组成的。该函数返回的值指明了准备好集合的基数。注意，由于这个副作用，我们必须在每次调用 select 时都更新读集合。) Tj
T*
() Tj
T*
(理解 select 的最好办法是研究一个具体例子。图 12-6 展示了可以如何利用 select 来实现一个迭代 echo 服务器，它也可以接受标准输入上的用户命令。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    void echo\(int connfd\);) Tj
T*
ET
endstream
endobj
603 0 obj
<< /Length 2099 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    void command\(void\);) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        int listenfd, connfd;) Tj
T*
(        socklen_t clientlen;) Tj
T*
(        struct sockaddr_storage clientaddr;) Tj
T*
(        fd_set read_set, ready_set;) Tj
T*
() Tj
T*
(        if \(argc != 2\) {) Tj
T*
(            fprintf\(stderr, "usage: %s <port>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
(        listenfd = Open_listenfd\(argv[1]\);) Tj
T*
() Tj
T*
(        FD_ZERO\(&read_set\);              /* Clear read set */) Tj
T*
(        FD_SET\(STDIN_FILENO, &read_set\); /* Add stdin to read set */) Tj
T*
(        FD_SET\(listenfd, &read_set\);     /* Add listenfd to read set */) Tj
T*
() Tj
T*
(        while \(1\) {) Tj
T*
(            ready_set = read_set;) Tj
T*
(            Select\(listenfd + 1, &ready_set, NULL, NULL, NULL\);) Tj
T*
(            if \(FD_ISSET\(STDIN_FILENO, &ready_set\)\)) Tj
T*
(                command\(\); /* Read command line from stdin */) Tj
T*
(            if \(FD_ISSET\(listenfd, &ready_set\)\) {) Tj
T*
(                clientlen = sizeof\(struct sockaddr_storage\);) Tj
T*
(                connfd = Accept\(listenfd, \(SA *\)&clientaddr, &clientlen\);) Tj
T*
(                echo\(connfd\); /* Echo client input until EOF */) Tj
T*
(                Close\(connfd\);) Tj
T*
(            }) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(    void command\(void\) {) Tj
T*
(        char buf[MAXLINE];) Tj
T*
(        if \(!Fgets\(buf, MAXLINE, stdin\)\)) Tj
T*
(            exit\(0\); /* EOF */) Tj
T*
(        printf\("%s", buf\); /* Process the input command */) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-6 使用 I/O 多路复用的迭代 echo 服务器。服务器使用 select 等待监听描述符上的连接请求和标准输人上的命令) Tj
T*
() Tj
T*
(一开始，我们用图 11-19 中的 open\\listenfd 函数打开一个监听描述符（第 16 行），然后使用 FD\\ZERO 创建一个空的读集合（第 18 行）：) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
ET
endstream
endobj
604 0 obj
<< /Length 4824 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(接下来，在第 19 和 20 行中，我们定义由描述符 0（标准输入）和描述符 3（监听描述符）组成的读集合：) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(在这里，我们开始典型的服务器循环。但是我们不调用 accept 函数来等待一个连接请求，而是调用 select 函数，这个函数会一直阻塞，直到监听描述符或者标准输入准备好可以读（第) Tj
T*
(24 行）。例如，下面是当用户按回车键，因此使得标准输入描述符变为可读时，select 会返回的 ready\\_set 的值：) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(一旦 select 返回，我们就用 FD\\_ISSET 宏指令来确定哪个描述符准备好可以读了。如果是标准输入准备好了（第 25 行），我们就调用 command) Tj
T*
(函数，该函数在返回到主程序前，会读、解析和响应命令。如果是监听描述符准备好了（第 27 行），我们就调用 accept 来得到一个已连接描述符，然后调用图 11-22 中的) Tj
T*
(echo 函数，它会将来自客户端的每一行又回送回去，直到客户端关闭这个连接中它的那一端。) Tj
T*
() Tj
T*
(虽然这个程序是使用 select 的一个很好示例，但是它仍然留下了一些问题待解决。问题是一旦它连接到某个客户端，就会连续回送输入行，直到客户端关闭这个连接中它的那一端。因此，如果键) Tj
T*
(入一个命令到标准输入，你将不会得到响应，直到服务器和客户端之间结 束。一个更好的方法是更细粒度的多路复用，服务器每次循环（至多）回送一个文本行。) Tj
T*
() Tj
T*
(练习题 12.3) Tj
T*
() Tj
T*
() Tj
T*
(在 Linux 系统里，在标准输入上键入 Ctrl+D 表示 EOF。图 12-6 中的程序阻塞在对 select 的调用上时，如果你键入 Ctrl+D 会发生什么？) Tj
T*
() Tj
T*
(回想一下，如果一个从描述符中读一个字节的请求不会阻塞，那么这个描述符就准备好可以读了。假如 EOF) Tj
T*
(在一个描述符上为真，那么描述符也准备好可读了，因为读操作将立即返回一个零返回码，表示 EOF。因此，键入 Ctrl+D 会导致 select 函数返回，准备好的集合中有描述符 0。) Tj
T*
() Tj
T*
(12.2.1 基于 I/O 多路复用的并发事件驱动服务器) Tj
T*
() Tj
T*
() Tj
T*
(I/O 多路复用可以用做并发事件驱动（event-) Tj
T*
(driven）程序的基础，在事件驱动程序中，某些事件会导致流向前推进。一般的思路是将逻辑流模型化为状态机。不严格地说，一个状态机（state) Tj
T*
(machine）就是一组状态（state）、输入事件（input) Tj
T*
(event）和转移（transition），其中转移是将状态和输入事件映射到状态。每个转移是将一个（输入状态，输入事件）对映射到一个输出状态。自循环（self-loop）是同一输入) Tj
T*
(和输岀状态之间的转移。通常把状态机画成有向图，其中节点表示状态，有向弧表示转移，而弧上的标号表示输入事件。一个状态机从某种初始状态开始执行。每个输入事件都会引发一个从当前状态到下一) Tj
T*
(状态的转移。) Tj
T*
() Tj
T*
(对于每个新的客户端 k，基于 I/O 多路复用的并发服务器会创建一个新的状态机$$\\small sk$$，并将它和已连接描述符联系起来。如图 12-7) Tj
T*
(所示，每个状态机$$\\small sk$$都有一个状态（“等待描述符$$\\small dk$$准备好可读”）、一个输入事件（“描述符$$\\small) Tj
T*
(dk$$准备好可以读了”）和一个转移（“从描述符$$\\small d_k$$读一个文本行”）。) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-7 &#x5E76;&#x53D1;&#x4E8B;&#x4EF6;&#x9A71;&#x52A8; echo) Tj
T*
(&#x670D;&#x52A1;&#x5668;&#x4E2D;&#x903B;&#x8F91;&#x6D41;&#x7684;&#x72B6;&#x6001;&#x673A;]) Tj
T*
() Tj
T*
(服务器使用 I/O 多路复用，借助 select 函数检测输入事件的发生。当每个已连接描述符准备好可读时，服务器就为相应的状态机执行转移，在这里就是从描述符读和写回一个文本行。) Tj
T*
() Tj
T*
(图 12-8 展示了一个基于 I/O 多路复用的并发事件驱动服务器的完整示例代码。一个 pool 结构里维护着活动客户端的集合（第 3 ~ 11 行）。在调用 init\\pool) Tj
T*
(初始化池（第 27 行）之后，服务器进入一个无限循环。在循环的每次迭代中，服务器调用 select) Tj
T*
(函数来检测两种不同类型的输入事件：a）来自一个新客户端的连接请求到达，b）一个已存在的客户端的已连接描述符准备好可以读了。当一个连接请求到达时（第 35 行），服务器打开连接（第) Tj
T*
ET
endstream
endobj
605 0 obj
<< /Length 2350 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(37 行），并调用 add\\client 函数，将该客户端添加到池里（第 38 行）。最后，服务器调用 check\\_clients) Tj
T*
(函数，把来自每个准备好的已连接描述符的一个文本行回送回去（第 42 行）。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    typedef struct { /* Represents a pool of connected descriptors */) Tj
T*
(        int maxfd;        /* Largest descriptor in read_set */) Tj
T*
(        fd_set read_set;  /* Set of all active descriptors */) Tj
T*
(        fd_set ready_set; /* Subset of descriptors ready for reading */) Tj
T*
(        int nready;       /* Number of ready descriptors from select */) Tj
T*
(        int maxi;         /* High water index into client array */) Tj
T*
(        int clientfd[FD_SETSIZE];    /* Set of active descriptors */) Tj
T*
(        rio_t clientrio[FD_SETSIZE]; /* Set of active read buffers */) Tj
T*
(    } pool;) Tj
T*
() Tj
T*
(    int byte_cnt = 0; /* Counts total bytes received by server */) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        int listenfd, connfd;) Tj
T*
(        socklen_t clientlen;) Tj
T*
(        struct sockaddr_storage clientaddr;) Tj
T*
(        static pool pool;) Tj
T*
() Tj
T*
(        if \(argc != 2\) {) Tj
T*
(            fprintf\(stderr, "usage: %s <port>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
(        listenfd = Open_listenfd\(argv[1]\);) Tj
T*
(        init_pool\(listenfd, &pool\);) Tj
T*
() Tj
T*
(        while \(1\) {) Tj
T*
(            /* Wait for listening/connected descriptor\(s\) to become ready */) Tj
T*
(            pool.ready_set = pool.read_set;) Tj
T*
(            pool.nready = Select\(pool.maxfd + 1, &pool.ready_set, NULL, NULL, NULL\);) Tj
T*
() Tj
T*
(            /* If listening descriptor ready, add new client to pool */) Tj
T*
(            if \(FD_ISSET\(listenfd, &pool.ready_set\)\) {) Tj
T*
(                clientlen = sizeof\(struct sockaddr_storage\);) Tj
T*
(                connfd = Accept\(listenfd, \(SA *\)&clientaddr, &clientlen\);) Tj
T*
(                add_client\(connfd, &pool\);) Tj
T*
(            }) Tj
T*
() Tj
T*
(            /* Echo a text line from each ready connected descriptor */) Tj
T*
(            check_clients\(&pool\);) Tj
T*
(        }) Tj
T*
ET
endstream
endobj
606 0 obj
<< /Length 2660 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    }) Tj
T*
() Tj
T*
(> 图 12-8 基于 I/O 多路复用的并发 echo 服务器。每次服务器迭代都回送来自每个准备好的描述符的文本行) Tj
T*
() Tj
T*
(init\\_pool 函数（图 12-9）初始化客户端池。clientfd 数组表示已连接描述符的集合，其中整数 - 1 表示一个可用的槽位。初始时，已连接描述符集合是空的（第 5) Tj
T*
(~ 7 行），而且监听描述符是 select 读集合中唯一的描述符（第 10 ~ 12 行）。) Tj
T*
() Tj
T*
(    void init_pool\(int listenfd, pool *p\)) Tj
T*
(    {) Tj
T*
(        /* Initially, there are no connected descriptors */) Tj
T*
(        int i;) Tj
T*
(        p->maxi = -1;) Tj
T*
(        for \(i = 0; i < FD_SETSIZE; i++\)) Tj
T*
(            p->clientfd[i] = -1;) Tj
T*
() Tj
T*
(        /* Initially, listenfd is only member of select read set */) Tj
T*
(        p->maxfd = listenfd;) Tj
T*
(        FD_ZERO\(&p->read_set\);) Tj
T*
(        FD_SET\(listenfd, &p->read_set\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-9 init\\_pool 初始化活动客户端池) Tj
T*
() Tj
T*
(add\\client 函数（图 12-10）添加一个新的客户端到活动客户端池中。在 clientfd 数组中找到一个空槽位后，服务器将这个已连接描述符添加到数组中，并初始化相应的) Tj
T*
(RIO 读缓冲区，这样一来我们就能够对这个描述符调用 rio\\readlineb（第 8 ~ 9 行）。然后，我们将这个已连接描述符添加到 select 读集合（第 12) Tj
T*
(行），并更新该池的一些全局属性。maxfd 变量（第 15 ~ 16 行）记录了 select 的最大文件描述符。maxi 变量（第 17 ~ 18 行）记录的是到) Tj
T*
(clientfd 数组的最大索引，这样 check\\_clients 函数就无需搜索整个数组了。) Tj
T*
() Tj
T*
(    void add_client\(int connfd, pool *p\)) Tj
T*
(    {) Tj
T*
(        int i;) Tj
T*
(        p->nready--;) Tj
T*
(        for \(i = 0; i < FD_SETSIZE; i++\) /* Find an available slot */) Tj
T*
(            if \(p->clientfd[i] < 0\) {) Tj
T*
(                /* Add connected descriptor to the pool */) Tj
T*
(                p->clientfd[i] = connfd;) Tj
T*
(                Rio_readinitb\(&p->clientrio[i], connfd\);) Tj
T*
() Tj
T*
(                /* Add the descriptor to descriptor set */) Tj
T*
(                FD_SET\(connfd, &p->read_set\);) Tj
T*
() Tj
T*
(                /* Update max descriptor and pool high water mark */) Tj
T*
(                if \(connfd > p->maxfd\)) Tj
T*
(                    p->maxfd = connfd;) Tj
T*
(                if \(i > p->maxi\)) Tj
T*
(                    p->maxi = i;) Tj
T*
ET
endstream
endobj
607 0 obj
<< /Length 2520 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(                break;) Tj
T*
(            }) Tj
T*
(        if \(i == FD_SETSIZE\) /* Couldn’t find an empty slot */) Tj
T*
(            app_error\("add_client error: Too many clients"\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-10 add\\_client 向池中添加一个新的客户端连接) Tj
T*
() Tj
T*
(图 12-11 中的 check\\_clients 函数回送来自每个准备好的已连接描述符的一个文本行。如果成功地从描述符读取了一个文本行，那么就将该文本行回送到客户端（第 15 ~) Tj
T*
(18 行）。注意，在第 15 行我们维护着一个从所有客户端接收到的全部字节的累计值。如果因为客户端关闭这个连接中它的那一端，检测到 EOF，那么将关闭这边的连接端（第 23) Tj
T*
(行），并从池中清除掉这个描述符（第 24 ~ 25 行）。) Tj
T*
() Tj
T*
(    void check_clients\(pool *p\)) Tj
T*
(    {) Tj
T*
(        int i, connfd, n;) Tj
T*
(        char buf[MAXLINE];) Tj
T*
(        rio_t rio;) Tj
T*
() Tj
T*
(        for \(i = 0; \(i <= p->maxi\) && \(p->nready > 0\); i++\) {) Tj
T*
(            connfd = p->clientfd[i];) Tj
T*
(            rio = p->clientrio[i];) Tj
T*
() Tj
T*
(            /* If the descriptor is ready, echo a text line from it */) Tj
T*
(            if \(\(connfd > 0\) && \(FD_ISSET\(connfd, &p->ready_set\)\)\) {) Tj
T*
(                p->nready--;) Tj
T*
(                if \(\(n = Rio_readlineb\(&rio, buf, MAXLINE\)\) != 0\) {) Tj
T*
(                    byte_cnt += n;) Tj
T*
(                    printf\("Server received %d \(%d total\) bytes on fd %d\\n",) Tj
T*
(                           n, byte_cnt, connfd\);) Tj
T*
(                    Rio_writen\(connfd, buf, n\);) Tj
T*
(                }) Tj
T*
() Tj
T*
(                /* EOF detected, remove descriptor from pool */) Tj
T*
(                else {) Tj
T*
(                    Close\(connfd\);) Tj
T*
(                    FD_CLR\(connfd, &p->read_set\);) Tj
T*
(                    p->clientfd[i] = -1;) Tj
T*
(                }) Tj
T*
(            }) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-11 check\\_clients 服务准备好的客户端连接) Tj
T*
() Tj
T*
(根据图 12-7 中的有限状态模型，select 函数检测到输入事件，而 add\\client 函数创建一个新的逻辑流（状态机）。check\\clients) Tj
T*
(函数回送输入行，从而执行状态转移，而且当客户端完成文本行发送时，它还要删除这个状态机。) Tj
T*
ET
endstream
endobj
608 0 obj
<< /Length 4560 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(练习题 12.4) Tj
T*
() Tj
T*
() Tj
T*
(图 12-8 所示的服务器中，我们在每次调用 select 之前都立即小心地重新初始化 pool.ready\\_set 变量。为什么？) Tj
T*
() Tj
T*
(因为变量 pool.read\\_set 既作为输入参数也作为输出参数，所以我们在每一次调用 select 之前都重新初始化它。在输入时，它包含读集合。在输出，它包含准备好的集合。) Tj
T*
() Tj
T*
(旁注 - 事件驱动的 Web 服务器) Tj
T*
() Tj
T*
() Tj
T*
(尽管有 12.2.2 节中说明的缺点，现代高性能服务器（例如 Node.js、nginx 和 Tornado）使用的都是基于 I/O) Tj
T*
(多路复用的事件驱动的编程方式，主要是因为相比于进程和线程的方式，它有明显的性能优势。) Tj
T*
() Tj
T*
(12.2.2 I/O 多路复用技术的优劣) Tj
T*
() Tj
T*
() Tj
T*
(图 12-8 中的服务器提供了一个很好的基于 I/O 多路复用的事件驱动编程的优缺点示例。事件驱动设计的一个优点是，它比基于进程的设计给了程序员更多的对程序行为的控制。例如，我们可) Tj
T*
(以设想编写一个事件驱动的并发服务器，为某些客户端提供它们需要的服务，而这对于基于进程的并发服务器来说，是很困难的。) Tj
T*
() Tj
T*
(另一个优点是，一个基于 I/O 多路复用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间。这使得在流之间共享数据变得很容易。一个与作为单个进程) Tj
T*
(运行相关的优点是，你可以利用熟悉的调试工具，例如) Tj
T*
(GDB，来调试你的并发服务器，就像对顺序程序那样。最后，事件驱动设计常常比基于进程的设计要高效得多，因为它们不需要进程上下文切换来调度新的流。) Tj
T*
() Tj
T*
(事件驱动设计一个明显的缺点就是编码复杂。我们的事件驱动的并发 echo 服务器需要的代码比基于进程的服务器多三倍，并且很不幸，随着并发粒度的减小，复杂性还会上升。这里的粒度是指每个) Tj
T*
(逻辑流每个时间片执行的指令数量。例如，在示例并发服务器中，并发粒度就是读一个完整的文本行所需要的指令数量。只要某个逻辑流正忙于读一个文本行，其他逻辑流就不可能有进展。对我们的例子来) Tj
T*
(说这没有问题，但是它使得在“故意只发送部分文本行然后就停止”的恶意客户端的攻击面前，我们的事件驱动服务器显得很脆弱。修改事件驱动服务器来处理部分文本行不是一个简单的任务，但是基于进) Tj
T*
(程的设计却能处理得很好，而且是自动处理的。基于事件的设计另一个重要的缺点是它们不能充分利用多核处理器。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(12.3 基于线程的并发编程) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(12.3 基于线程的并发编程) Tj
T*
() Tj
T*
() Tj
T*
(到目前为止，我们已经看到了两种创建并发逻辑流的方法。在第一种方法中，我们为每个流使用了单独的进程。内核会自动调度每个进程.) Tj
T*
(而每个进程有它自己的私有地址空间，这使得流共享数据很困难。在第二种方法中，我们创建自己的逻辑流，并利用 I/O) Tj
T*
(多路复用来显式地调度流。因为只有一个进程，所有的流共享整个地址空间。本节介绍第三种方法——基于线程，它是这两种方法的混合。) Tj
T*
() Tj
T*
(线程（thread）就是运行在进程上下文中的逻辑流。在本书里迄今为止，程序都是由每个进程中一个线程组成的。但是现代系统也允许我们编写一个进程里同时运行多个线程的程序。线程由内核自动) Tj
T*
(调度。每个线程都有它自己的线程上下文（thread context），包括一个唯一的整数线程 ID（Thread) Tj
T*
(ID，TID）、栈、栈指针、程序计数器、通用目的寄存器和条件码。所有的运行在一个进程里的线程共享该进程的整个虚拟地址空间。) Tj
T*
() Tj
T*
(基于线程的逻辑流结合了基于进程和基于 I/O 多路复用的流的特性。同进程一样，线程由内核自动调度，并且内核通过一个整数 ID 来识别线程。同基于 I/O) Tj
T*
ET
endstream
endobj
609 0 obj
<< /Length 3596 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(多路复用的流一样，多个线程运行在单一进程的上下文中，因此共享这个进程虚拟地址空间的所有内容，包括它的代码、数据、堆、共享库和打开的文件。) Tj
T*
() Tj
T*
(12.3.1 线程执行模型) Tj
T*
() Tj
T*
() Tj
T*
(多线程的执行模型在某些方面和多进程的执行模型是相似的。思考图 12-12 中的示例。每个进程开始生命周期时都是单一线程，这个线程称为主线程（main) Tj
T*
(thread）。在某一时刻，主线程创建一个对等线程（peer thread），从这个时间点开始，两个线程就并发地运行。最后，因为主线程执行一个慢速系统调用，例如 read 或者) Tj
T*
(sleep，或者因为被系统的间隔计时器中断，控制就会通过上下文切换传递到对等线程。对等线程会执行一段时间，然后控制传递回主线程，依次类推。) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-12 &#x5E76;&#x53D1;&#x7EBF;&#x7A0B;&#x6267;&#x884C;]) Tj
T*
() Tj
T*
(在一些重要的方面，线程执行是不同于进程的。因为一个线程的上下文要比一个进程的上下文小得多，线程的上下文切换要比进程的上下文切换快得多。另一个不同就是线程不像进程那样，不是按照严格的) Tj
T*
(父子层次来组织的。和一个进程相关的线程组成一个对等（线程）池，独立于其他线程创建的线程。主线程和其他线程的区别仅在于它总是进程中第一个运行的线程。对等（线程）池概念的主要影响是，一) Tj
T*
(个线程可以杀死它的任何对等线程，或者等待它的任意对等线程终止。另外，每个对等线程都能读写相同的共享数据。) Tj
T*
() Tj
T*
(12.3.2 Posix 线程) Tj
T*
() Tj
T*
() Tj
T*
(Posix 线程（Pthreads）是在 C 程序中处理线程的一个标准接口。它最早出现在 1995 年，而且在所有的 Linux 系统上都可用。Pthreads 定义了大约 60) Tj
T*
(个函数，允许程序创建、杀死和回收线程，与对等线程安全地共享数据，还可以通知对等线程系统状态的变化。) Tj
T*
() Tj
T*
(图 12-13 展示了一个简单的 Pthreads 程序。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    void *thread\(void *vargp\);) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        pthread_t tid;) Tj
T*
(        Pthread_create\(&tid, NULL, thread, NULL\);) Tj
T*
(        Pthread_join\(tid, NULL\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    void *thread\(void *vargp\) /* Thread routine */) Tj
T*
(    {) Tj
T*
(        printf\("Hello, world!\\n"\);) Tj
T*
(        return NULL;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-13 hello.c：使用 Pthreads 的 “Hello, world!” 程序) Tj
T*
() Tj
T*
(主线程创建一个对等线程，然后等待它的终止。对等线程输岀 “Hello, world!\\n” 并且终止。当主线程检测到对等线程终止后，它就通过调用 exit) Tj
T*
(终止该进程。这是我们看到的第一个线程化的程序，所以让我们仔细地解析它。线程的代码和本地数据被封装在一个线程例程（thread routine）中。正如第二行里的原型所示，每个线程例) Tj
T*
(程都以一个通用指针作为输入，并返回一个通用指针。如果想传递多个参数给线程例程，那么你应该将参数放到一个结构中，并传递一个指向该结构的指针。相似地，如果想要线程例程返回多个参数，你可) Tj
T*
(以返回一个指向一个结构的指针。) Tj
T*
ET
endstream
endobj
610 0 obj
<< /Length 2517 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(第 4 行标出了主线程代码的开始。主线程声明了一个本地变量 tid，可以用来存放对等线程的 ID（第 6 行）。主线程通过调用 pthread\\create) Tj
T*
(函数创建一个新的对等线程（第 7 行）。当对 pthread\\create 的调用返回时，主线程和新创建的对等线程同时运行，并且 tid 包含新线程的 ID。通过在第 8 行调用) Tj
T*
(pthread\\_join，主线程等待对等线程终止。最后，主线程调用 exit（第 9 行），终止当时运行在这个进程中的所有线程（在这个示例中就只有主线程）。) Tj
T*
() Tj
T*
(第 12 ~ 16 行定义了对等线程的例程。它只打印一个字符串，然后就通过执行第 15 行中的 return 语句来终止对等线程。) Tj
T*
() Tj
T*
(12.3.3 创建线程) Tj
T*
() Tj
T*
() Tj
T*
(线程通过调用 pthread\\_create 函数来创建其他线程。) Tj
T*
() Tj
T*
(    #include <pthread.h>) Tj
T*
(    typedef void *\(func\)\(void *\);) Tj
T*
() Tj
T*
(    int pthread_create\(pthread_t *tid, pthread_attr_t *attr,) Tj
T*
(                       func *f, void *arg\);) Tj
T*
() Tj
T*
(    // 若成功则返回 0，若出错则为非零。) Tj
T*
() Tj
T*
(pthread\\create 函数创建一个新的线程，并带着一个输入变量 arg，在新线程的上下文中运行线程例程 f。能用 attr) Tj
T*
(参数来改变新创建线程的默认属性。改变这些属性已超出我们学习的范围，在我们的示例中，总是用一个为 NULL 的参数来调用 pthread\\create 函数。) Tj
T*
() Tj
T*
(当 pthread\\create 返回时，参数 tid 包含新创建线程的 ID。新线程可以通过调用 pthread\\self 函数来获得它自己的线程 ID。) Tj
T*
() Tj
T*
(    #include <pthread.h>) Tj
T*
() Tj
T*
(    pthread_t pthread_self\(void\);) Tj
T*
() Tj
T*
(    // 返回调用者的线程 ID。) Tj
T*
() Tj
T*
(12.3.4 终止线程) Tj
T*
() Tj
T*
() Tj
T*
(一个线程是以下列方式之一来终止的：) Tj
T*
() Tj
T*
(* 当顶层的线程例程返回时，线程会隐式地终止。) Tj
T*
(* 通过调用 pthread\\exit 函数，线程会显式地终止。如果主线程调用 pthread\\exit，它会等待所有其他对等线程终止，然后再终止主线程和整个进程，返回值为) Tj
T*
(thread\\_return。) Tj
T*
() Tj
T*
(    #include <pthread.h>) Tj
T*
() Tj
T*
(    void pthread_exit\(void *thread_return\);) Tj
T*
() Tj
T*
(    // 从不返回。) Tj
T*
() Tj
T*
ET
endstream
endobj
611 0 obj
<< /Length 3089 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(* 某个对等线程调用 Linux 的 exit 函数，该函数终止进程以及所有与该进程相关的线程。) Tj
T*
(* 另一个对等线程通过以当前线程 ID 作为参数调用 pthread\\_Cancel 函数来终止当前线程。) Tj
T*
() Tj
T*
(    #include <pthread.h>) Tj
T*
() Tj
T*
(    int pthread_cancel\(pthread_t tid\);) Tj
T*
() Tj
T*
(    // 若成功则返回 0，若出错则为非零。) Tj
T*
() Tj
T*
(12.3.5 回收已终止线程的资源) Tj
T*
() Tj
T*
() Tj
T*
(线程通过调用 pthread\\_join 函数等待其他线程终止。) Tj
T*
() Tj
T*
(    #include <pthread.h>) Tj
T*
() Tj
T*
(    int pthread_join\(pthread_t tid, void **thread_return\);) Tj
T*
() Tj
T*
(    // 若成功则返回 0，若出错则为非零。) Tj
T*
() Tj
T*
(pthread\\join 函数会阻塞，直到线程 tid 终止，将线程例程返回的通用 *\\\(void\\\\\)** 指针赋值为 thread\\return) Tj
T*
(指向的位置，然后回收已终止线程占用的所有内存资源。) Tj
T*
() Tj
T*
(注意，和 Linux 的 wait 函数不同，pthread\\join 函数只能等待一个指定的线程终止。没有办法让 pthread\\wait) Tj
T*
(等待任意一个线程终止。这使得代码更加复杂，因为它迫使我们去使用其他一些不那么直观的机制来检测进程的终止。实际上，Stevens) Tj
T*
(在【110】中就很有说服力地论证了这是规范中的一个错误。) Tj
T*
() Tj
T*
(12.3.6 分离线程) Tj
T*
() Tj
T*
() Tj
T*
(在任何一个时间点上，线程是可结合的（joinable）或者是分离的（detached）。一个可结合的线程能够被其他线程收回和杀死。在被其他线程回收之前，它的内存资源（例如栈）是不释) Tj
T*
(放的。相反，一个分离的线程是不能被其他线程回收或杀死的。它的内存资源在它终止时由系统自动释放。) Tj
T*
() Tj
T*
(默认情况下，线程被创建成可结合的。为了避免内存泄漏，每个可结合线程都应该要么被其他线程显式地收回，要么通过调用 pthread\\_detach 函数被分离。) Tj
T*
() Tj
T*
(    #include <pthread.h>) Tj
T*
() Tj
T*
(    int pthread_detach\(pthread_t tid\);) Tj
T*
() Tj
T*
(    // 若成功则返回 0，若出错则为非零。) Tj
T*
() Tj
T*
(pthread\\detach 函数分离可结合线程 tid。线程能够通过以 pthread\\self\\\(\\\) 参数的 pthread\\_detach 调用来分离它们自己。) Tj
T*
() Tj
T*
(尽管我们的一些例子会使用可结合线程，但是在现实程序中，有很好的理由要使用分离的线程。例如，一个高性能 Web 服务器可能在每次收到 Web 浏览器的连接请求时都创建一个新的对等线程) Tj
T*
(。因为每个连接都是由一个单独的线程独立处理的，所以对于服务器而言，就很没有必要（实际上也不愿意）显式地等待每个对等线程终止。在这种情况下，每个对等线程都应该在它开始处理请求之前分离) Tj
T*
(它自身，这样就能在它终止后回收它的内存资源了。) Tj
T*
ET
endstream
endobj
612 0 obj
<< /Length 1964 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(12.3.7 初始化线程) Tj
T*
() Tj
T*
() Tj
T*
(pthread\\_once 函数允许你初始化与线程例程相关的状态。) Tj
T*
() Tj
T*
(    #include <pthread.h>) Tj
T*
() Tj
T*
(    pthread_once_t once_control = PTHREAD_ONCE_INIT;) Tj
T*
() Tj
T*
(    int pthread_once\(pthread_once_t *once_control,) Tj
T*
(                     void \(*init_routine\)\(void\)\);) Tj
T*
() Tj
T*
(    // 总是返回 0。) Tj
T*
() Tj
T*
(once\\control 变量是一个全局或者静态变量，总是被初始化为 PTHREAD\\ONCE\\INIT。当你第一次用参数 once\\control 调用 pthread\\once) Tj
T*
(时，它调用 init\\routine，这是一个没有输入参数、也不返回什么的函数。接下来的以 once\\control 为参数的 pthread\\once) Tj
T*
(调用不做任何事情。无论何时，当你需要动态初始化多个线程共享的全局变量时，pthread\\_once 函数是很有用的。我们将在 12.5.5 节里看到一个示例。) Tj
T*
() Tj
T*
(12.3.8 基于线程的并发服务器) Tj
T*
() Tj
T*
() Tj
T*
(图 12-14 展示了基于线程的并发 echo 服务器的代码。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void echo\(int connfd\);) Tj
T*
(    void *thread\(void *vargp\);) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        int listenfd, *connfdp;) Tj
T*
(        socklen_t clientlen;) Tj
T*
(        struct sockaddr_storage clientaddr;) Tj
T*
(        pthread_t tid;) Tj
T*
() Tj
T*
(        if \(argc != 2\) {) Tj
T*
(            fprintf\(stderr, "usage: %s <port>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
(        listenfd = Open_listenfd\(argv[1]\);) Tj
T*
() Tj
T*
(        while \(1\) {) Tj
T*
(            clientlen = sizeof\(struct sockaddr_storage\);) Tj
T*
(            connfdp = Malloc\(sizeof\(int\)\);) Tj
T*
(            *connfdp = Accept\(listenfd, \(SA *\) &clientaddr, &clientlen\);) Tj
T*
ET
endstream
endobj
613 0 obj
<< /Length 2861 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(            Pthread_create\(&tid, NULL, thread, connfdp\);) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* Thread routine */) Tj
T*
(    void *thread\(void *vargp\)) Tj
T*
(    {) Tj
T*
(        int connfd = *\(\(int *\)vargp\);) Tj
T*
(        Pthread_detach\(pthread_self\(\)\);) Tj
T*
(        Free\(vargp\);) Tj
T*
(        echo\(connfd\);) Tj
T*
(        Close\(connfd\);) Tj
T*
(        return NULL;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-14 基于线程的并发 echo 服务器) Tj
T*
() Tj
T*
(整体结构类似于基于进程的设计。主线程不断地等待连接请求，然后创建一个对等线程处理该请求。虽然代码看似简单，但是有几个普遍而且有些微妙的问题需要我们更仔细地看一看。第一个问题是当我们) Tj
T*
(调用 pthread\\_create 时，如何将已连接描述符传递给对等线程。最明显的方法就是传递一个指向这个描述符的指针，就像下面这样) Tj
T*
() Tj
T*
(    connfd = Accept\(listenfd, \(SA *\) &clientaddr, &clientlen\);) Tj
T*
(    Pthread_create\(&tid, NULL, thread, &connfd\);) Tj
T*
() Tj
T*
(然后，我们让对等线程间接引用这个指针，并将它赋值给一个局部变量，如下所示) Tj
T*
() Tj
T*
(    void *thread\(void *vargp\) {) Tj
T*
(        int connfd = *\(\(int *\)vargp\);) Tj
T*
(        .) Tj
T*
(        .) Tj
T*
(        .) Tj
T*
(    }) Tj
T*
() Tj
T*
(然而，这样可能会出错，因为它在对等线程的赋值语句和主线程的 accept 语句间引入了竞争（race）。如果赋值语句在下一个 accept 之前完成，那么对等线程中的局部变量) Tj
T*
(connfd 就得到正确的描述符值。然而，如果赋值语句是在 accept 之后才完成的，那么对等线程中的局部变量 connfd) Tj
T*
(就得到下一次连接的描述符值。那么不幸的结果就是，现在两个线程在同一个描述符上执行输入和输出。为了避免这种潜在的致命竞争，我们必须将 accept) Tj
T*
(返回的每个已连接描述符分配到它自己的动态分配的内存块，如第 20 ~ 21 行所示。我们会在 12.7.4 节中回过来讨论竞争的问题。) Tj
T*
() Tj
T*
(另一个问题是在线程例程中避免内存泄漏。既然不显式地收回线程，就必须分离每个线程，使得在它终止时它的内存资源能够被收回（第 31) Tj
T*
(行）。更进一步，我们必须小心释放主线程分配的内存块（第 32 行）。) Tj
T*
() Tj
T*
(练习题 12.5) Tj
T*
() Tj
T*
() Tj
T*
(在图 12-5 中基于进程的服务器中，我们在两个位置小心地关闭了已连接描述符：父进程和子进程。然而，在图 12-14) Tj
T*
(中基于线程的服务器中，我们只在一个位置关闭了已连接描述符：对等线程。为什么？) Tj
T*
() Tj
T*
ET
endstream
endobj
614 0 obj
<< /Length 2507 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(因为线程运行在同一个进程中，它们都共享相同的描述符表。无论有多少线程使用这个已连接描述符，这个已连接描述符的文件表的引用计数都等于 1。因此，当我们用完它时，一个 close) Tj
T*
(操作就足以释放与这个已连接描述符相关的内存资源了。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(12.4 多线程程序中的共享变量) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(12.4 多线程程序中的共享变量) Tj
T*
() Tj
T*
() Tj
T*
(从程序员的角度来看，线程很有吸引力的一个方面是多个线程很容易共享相同的程序变量。然而，这种共享也是很棘手的。为了编写正确的多线程程序，我们必须对所谓的共享以及它是如何工作的有很清楚) Tj
T*
(的了解。) Tj
T*
() Tj
T*
(为了理解 C 程序中的一个变量是否是共享的，有一些基本的问题要解答：) Tj
T*
() Tj
T*
(1. 线程的基础内存模型是什么？) Tj
T*
(2. 根据这个模型，变量实例是如何映射到内存的？) Tj
T*
(3. 最后，有多少线程引用这些实例？一个变量是共享的，当且仅当多个线程引用这个变量的某个实例。) Tj
T*
() Tj
T*
(为了让我们对共享的讨论具体化，我们将使用图 12-15) Tj
T*
(中的程序作为运行示例。尽管有些人为的痕迹，但是它仍然值得研究，因为它说明了关于共享的许多细微之处。示例程序由一个创建了两个对等线程的主线程组成。主线程传递一个唯一的 ID) Tj
T*
(给每个对等线程，每个对等线程利用这个 ID 输出一条个性化的信息，以及调用该线程例程的总次数。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    #define N 2) Tj
T*
(    void *thread\(void *vargp\);) Tj
T*
() Tj
T*
(    char **ptr; /* Global variable */) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        int i;) Tj
T*
(        pthread_t tid;) Tj
T*
(        char *msgs[N] = {) Tj
T*
(            "Hello from foo",) Tj
T*
(            "Hello from bar") Tj
T*
(        };) Tj
T*
() Tj
T*
(        ptr = msgs;) Tj
T*
(        for \(i = 0; i < N; i++\)) Tj
T*
(            Pthread_create\(&tid, NULL, thread, \(void *\)i\);) Tj
T*
(        Pthread_exit\(NULL\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    void *thread\(void *vargp\)) Tj
T*
ET
endstream
endobj
615 0 obj
<< /Length 4063 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    {) Tj
T*
(        int myid = \(int\)vargp;) Tj
T*
(        static int cnt = 0;) Tj
T*
(        printf\("[%d]: %s \(cnt=%d\)\\n", myid, ptr[myid], ++cnt\);) Tj
T*
(        return NULL;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-15 说明共享不同方面的示例程序) Tj
T*
() Tj
T*
(12.4.1 线程内存模型) Tj
T*
() Tj
T*
() Tj
T*
(一组并发线程运行在一个进程的上下文中。每个线程都有它自己独立的线程上下文，包括线程 ID、栈、栈指针、程序计数器、条件码和通用目的寄存器值。每个线程和其他线程一起共享进程上下文的剩) Tj
T*
(余部分。这包括整个用户虚拟地址空间，它是由只读文本（代码）、读/写数据、堆以及所有的共享库代码和数据区域组成的。线程也共享相同的打开文件的集合。) Tj
T*
() Tj
T*
(从实际操作的角度来说，让一个线程去读或写另一个线程的寄存器值是不可能的。另一方面，任何线程都可以访问共享虚拟内存的任意位置。如果某个线程修改了一个内存位置，那么其他每个线程最终都能) Tj
T*
(在它读这个位置时发现这个变化。因此，寄存器是从不共享的，而虚拟内存总是共享的。) Tj
T*
() Tj
T*
(各自独立的线程栈的内存模型不是那么整齐清楚的。这些栈被保存在虚拟地址空间的栈区域中，并且通常是被相应的线程独立地访问的。我们说通常而不是总是，是因为不同的线程栈是不对其他线程设防的) Tj
T*
(。所以，如果一个线程以某种方式得到一个指向其他线程栈的指针，那么它就可以读写这个栈的任何部分。示例程序在第 26 行展示了这一点，其中对等线程直接通过全局变量 ptr) Tj
T*
(间接引用主线程的栈的内容。) Tj
T*
() Tj
T*
(12.4.2 将变量映射到内存) Tj
T*
() Tj
T*
() Tj
T*
(多线程的 C 程序中变量根据它们的存储类型被映射到虚拟内存：) Tj
T*
() Tj
T*
(* 全局变量。全局变量是定义在函数之外的变量。在运行时，虚拟内存的读/写区域只包含每个全局变量的一个实例，任何线程都可以引用。例如，第 5 行声明的全局变量 ptr) Tj
T*
(在虚拟内存的读/写区域中有一个运行时实例。当一个变量只有一个实例时，我们只用变量名（在这里就是 ptr）来表示这个实例。) Tj
T*
(* 本地自动变量。本地自动变量就是定义在函数内部但是没有 static) Tj
T*
(属性的变量。在运行时，每个线程的栈都包含它自己的所有本地自动变量的实例。即使多个线程执行同一个线程例程时也是如此。例如，有一个本地变量 tid 的实例，它保存在主线程的栈中。我们用) Tj
T*
(tid.m 来表示这个实例。再来看一个例子，本地变量 myid 有两个实例，一个在对等线程。的栈内，另一个在对等线程 1 的栈内。我们将这两个实例分别表示为 myid.p0 和) Tj
T*
(myid.p1。) Tj
T*
(* 本地静态变量。本地静态变量是定义在函数内部并有 static) Tj
T*
(属性的变量。和全局变量一样，虚拟内存的读/写区域只包含在程序中声明的每个本地静态变量的一个实例。例如，即使示例程序中的每个对等线程都在第 25 行声明了) Tj
T*
(cnt，在运行时，虚拟内存的读/写区域中也只有一个 cnt 的实例。每个对等线程都读和写这个实例。) Tj
T*
() Tj
T*
(12.4.3 共享变量) Tj
T*
() Tj
T*
() Tj
T*
(我们说一个变量 v 是共享的，当且仅当它的一个实例被一个以上的线程引用。例如，示例程序中的变量 cnt) Tj
T*
(就是共享的，因为它只有一个运行时实例，并且这个实例被两个对等线程引用。在另一方面，myid 不是共享的，因为它的两个实例中每一个都只被一个线程引用。然而，认识到像 msgs) Tj
T*
(这样的本地自动变量也能被共享是很重要的。) Tj
T*
() Tj
T*
(练习题 12.6) Tj
T*
() Tj
T*
ET
endstream
endobj
616 0 obj
<< /Length 2542 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(A. 利用 12.4 节中的分析，为图 12-15 中的示例程序在下表的每个条目中填写“是”或者“否”。在第一列中，符号 v.t 表示变量 v 的一个实例，它驻留在线程 t) Tj
T*
(的本地栈中，其中 t 要么是 m（主线程），要么是 p0（对等线程 0）或者 p1（对等线程 1）。) Tj
T*
() Tj
T*
(| 变量实例 | 主线程引用的？ | 对等线程 0 引用的？ | 对等线程 1 引用的？ |) Tj
T*
(| :--- | :--- | :--- | :--- |) Tj
T*
(| ptr |  |  |  |) Tj
T*
(| cnt |  |  |  |) Tj
T*
(| i.m |  |  |  |) Tj
T*
(| msgs.m |  |  |  |) Tj
T*
(| myid.p0 |  |  |  |) Tj
T*
(| myid.p1 |  |  |  |) Tj
T*
() Tj
T*
(B. 根据 A 部分的分析，变量 ptr、cnt、i、msgs 和 myid 哪些是共享的？) Tj
T*
() Tj
T*
(这里的主要的思想是，栈变量是私有的，而全局和静态变量是共享的。诸如 cnt 这样的静态变量有点小麻烦，因为共享是限制在它们的函数范围内的一一在这个例子中，就是线程例程。) Tj
T*
() Tj
T*
(A. 下面就是这张表：) Tj
T*
() Tj
T*
(| 变量实例 | 被主线程引用？ | 被对等线程 0 引用？ | 被对等线程 1 引用？ |) Tj
T*
(| :--- | :---: | :---: | :---: |) Tj
T*
(| ptr | 是 | 是 | 是 |) Tj
T*
(| cnt | 否 | 是 | 是 |) Tj
T*
(| i.m | 是 | 否 | 否 |) Tj
T*
(| msgs.m | 是 | 是 | 是 |) Tj
T*
(| myid.p0 | 否 | 是 | 否 |) Tj
T*
(| myid.p1 | 否 | 否 | 是 |) Tj
T*
() Tj
T*
(说明：) Tj
T*
() Tj
T*
(* ptr：一个被主线程写和被对等线程读的全局变量。) Tj
T*
(* cnt：一个静态变量，在内存中只有一个实例，被两个对等线程读和写。) Tj
T*
(* i.m：一个存储在主线程栈中的本地自动变量。虽然它的值被传递给对等线程，但是对等线程也绝不会在栈中引用它，因此它不是共享的。) Tj
T*
(* msgs.m：一个存储在主线程栈中的本地自动变量，被两个对等线程通过 ptr 间接地引用。) Tj
T*
(* myid.0 和 myid.1；—个本地自动变量的实例，分别驻留在对等线程 0 和线程 1 的栈中。) Tj
T*
() Tj
T*
(B. 变量 ptr、ent 和 msgs 被多于一个线程引用，因此它们是共享的。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(12.5 用信号量同步线程) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(12.5 用信号量同步线程) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
617 0 obj
<< /Length 1737 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(共享变量是十分方便，但是它们也引入了同步错误（synchronization error）的可能性。考虑图 12-16 中的程序) Tj
T*
(badcnt.c，它创建了两个线程，每个线程都对共享计数变量 cnt 加 1。) Tj
T*
() Tj
T*
(    /* WARNING: This code is buggy! */) Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void *thread\(void *vargp\); /* Thread routine prototype */) Tj
T*
() Tj
T*
(    /* Global shared variable */) Tj
T*
(    volatile long cnt = 0; /* Counter */) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        long niters;) Tj
T*
(        pthread_t tid1, tid2;) Tj
T*
() Tj
T*
(        /* Check input argument */) Tj
T*
(        if \(argc != 2\) {) Tj
T*
(            printf\("usage: %s <niters>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
(        niters = atoi\(argv[1]\);) Tj
T*
() Tj
T*
(        /* Create threads and wait for them to finish */) Tj
T*
(        Pthread_create\(&tid1, NULL, thread, &niters\);) Tj
T*
(        Pthread_create\(&tid2, NULL, thread, &niters\);) Tj
T*
(        Pthread_join\(tid1, NULL\);) Tj
T*
(        Pthread_join\(tid2, NULL\);) Tj
T*
() Tj
T*
(        /* Check result */) Tj
T*
(        if \(cnt != \(2 * niters\)\)) Tj
T*
(            printf\("BOOM! cnt=%ld\\n", cnt\);) Tj
T*
(        else) Tj
T*
(            printf\("OK cnt=%ld\\n", cnt\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* Thread routine */) Tj
T*
(    void *thread\(void *vargp\)) Tj
T*
(    {) Tj
T*
(        long i, niters = *\(\(long *\)vargp\);) Tj
T*
() Tj
T*
(        for \(i = 0; i < niters; i++\)) Tj
T*
(            cnt++;) Tj
T*
() Tj
T*
(        return NULL;) Tj
T*
ET
endstream
endobj
618 0 obj
<< /Length 3031 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    }) Tj
T*
() Tj
T*
() Tj
T*
(> 图 12-16 badcnt.c：一个同步不正确的计数器程序) Tj
T*
() Tj
T*
(因为每个线程都对计数器增加了 niters 次，我们预计它的最终值是 2 × niters。这看上去简单而直接。然而，当在 Linux 系统上运行 badcnt.c) Tj
T*
(时，我们不仅得到错误的答案，而且每次得到的答案都还不相同！) Tj
T*
() Tj
T*
(    linux> ./badcnt 1000000) Tj
T*
(    BOOM! cnt=1445085) Tj
T*
() Tj
T*
(    linux> ./badcnt 1000000) Tj
T*
(    BOOM! cnt=1915220) Tj
T*
() Tj
T*
(    linux> ./badcnt 1000000) Tj
T*
(    BOOM! cnt=1404746) Tj
T*
() Tj
T*
(那么哪里出错了呢？为了清晰地理解这个问题，我们需要研究计数器循环（第 40 ~ 41 行）的汇编代码，如图 12-17 所示。) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-17 badcnt.c) Tj
T*
(&#x4E2D;&#x8BA1;&#x6570;&#x5668;&#x5FAA;&#x73AF;&#xFF08;&#x7B2C; 40 ~ 41) Tj
T*
(&#x884C;&#xFF09;&#x7684;&#x6C47;&#x7F16;&#x4EE3;&#x7801;]) Tj
T*
() Tj
T*
(我们发现，将线程 i 的循环代码分解成五个部分是很有帮助的：) Tj
T*
() Tj
T*
(* $$H_i$$：在循环头部的指令块。) Tj
T*
(* $$ L_i$$：加载共享变量 cnt 到累加寄存器 %rdxi 的指令，这里 %rdxi 表示线程 i 中的寄存器 ％rdx 的值。) Tj
T*
(* $$U_i$$：更新（增加）%rdxi 的指令。) Tj
T*
(* $$S_i$$：将 ％rdxi 的更新值存回到共享变量 cnt 的指令。) Tj
T*
(* $$T_i$$ ：循环尾部的指令块。) Tj
T*
() Tj
T*
(注意头和尾只操作本地栈变量，而$$Li$$、 $$Ui$$和$$S_i$$操作共享计数器变量的内容。) Tj
T*
() Tj
T*
(当 badcnt.c 中的两个对等线程在一个单处理器上并发运行时，机器指令以某种顺序一个接一个地完成。因此，每个并发执行定义了两个线程中的指令的某种全序（或者交叉）。不幸的是，这些) Tj
T*
(顺序中的一些将会产生正确结果，但是其他的则不会。) Tj
T*
() Tj
T*
(这里有个关键点：一般而言，你没有办法预测操作系统是否将为你的线程选择一个正确的顺序。例如，图 12-18a 展示了一个正确的指令顺序的分步操作。在每个线程更新了共享变量 cnt) Tj
T*
(之后，它在内存中的值就是 2，这正是期望的值。) Tj
T*
() Tj
T*
(另一方面，图 12-18b 的顺序产生一个不正确的 cnt 的值。会发生这样的问题是因为，线程 2 在第 5 步加载 ent，是在第 2 步线程 1 加载 cnt 之后，而在第 6) Tj
T*
(步线程 1 存储它的更新值之前。因此，每个线程最终都会存储一个值为 1 的更新后的计数器值。我们能够借助于一种叫做进度图（progress) Tj
T*
(graph）的方法来阐明这些正确的和不正确的指令顺序的概念，这个图我们将在下一节中介绍。) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-18 badcnt.c &#x4E2D;&#x7B2C;&#x4E00;&#x6B21;&#x5FAA;&#x73AF;&#x8FED;&#) Tj
T*
(x4EE3;&#x7684;&#x6307;&#x4EE4;&#x987A;&#x5E8F;]) Tj
T*
() Tj
T*
ET
endstream
endobj
619 0 obj
<< /Length 2109 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(练习题 12.7) Tj
T*
() Tj
T*
() Tj
T*
(根据 badcnt.c 的指令顺序完成下表：) Tj
T*
() Tj
T*
(| 步骤 | 线程 | 指令 | %rdx1 | %rdx2 | cnt |) Tj
T*
(| :---: | :---: | :---: | :---: | :---: | :---: |) Tj
T*
(| 1 | 1 | $$H_1$$  | — | — | 0 |) Tj
T*
(| 2 | 1 | $$L_1$$ |  |  |  |) Tj
T*
(| 3 | 2 | $$H_2$$ |  |  |  |) Tj
T*
(| 4 | 2 | $$L_2$$ |  |  |  |) Tj
T*
(| 5 | 2 | $$U_2$$ |  |  |  |) Tj
T*
(| 6 | 2 | $$S_2$$ |  |  |  |) Tj
T*
(| 7 | 1 | $$U_1$$ |  |  |  |) Tj
T*
(| 8 | 1 | $$S_1$$ |  |  |  |) Tj
T*
(| 9 | 1 | $$T_1$$ |  |  |  |) Tj
T*
(| 10 | 2 | $$T_2$$ |  |  |  |) Tj
T*
() Tj
T*
(这种顺序会产生一个正确的 cnt 值吗？) Tj
T*
() Tj
T*
(这里的重要思想是，你不能假设当内核调度你的线程时会如何选择顺序。) Tj
T*
() Tj
T*
(| 步骤 | 线程 | 指令 | %rdx1 | %rdx2 | cnt |) Tj
T*
(| :---: | :---: | :---: | :---: | :---: | :---: |) Tj
T*
(| 1 | 1 | $$H_1$$  | — | — | 0 |) Tj
T*
(| 2 | 1 | $$L_1$$ | 0 | — | 0 |) Tj
T*
(| 3 | 2 | $$H_2$$ | — | — | 0 |) Tj
T*
(| 4 | 2 | $$L_2$$ | — | 0 | 0 |) Tj
T*
(| 5 | 2 | $$U_2$$ | — | 1 | 0 |) Tj
T*
(| 6 | 2 | $$S_2$$ | — | 1 | 1 |) Tj
T*
(| 7 | 1 | $$U_1$$ | 1 | — | 1 |) Tj
T*
(| 8 | 1 | $$S_1$$ | 1 | — | 1 |) Tj
T*
(| 9 | 1 | $$T_1$$ | 1 | — | 1 |) Tj
T*
(| 10 | 2 | $$T_2$$ | — | 1 | 1 |) Tj
T*
() Tj
T*
(变量 cnt 最终有一个不正确的值 1。) Tj
T*
() Tj
T*
(12.5.1 进度图) Tj
T*
() Tj
T*
() Tj
T*
(进度图（progress graph）将 n 个并发线程的执行模型化为一条 n 维笛卡儿空间中的轨迹线。每条轴 k 对应于线程 k 的进度。每个点) Tj
T*
($$\(I1,I2,\\cdots,In\)$$ 代表线程$$k~\(k=1,\\dots,n\)$$ 已经完成了指令$$Ik$$这一状态。图的原点对应于没有任何线程完成一条指令的初始状态。) Tj
T*
() Tj
T*
(图 12-19 展示了 badcnt.c 程序第一次循环迭代的二维进度图。水平轴对应于线程 1，垂直轴对应于线程 2。点 $$\(L1, S2\)$$ 对应于线程 1 完成了) Tj
T*
($$L1$$ 而线程 2 完成了 $$S2$$ 的状态。) Tj
T*
() Tj
T*
ET
endstream
endobj
620 0 obj
<< /Length 3401 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
([Image: &#x56FE; 12-19 badcnt.c) Tj
T*
(&#x7B2C;&#x4E00;&#x6B21;&#x5FAA;&#x73AF;&#x8FED;&#x4EE3;&#x7684;&#x8FDB;&#x5EA6;&#x56FE;]) Tj
T*
() Tj
T*
(进度图将指令执行模型化为从一种状态到另一种状态的转换（transition）。转换被表示为一条从一点到相邻点的有向边。合法的转换是向右（线程 1 中的一条指令完成）或者向上（线程) Tj
T*
(2 中的一条指令完成）的。两条指令不能在同一时刻完成一对角线转换是不允许的。程序决不会反向运行，所以向下或者向左移动的转换也是不合法的。) Tj
T*
() Tj
T*
(一个程序的执行历史被模型化为状态空间中的一条轨迹线。图 12-20 展示了下面指令顺序对应的轨迹线：) Tj
T*
() Tj
T*
($$) Tj
T*
(H1,L1,U1,H2,L2,S1,T1,U2,S2,T2) Tj
T*
($$) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-20 &#x4E00;&#x4E2A;&#x8F68;&#x8FF9;&#x7EBF;&#x793A;&#x4F8B;]) Tj
T*
() Tj
T*
(对于线程 i，操作共享变量 cnt 内容的指令$$\(Li,Ui,S_i\)$$构成了一个（关于共享变量 cnt 的）临界区（critical) Tj
T*
(section），这个临界区不应该和其他进程的临界区交替执行。换句话说，我们想要确保每个线程在执行它的临界区中的指令时，拥有对共享变量的互斥的访问（mutually) Tj
T*
(exclusive access）。通常这种现象称为互斥（mutual exclusion）。) Tj
T*
() Tj
T*
(在进度图中，两个临界区的交集形成的状态空间区域称为不安全区（unsafe region）。图 12-21 展示了变量 cnt) Tj
T*
(的不安全区。注意，不安全区和与它交界的状态相毗邻，但并不包括这些状态。例如，状态$$\(H1,H2\)$$) Tj
T*
(和$$\(S1,S2\)$$毗邻不安全区，但是它们并不是不安全区的一部分。绕开不安全区的轨迹线叫做安全轨迹线（safe) Tj
T*
(trajectory）。相反，接触到任何不安全区的轨迹线就叫做不安全轨迹线（unsafe trajectory）。图 12-21 给出了示例程序 badcnt.c) Tj
T*
(的状态空间中的安全和不安全轨迹线。上面的轨迹线绕开了不安全区域的左边和上边，所以是安全的。下面的轨迹线穿越不安全区，因此是不安全的。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 12-21 安全和不安全轨迹线。临界区的交集形成了不安全区。绕开不安全区的轨迹线能够正确更新计数器变量) Tj
T*
() Tj
T*
(任何安全轨迹线都将正确地更新共享计数器。为了保证线程化程序示例的正确执行（实际上任何共享全局数据结构的并发程序的正确执行）我们必须以某种方式同步线程，使它们总是有一条安全轨迹线。一) Tj
T*
(个经典的方法是基于信号量的思想，接下来我们就介绍它。) Tj
T*
() Tj
T*
(练习题 12.8) Tj
T*
() Tj
T*
() Tj
T*
(使用图 12-21 中的进度图，将下列轨迹线划分为安全的或者不安全的。) Tj
T*
() Tj
T*
(A. $$H1,L1,U1,S1,H2,L2,U2,S2,T2,T1$$) Tj
T*
() Tj
T*
(B. $$H2,L2,H1,L1,U1,S1,T1,U2,S2,T2$$) Tj
T*
() Tj
T*
(C. $$H1,H2,L2,U2,S2,L1,U1,S1,T1,T2$$) Tj
T*
() Tj
T*
(这道题简单地测试你对进度图中安全和不安全轨迹线的理解。像 A 和 C 这样的轨迹线绕开了临界区，是安全的，会产生正确的结果。) Tj
T*
() Tj
T*
(A. $$H1,L1,U1,S1,H2,L2,U2,S2,T2,T1$$ ：安全的) Tj
T*
() Tj
T*
ET
endstream
endobj
621 0 obj
<< /Length 3114 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(B. $$H2,L2,H1,L1,U1,S1,T1,U2,S2,T2$$ ：不安全的) Tj
T*
() Tj
T*
(C. $$H1,H2,L2,U2,S2,L1,U1,S1,T1,T2$$ ：安全的) Tj
T*
() Tj
T*
(12.5.2 信号量) Tj
T*
() Tj
T*
() Tj
T*
(Edsger Dijkstra，并发编程领域的先锋人物，提出了一种经典的解决同步不同执行线程问题的方法，这种方法是基于一种叫做信号量（semaphore）的特殊类型变量的。信号量) Tj
T*
(s 是具有非负整数值的全局变量，只能由两种特殊的操作来处理，这两种操作称为 P 和 V：) Tj
T*
() Tj
T*
(* $$P\(s\)$$：如果 s 是非零的，那么 P 将 s 减 1，并且立即返回。如果 s 为零，那么就挂起这个线程，直到 s 变为非零，而一个 V) Tj
T*
(操作会重启这个线程。在重启之后，P 操作将 s 减 1，并将控制返回给调用者。) Tj
T*
(* $$V\(s\)$$：V 操作将 s 加 1。如果有任何线程阻塞在 P 操作等待 s 变成非零，那么 V 操作会重启这些线程中的一个，然后该线程将 s 减 1，完成它的 P 操作。) Tj
T*
() Tj
T*
(P 中的测试和减 1 操作是不可分割的，也就是说，一旦预测信号量 s 变为非零，就会将 s 减 1，不能有中断。V 中的加 1 操作也是不可分割的，也就是加载、加 1) Tj
T*
(和存储信号量的过程中没有中断。注意，V 的定义中没有定义等待线程被重启动的顺序。唯一的要求是 V 必须只能重启一个正在等待的线程。因此，当有多个线程在等待同一个信号量时，你不能预测) Tj
T*
(V 操作要重启哪一个线程。) Tj
T*
() Tj
T*
(P 和 V 的定义确保了一个正在运行的程序绝不可能进入这样一种状态，也就是一个正确初始化了的信号量有一个负值。这个属性称为信号量不变性（semaphore) Tj
T*
(invariant），为控制并发程序的轨迹线提供了强有力的工具，在下一节中我们将看到。) Tj
T*
() Tj
T*
(Posix 标准定义了许多操作信号量的函数。) Tj
T*
() Tj
T*
(    #include <semaphore.h>) Tj
T*
() Tj
T*
(    int sem_init\(sem_t *sem, 0, unsigned int value\);) Tj
T*
(    int sem_wait\(sem_t *s\); /* P\(s\) */) Tj
T*
(    int sem_post\(sem_t *s\); /* V\(s\) */) Tj
T*
() Tj
T*
(    // 返回：若成功则为 0，若出错则为 -1。) Tj
T*
() Tj
T*
(sem\\init 函数将信号量 sem 初始化为 value。每个信号量在使用前必须初始化。针对我们的目的，中间的参数总是零。程序分别通过调用 sem\\wait 和) Tj
T*
(sem\\_post 函数来执行 P 和 V 操作。为了简明，我们更喜欢使用下面这些等价的 P 和 V 的包装函数：) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    void P\(sem_t *s\); /* Wrapper function for sem_wait */) Tj
T*
(    void V\(sem_t *s\); /* Wrapper function for sem_post */) Tj
T*
() Tj
T*
(    // 返回：无。) Tj
T*
() Tj
T*
(旁注 - P 和 V 名字的起源) Tj
T*
() Tj
T*
() Tj
T*
(Edsger Dijkstra（1930 — 2002）出生于荷兰。名字 P 和 V 来源于荷兰语单词 Proberen（测试）和 Verhogen（增加）。) Tj
T*
() Tj
T*
ET
endstream
endobj
622 0 obj
<< /Length 3118 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(12.5.3 使用信号量来实现互斥) Tj
T*
() Tj
T*
() Tj
T*
(信号量提供了一种很方便的方法来确保对共享变量的互斥访问。基本思想是将每个共享变量（或者一组相关的共享变量）与一个信号量 s（初始为) Tj
T*
(1）联系起来，然后用$$P\(s\)$$和$$V\(s\)$$操作将相应的临界区包围起来。) Tj
T*
() Tj
T*
(以这种方式来保护共享变量的信号量叫做二元信号量（binary semaphore），因为它的值总是 0 或者) Tj
T*
(1。以提供互斥为目的的二元信号量常常也称为互斥锁（mutex）。在一个互斥锁上执行 P 操作称为对互斥锁加锁。类似地，执行 V) Tj
T*
(操作称为对互斥锁解锁。对一个互斥锁加了锁但是还没有解锁的线程称为占用这个互斥锁。一个被用作一组可用资源的计数器的信号量被称为计数信号量。) Tj
T*
() Tj
T*
(图 12-22 中的进度图展示了我们如何利用二元信号量来正确地同步计数器程序示例。每个状态都标出了该状态中信号量 s 的值。关键思想是这种 P 和 V) Tj
T*
(操作的结合创建了一组状态，叫做禁止区（forbidden region），其中因为信号量的不变性，没有实际可行的轨迹线能够包含禁止区中的状态。而且，因为禁止区完全包括了不安全区，所) Tj
T*
(以没有实际可行的轨迹线能够接触不安全区的任何部分。因此，每条实际可行的轨迹线都是安全的，而且不管运行时指令顺序是怎样的，程序都会正确地增加计数器值。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 12-22 使用信号量来互斥。$$\\small s\\lt0$$的不可行状态定义了一个禁止区，禁止区完全包括了不安全区，阻止了实际可行的轨迹线接触到不安全区) Tj
T*
() Tj
T*
(从可操作的意义上来说，由 P 和 V 操作创建的禁止区使得在任何时间点上，在被包围的临界区中，不可能有多个线程在执行指令。换句话说，信号量操作确保了对临界区的互斥访问。) Tj
T*
() Tj
T*
(总的来说，为了用信号量正确同步图 12-16 中的计数器程序示例，我们首先声明一个信号量 mutex：) Tj
T*
() Tj
T*
(    volatile long cnt = 0; /* Counter */) Tj
T*
(    sem_t mutex;           /* Semaphore that protects counter */) Tj
T*
() Tj
T*
(然后在主例程中将 mutex 初始化为 1：) Tj
T*
() Tj
T*
(    Sem_init\(&mutex, 0, 1\); /* mutex = 1 */) Tj
T*
() Tj
T*
(最后，我们通过把在线程例程中对共享变量 cnt 的更新包围 P 和 V 操作，从而保护它们：) Tj
T*
() Tj
T*
(    for \(i = 0; i < niters; i++\) {) Tj
T*
(        P\(&mutex\);) Tj
T*
(        cnt++;) Tj
T*
(        V\(&mutex\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(当我们运行这个正确同步的程序时，现在它每次都能产生正确的结果了。) Tj
T*
() Tj
T*
(    linux> ./goodcnt 1000000) Tj
T*
(    OK cnt=2000000) Tj
T*
() Tj
T*
(    linux> ./goodcnt 1000000) Tj
T*
(    OK cnt=2000000) Tj
T*
() Tj
T*
(旁注 - 进度图的局限性) Tj
T*
ET
endstream
endobj
623 0 obj
<< /Length 4145 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
() Tj
T*
(进度图给了我们一种较好的方法，将在单处理器上的并发程序执行可视化，也帮助我们理解为什么需要同步。然而，它们确实也有局限性，特别是对于在多处理器上的并发执行，在多处理器上一组 CPU) Tj
T*
(/高速缓存对共享同一个主存。多处理器的工作方式是进度图不能解释的。特别是，一个多处理器内存系统可以处于一种状态，不对应于进度图中任何轨迹线。不管如何，结论总是一样的：无论是在单处理) Tj
T*
(器还是多处理器上运行程序，都要同步你对共享变量的访问。) Tj
T*
() Tj
T*
(12.5.4 利用信号量来调度共享资源) Tj
T*
() Tj
T*
() Tj
T*
(除了提供互斥之外，信号量的另一个重要作用是调度对共享资源的访问。在这种场景中，一个线程用信号量操作来通知另一个线程，程序状态中的某个条件已经为真了。两个经典而有用的例子是生产者—消) Tj
T*
(费者和读者—写者问题。) Tj
T*
() Tj
T*
(1. 生产者—消费者问题) Tj
T*
() Tj
T*
() Tj
T*
(图 12-23 给出了生产者—消费者问题。生产者和消费者线程共享一个有 n) Tj
T*
(个槽的有限缓冲区。生产者线程反复地生成新的项目（item），并把它们插入到缓冲区中。消费者线程不断地从缓冲区中取出这些项目，然后消费（使用）它们。也可能有多个生产者和消费者的变种。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 12-23 生产者—消费者问题。生产者产生项目并把它们插人到一个有限的缓冲区中。消费者从缓冲区中取出这些项目，然后消费它们) Tj
T*
() Tj
T*
(因为插入和取出项目都涉及更新共享变量，所以我们必须保证对缓冲区的访问是互斥的。但是只保证互斥访问是不够的，我们还需要调度对缓冲区的访问。如果缓冲区是满的（没有空的槽位），那么生产者) Tj
T*
(必须等待直到有一个槽位变为可用。与之相似，如果缓冲区是空的（没有可取用的项目），那么消费者必须等待直到有一个项目变为可用。) Tj
T*
() Tj
T*
(生产者—消费者的相互作用在现实系统中是很普遍的。例如，在一个多媒体系统中，生产者编码视频帧，而消费者解码并在屏幕上呈现出来。缓冲区的目的是为了减少视频流的抖动，而这种抖动是由各个帧) Tj
T*
(的编码和解码时与数据相关的差异引起的。缓冲区为生产者提供了一个槽位池，而为消费者提供一个已编码的帧池。另一个常见的示例是图形用户接口设计。生产者检测到鼠标和键盘事件，并将它们插入到) Tj
T*
(缓冲区中。消费者以某种基于优先级的方式从缓冲区取出这些事件，并显示在屏幕上。) Tj
T*
() Tj
T*
(在本节中，我们将开发一个简单的包，叫做) Tj
T*
(SBUF，用来构造生产者—消费者程序。在下一节里，我们会看到如何用它来构造一个基于预线程化（prethreading）的有趣的并发服务器。SBUF 操作类型为 sbuf\\_t) Tj
T*
(的有限缓冲区（图 12-24）。项目存放在一个动态分配的 1 项整数数组（buf）中。front 和 rear) Tj
T*
(索引值记录该数组中的第一项和最后一项。三个信号量同步对缓冲区的访问。mutex 信号量提供互斥的缓冲区访问。slots 和 items 信号量分别记录空槽位和可用项目的数量。) Tj
T*
() Tj
T*
(    typedef struct {) Tj
T*
(        int *buf;       /* Buffer array */) Tj
T*
(        int n;          /* Maximum number of slots */) Tj
T*
(        int front;      /* buf[\(front+1\)%n] is first item */) Tj
T*
(        int rear;       /* buf[rear%n] is last item */) Tj
T*
(        sem_t mutex;    /* Protects accesses to buf */) Tj
T*
(        sem_t slots;    /* Counts available slots */) Tj
T*
(        sem_t items;    /* Counts available items */) Tj
T*
(    } sbuf_t;) Tj
T*
() Tj
T*
(> 图 12-24 sbuf\\_t：SBUF 包使用的有限缓冲区) Tj
T*
() Tj
T*
ET
endstream
endobj
624 0 obj
<< /Length 2864 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(图 12-25 给出了 SBUF 函数的实现。sbuf\\init 函数为缓冲区分配堆内存，设置 front 和 rear) Tj
T*
(表示一个空的缓冲区，并为三个信号量赋初始值。这个函数在调用其他三个函数中的任何一个之前调用一次。sbuf\\deinit) Tj
T*
(函数是当应用程序使用完缓冲区时，释放缓冲区存储的。sbuf\\insert) Tj
T*
(函数等待一个可用的槽位，对互斥锁加锁，添加项目，对互斥锁解锁，然后宣布有一个新项目可用。sbuf\\remove 函数是与 sbuf\\_insert) Tj
T*
(函数对称的。在等待一个可用的缓冲区项目之后，对互斥锁加锁，从缓冲区的前面取出该项目，对互斥锁解锁，然后发信号通知一个新的槽位可供使用。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    #include "sbuf.h") Tj
T*
() Tj
T*
(    /* Create an empty, bounded, shared FIFO buffer with n slots */) Tj
T*
(    void sbuf_init\(sbuf_t *sp, int n\)) Tj
T*
(    {) Tj
T*
(        sp->buf = Calloc\(n, sizeof\(int\)\);) Tj
T*
(        sp->n = n;                       /* Buffer holds max of n items */) Tj
T*
(        sp->front = sp->rear = 0;        /* Empty buffer iff front == rear */) Tj
T*
(        Sem_init\(&sp->mutex, 0, 1\);      /* Binary semaphore for locking */) Tj
T*
(        Sem_init\(&sp->slots, 0, n\);      /* Initially, buf has n empty slots */) Tj
T*
(        Sem_init\(&sp->items, 0, 0\);      /* Initially, buf has zero data items */) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* Clean up buffer sp */) Tj
T*
(    void sbuf_deinit\(sbuf_t *sp\)) Tj
T*
(    {) Tj
T*
(        Free\(sp->buf\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* Insert item onto the rear of shared buffer sp */) Tj
T*
(    void sbuf_insert\(sbuf_t *sp, int item\)) Tj
T*
(    {) Tj
T*
(        P\(&sp->slots\);                           /* Wait for available slot */) Tj
T*
(        P\(&sp->mutex\);                           /* Lock the buffer */) Tj
T*
(        sp->buf[\(++sp->rear\) % \(sp->n\)] = item;  /* Insert the item */) Tj
T*
(        V\(&sp->mutex\);                           /* Unlock the buffer */) Tj
T*
(        V\(&sp->items\);                           /* Announce available item */) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* Remove and return the first item from buffer sp */) Tj
T*
(    int sbuf_remove\(sbuf_t *sp\)) Tj
T*
(    {) Tj
T*
(        int item;) Tj
T*
(        P\(&sp->items\);                           /* Wait for available item */) Tj
T*
(        P\(&sp->mutex\);                           /* Lock the buffer */) Tj
T*
(        item = sp->buf[\(++sp->front\) % \(sp->n\)]; /* Remove the item */) Tj
T*
(        V\(&sp->mutex\);                           /* Unlock the buffer */) Tj
T*
(        V\(&sp->slots\);                           /* Announce available slot */) Tj
T*
(        return item;) Tj
T*
ET
endstream
endobj
625 0 obj
<< /Length 3815 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    }) Tj
T*
() Tj
T*
(> 图 12-25 SBUF：同步对有限缓冲区并发访问的包) Tj
T*
() Tj
T*
(练习题 12.9) Tj
T*
() Tj
T*
() Tj
T*
(设 p 表示生产者数量，c 表示消费者数量，而 n 表示以项目单元为单位的缓冲区大小。对于下面的每个场景，指出 sbuf\\insert 和 sbuf\\remove) Tj
T*
(中的互斥锁信号量是否是必需的。) Tj
T*
() Tj
T*
(A. $$p=1，c=1，n\\gt1$$) Tj
T*
() Tj
T*
(B. $$p=1，c=1，n=1$$) Tj
T*
() Tj
T*
(C. $$p\\gt 1，c\\gt1，n=1$$) Tj
T*
() Tj
T*
(A. $$p=1，c=1，n\\gt1$$ ：) Tj
T*
() Tj
T*
(* 是，互斥锁是需要的，因为生产者和消费者会并发地访问缓冲区。) Tj
T*
() Tj
T*
(B. $$p=1，c=1，n=1$$ ：) Tj
T*
() Tj
T*
(* 不是，在这种情况中不需要互斥锁信号量，因为一个非空的缓冲区就等于满的缓冲区。当缓冲区包含一个项目时，生产者就被阻塞了。当缓冲区为空时，消费者就被阻塞了。所以在任意时刻，只有一个) Tj
T*
(线程可以访问缓冲区，因此不用互斥锁也能保证互斥。) Tj
T*
() Tj
T*
(C. $$p\\gt 1，c\\gt1，n=1$$ ：) Tj
T*
() Tj
T*
(* 不是，在这种情况中，也不需要互斥锁，原因与前面一种情况相同。) Tj
T*
() Tj
T*
(2. 读者—写者问题) Tj
T*
() Tj
T*
() Tj
T*
(读者—写者问题是互斥问题的一个概括。一组并发的线程要访问一个共享对象，例如一个主存中的数据结构，或者一个磁盘上的数据库。有些线程只读对象，而其他的线程只修改对象。修改对象的线程叫做) Tj
T*
(写者。只读对象的线程叫做读者。写者必须拥有对对象的独占的访问，而读者可以和无限多个其他的读者共享对象。一般来说，有无限多个并发的读者和写者。) Tj
T*
() Tj
T*
(读者—写者交互在现实系统中很常见。例如，一个在线航空预定系统中，允许有无限多个客户同时查看座位分配，但是正在预订座位的客户必须拥有对数据库的独占的访问。再来看另一个例子，在一个多线) Tj
T*
(程缓存 Web 代理中，无限多个线程可以从共享页面缓存中取出已有的页面，但是任何向缓存中写入一个新页面的线程必须拥有独占的访问。) Tj
T*
() Tj
T*
(读者—写者问题有几个变种，分别基于读者和写者的优先级。第一类读者—写者问题，读者优先，要求不要让读者等待，除非已经把使用对象的权限赋予了一个写者。换句话说，读者不会因为有一个写者在) Tj
T*
(等待而等待。第二类读者—写者问题，写者优先，要求一旦一个写者准备好可以写，它就会尽可能快地完成它的写操作。同第一类问题不同，在一个写者后到达的读者必须等待，即使这个写者也是在等待。) Tj
T*
() Tj
T*
(图 12-26 给出了一个对第一类读者—写者问题的解答。同许多同步问题的解答一样，这个解答很微妙，极具欺骗性地简单。信号量 w 控制对访问共享对象的临界区的访问。信号量 mutex) Tj
T*
(保护对共享变量 readcnt 的访问，readcnt 统计当前在临界区中的读者数量。每当一个写者进入临界区时，它对互斥锁 w 加锁，每当它离开临界区时，对 w) Tj
T*
(解锁。这就保证了任意时刻临界区中最多只有一个写者。另一方面，只有第一个进入临界区的读者对 w 加锁，而只有最后一个离开临界区的读者对 w) Tj
T*
(解锁。当一个读者进入和离开临界区时，如果还有其他读者在临界区中，那么这个读者会忽略互斥锁 w。这就意味着只要还有一个读者占用互斥锁 w，无限多数量的读者可以没有障碍地进入临界区。) Tj
T*
() Tj
T*
ET
endstream
endobj
626 0 obj
<< /Length 1849 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    /* Global variables */) Tj
T*
(    int readcnt;    /* Initially = 0 */) Tj
T*
(    sem_t mutex, w; /* Both initially = 1 */) Tj
T*
() Tj
T*
(    void reader\(void\)) Tj
T*
(    {) Tj
T*
(        while \(1\) {) Tj
T*
(            P\(&mutex\);) Tj
T*
(            readcnt++;) Tj
T*
(            if \(readcnt == 1\) /* First in */) Tj
T*
(                P\(&w\);) Tj
T*
(            V\(&mutex\);) Tj
T*
() Tj
T*
(            /* Critical section */) Tj
T*
(            /* Reading happens  */) Tj
T*
() Tj
T*
(            P\(&mutex\);) Tj
T*
(            readcnt--;) Tj
T*
(            if \(readcnt == 0\) /* Last out */) Tj
T*
(                V\(&w\);) Tj
T*
(            V\(&mutex\);) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(    void writer\(void\)) Tj
T*
(    {) Tj
T*
(        while \(1\) {) Tj
T*
(            P\(&w\);) Tj
T*
() Tj
T*
(            /* Critical section */) Tj
T*
(            /* Writing happens  */) Tj
T*
() Tj
T*
(            V\(&w\);) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-26 对第一类读者—写者问题的解答。读者优先级高于写者) Tj
T*
() Tj
T*
(对这两种读者—写者问题的正确解答可能导致饥饿（starvation），饥饿就是一个线程无限期地阻塞，无法进展。例如，图 12-26) Tj
T*
(所示的解答中，如果有读者不断地到达，写者就可能无限期地等待。) Tj
T*
() Tj
T*
(练习题 12.10) Tj
T*
() Tj
T*
() Tj
T*
(图 12-26 所示的对第一类读者—写者问题的解答给予读者较高的优先级，但是从某种意义上说，这种优先级是很弱的，因为一个离开临界区的写者可能重启一个在等待的写者，而不是一个在等待的) Tj
T*
(读者。描述出一个场景，其中这种弱优先级会导致一群写者使得一个读者饥饿。) Tj
T*
ET
endstream
endobj
627 0 obj
<< /Length 3794 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(假设一个特殊的信号量实现为每一个信号量使用了一个 LIFO 的线程栈。当一个线程在 P 操作中. 阻塞在一个信号量上，它的 ID 就被压入栈中。类似地，V 操作从栈中弹出栈顶的线程) Tj
T*
(ID，并重启这个线程。根据这个栈的实现，一个在它的临界区中的竞争的写者会简单地等待，直到在它释放这个信号量之前另一个写者阻塞在这个信号量上。在这种场景中，当两个写者来回地传递控制权) Tj
T*
(时，正在等待的读者可能会永远地等待下去。) Tj
T*
() Tj
T*
(注意，虽然用 FIFO 队列而不是用 LIFO 更符合直觉，但是使用 LIF。的栈也是对的，而且也没有违反 P 和 V 操作的语义。) Tj
T*
() Tj
T*
(旁注 - 其他同步机制) Tj
T*
() Tj
T*
() Tj
T*
(我们已经向你展示了如何利用信号量来同步线程，主要是因为它们简单、经典，并且有一个清晰的语义模型。但是你应该知道还是存在着其他同步技术的。例如，Java 线程是用一种叫做 Java) Tj
T*
(监控器（Java Monitor）【48】的机制来同步的，它提供了对信号量互斥和调度能力的更高级别的抽象；实际上，监控器可以用信号量来实现。再来看一个例子，Pthreads) Tj
T*
(接口定义了一组对互斥锁和条件变量的同步操作。Pthreads 互斥锁被用来实现互斥。条件变量用来调度对共享资源的访问，例如在一个生产者—消费者程序中的有限缓冲区。) Tj
T*
() Tj
T*
(12.5.5 综合：基于预线程化的并发服务器) Tj
T*
() Tj
T*
() Tj
T*
(我们已经知道了如何使用信号量来访问共享变量和调度对共享资源的访问。为了帮助你更清晰地理解这些思想，让我们把它们应用到一个基于称为预线程化（prethreading）技术的并发服务器) Tj
T*
(上。) Tj
T*
() Tj
T*
(在图 12-14) Tj
T*
(所示的并发服务器中，我们为每一个新客户端创建了一个新线程。这种方法的缺点是我们为每一个新客户端创建一个新线程，导致不小的代价。一个基于预线程化的服务器试图通过使用如图 12-27 ) Tj
T*
(所示的生产者—消费者模型来降低这种开销。服务器是由一个主线程和一组工作者线程构成的。主线程不断地接受来自客户端的连接请求，并将得到的连接描述符放在一个有限缓冲区中。每一个工作者线程) Tj
T*
(反复地从共享缓冲区中取出描述符，为客户端服务，然后等待下一个描述符。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 12-27 预线程化的并发服务器的组织结构。一组现有的线程不断地取出和处理来自有限缓冲区的已连接描述符) Tj
T*
() Tj
T*
(图 12-28 显示了我们怎样用 SBUF 包来实现一个预线程化的并发 echo 服务器。在初始化了缓冲区 sbuf（第 24 行）后，主线程创建了一组工作者线程（第 25 ~) Tj
T*
(26 行）。然后它进入了无限的服务器循环，接受连接请求，并将得到的已连接描述符插入到缓冲区 sbuf) Tj
T*
(中。每个工作者线程的行为都非常简单。它等待直到它能从缓冲区中取出一个已连接描述符（第 39 行），然后调用 echo\\_cnt 函数回送客户端的输入。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    #include "sbuf.h") Tj
T*
(    #define NTHREADS 4) Tj
T*
(    #define SBUFSIZE 16) Tj
T*
() Tj
T*
(    void echo_cnt\(int connfd\);) Tj
T*
(    void *thread\(void *vargp\);) Tj
T*
() Tj
T*
(    sbuf_t sbuf; /* Shared buffer of connected descriptors */) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        int i, listenfd, connfd;) Tj
T*
ET
endstream
endobj
628 0 obj
<< /Length 2588 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        socklen_t clientlen;) Tj
T*
(        struct sockaddr_storage clientaddr;) Tj
T*
(        pthread_t tid;) Tj
T*
() Tj
T*
(        if \(argc != 2\) {) Tj
T*
(            fprintf\(stderr, "usage: %s <port>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
(        listenfd = Open_listenfd\(argv[1]\);) Tj
T*
() Tj
T*
(        sbuf_init\(&sbuf, SBUFSIZE\);) Tj
T*
(        for \(i = 0; i < NTHREADS; i++\)  /* Create worker threads */) Tj
T*
(            Pthread_create\(&tid, NULL, thread, NULL\);) Tj
T*
() Tj
T*
(        while \(1\) {) Tj
T*
(            clientlen = sizeof\(struct sockaddr_storage\);) Tj
T*
(            connfd = Accept\(listenfd, \(SA *\) &clientaddr, &clientlen\);) Tj
T*
(            sbuf_insert\(&sbuf, connfd\); /* Insert connfd in buffer */) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(    void *thread\(void *vargp\)) Tj
T*
(    {) Tj
T*
(        Pthread_detach\(pthread_self\(\)\);) Tj
T*
(        while \(1\) {) Tj
T*
(            int connfd = sbuf_remove\(&sbuf\); /* Remove connfd from buffer */) Tj
T*
(            echo_cnt\(connfd\);                /* Service client */) Tj
T*
(            Close\(connfd\);) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-28 一个预线程化的并发 echo 服务器。这个服务器使用的是有一个生产者和多个消费者的生产者—消费者模型) Tj
T*
() Tj
T*
(图 12-29 所示的函数 echo\\cnt 是图 11-22 中的 echo 函数的一个版本，它在全局变量 byte\\cnt) Tj
T*
(中记录了从所有客户端接收到的累计字节数。这是一段值得研究的有趣代码，因为它向你展示了一个从线程例程调用的初始化程序包的一般技术。在这种情况中，我们需要初始化 byte\\cnt) Tj
T*
(计数器和 mutex 信号量。一个方法是我们为 SBUF 和 RIO 程序包使用过的，它要泰主线程显式地调用一个初始化函数。另外一个方法，在此显示的，是当第一次有某个线程调用) Tj
T*
(echo\\cnt 函数时，使用 pthread\\once 函数（第 19 行）去调用初始化函数。这个方法的优点是它届程序包的使用更加容易。这种方法的缺点是每一次调用) Tj
T*
(echo\\ent 都会导致调用 pthread\\_once 函数，而在大多数时候它没有做什么有用的事。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    static int byte_cnt; /* Byte counter */) Tj
T*
(    static sem_t mutex;  /* and the mutex that protects it */) Tj
T*
() Tj
T*
(    static void init_echo_cnt\(void\)) Tj
T*
(    {) Tj
T*
ET
endstream
endobj
629 0 obj
<< /Length 2984 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        Sem_init\(&mutex, 0, 1\);) Tj
T*
(        byte_cnt = 0;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    void echo_cnt\(int connfd\)) Tj
T*
(    {) Tj
T*
(        int n;) Tj
T*
(        char buf[MAXLINE];) Tj
T*
(        rio_t rio;) Tj
T*
(        static pthread_once_t once = PTHREAD_ONCE_INIT;) Tj
T*
() Tj
T*
(        Pthread_once\(&once, init_echo_cnt\);) Tj
T*
(        Rio_readinitb\(&rio, connfd\);) Tj
T*
(        while \(\(n = Rio_readlineb\(&rio, buf, MAXLINE\)\) != 0\) {) Tj
T*
(            P\(&mutex\);) Tj
T*
(            byte_cnt += n;) Tj
T*
(            printf\("server received %d \(%d total\) bytes on fd %d\\n",) Tj
T*
(                   n, byte_cnt, connfd\);) Tj
T*
(            V\(&mutex\);) Tj
T*
(            Rio_writen\(connfd, buf, n\);) Tj
T*
(        }) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-29 echo\\_cnt：echo 的一个版本，它对从客户端接收的所有字节计数) Tj
T*
() Tj
T*
(一旦程序包被初始化，echo\\cnt 函数会初始化 RIO 带缓冲区的 I/O 包（第 20 行），然后回送从客户端接收到的每一个文本行。注意，在第 23 ~ 25 行中对共享变量) Tj
T*
(byte\\cnt 的访问是被 P 和 V 操作保护的。) Tj
T*
() Tj
T*
(旁注 - 基于线程的事件驱动程序) Tj
T*
() Tj
T*
() Tj
T*
(I/O 多路复用不是编写事件驱动程序的唯一方法。例如，你可能已经注意到我们刚才开发的并发的预线程化的服务器实际上是一个事件驱动服务器，带有主线程和工作者线程的简单状态机。主线程有两) Tj
T*
(种状态（“等待连接请求” 和 “等待可用的缓冲区槽位”）、两个 I/O 事件（“连接请求到达” 和 “缓冲区槽位变为可用”）和两个转换（“接受连接请求”) Tj
T*
(和“插入缓冲区项目”）。类似地，每个工作者线程有一个状态（“等待可用的缓冲项目”）、一个 I/O 事件（“缓冲区项目变为可用”）和一个转换（“取出缓冲区项目”）。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(12.6 使用线程提高并行性) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(12.6 使用线程提高并行性) Tj
T*
() Tj
T*
() Tj
T*
(到目前为止，在对并发的研究中，我们都假设并发线程是在单处理器系统上执行的。然而，大多数现代机器具有多核处理器。并发程序通常在这样的机器上运行得更快，因为操作系统内核在多个核上并行地) Tj
T*
(调度这些并发线程，而不是在单个核上顺序地调度。在像繁忙的 Web 服务器、数据库服务器和大型科学计算代码这样的应用中利用这样的并行性是至关重要的，而且在像 Web) Tj
T*
(浏览器、电子表格处理程序和文档处理程序这样的主流应用中，并行性也变得越来越有用。) Tj
T*
ET
endstream
endobj
630 0 obj
<< /Length 3369 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(图 12-30 给出了顺序、并发和并行程序之间的集合关系。所有程序的集合能够被划分成不相交的顺序程序集合和并发程序的集合。写顺序程序只有一条逻辑流。写并发程序有多条并发流。并行程序) Tj
T*
(是一个运行在多个处理器上的并发程序。因此，并行程序的集合是并发程序集合的真子集。) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-30 &#x987A;&#x5E8F;&#x3001;&#x5E76;&#x53D1;&#x548C;&#x5E76;&#x884C;&#x) Tj
T*
(7A0B;&#x5E8F;&#x96C6;&#x5408;&#x4E4B;&#x95F4;&#x7684;&#x5173;&#x7CFB;]) Tj
T*
() Tj
T*
(并行程序的详细处理超出了本书讲述的范围，但是研究一个非常简单的示例程序能够帮助你理解并行编程的一些重要的方面。例如，考虑我们如何并行地对一列整数$$0，\\cdots，n-) Tj
T*
(1$$求和。当然，对于这个特殊的问题，有闭合形式表达式的解答（译者注：即有现成的公式来计算它，即和等于$$n\(n-) Tj
T*
(1\)/2$$），但是尽管如此，它是一个简洁和易于理解的示例，能让我们对并行程序做一些有趣的说明。) Tj
T*
() Tj
T*
(将任务分配到不同线程的最直接方法是将序列划分成 t 个不相交的区域，然后给，个不同的线程每个分配一个区域。为了简单，假设 n 是 t 的倍数，这样每个区域有以 n/t) Tj
T*
(个元素。让我们来看看多个线程并行处理分配给它们的区域的不同方法。) Tj
T*
() Tj
T*
(最简单也最直接的选择是将线程的和放入一个共享全局变量中，用互斥锁保护这个变量。图 12-31 给出了我们会如何实现这种方法。在第 28 ~ 33) Tj
T*
(行，主线程创建对等线程，然后等待它们结束。注意，主线程传递给每个对等线程一个小整数，作为唯一的线程 ID。每个对等线程会用它的线程 ID) Tj
T*
(来决定它应该计算序列的哪一部分。这个向对等线程传递一个小的唯一的线程 ID 的思想是一项通用技术，许多并行应用中都用到了它。在对等线程终止后，全局变量 gsum) Tj
T*
(包含着最终的和。然后主线程用闭合形式解答来验证结果（第 36 ~ 37 行）。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    #define MAXTHREADS 32) Tj
T*
() Tj
T*
(    void *sum_mutex\(void *vargp\); /* Thread routine */) Tj
T*
() Tj
T*
(    /* Global shared variables */) Tj
T*
(    long gsum = 0;          /* Global sum */) Tj
T*
(    long nelems_per_thread; /* Number of elements to sum */) Tj
T*
(    sem_t mutex;            /* Mutex to protect global sum */) Tj
T*
() Tj
T*
(    int main\(int argc, char **argv\)) Tj
T*
(    {) Tj
T*
(        long i, nelems, log_nelems, nthreads, myid[MAXTHREADS];) Tj
T*
(        pthread_t tid[MAXTHREADS];) Tj
T*
() Tj
T*
(        /* Get input arguments */) Tj
T*
(        if \(argc != 3\) {) Tj
T*
(            printf\("Usage: %s <nthreads> <log_nelems>\\n", argv[0]\);) Tj
T*
(            exit\(0\);) Tj
T*
(        }) Tj
T*
(        nthreads = atoi\(argv[1]\);) Tj
T*
(        log_nelems = atoi\(argv[2]\);) Tj
T*
(        nelems = \(1L << log_nelems\);) Tj
T*
(        nelems_per_thread = nelems / nthreads;) Tj
T*
(        sem_init\(&mutex, 0, 1\);) Tj
T*
() Tj
T*
(        /* Create peer threads and wait for them to finish */) Tj
T*
ET
endstream
endobj
631 0 obj
<< /Length 2728 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        for \(i = 0; i < nthreads; i++\) {) Tj
T*
(            myid[i] = i;) Tj
T*
(            Pthread_create\(&tid[i], NULL, sum_mutex, &myid[i]\);) Tj
T*
(        }) Tj
T*
(        for \(i = 0; i < nthreads; i++\)) Tj
T*
(            Pthread_join\(tid[i], NULL\);) Tj
T*
() Tj
T*
(        /* Check final answer */) Tj
T*
(        if \(gsum != \(nelems * \(nelems - 1\)\) / 2\)) Tj
T*
(            printf\("Error: result=%ld\\n", gsum\);) Tj
T*
() Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-31 psum-mutex 的主程序，使用多个线程将一个序列元素的和放入一个用互斥锁保护的共享全局变量中) Tj
T*
() Tj
T*
(图 12-32 给出了每个对等线程执行的函数。在第 4 行中，线程从线程参数中提取出线程 ID，然后用这个 ID 来决定它要计算的序列区域（第 5 ~ 6 行）。在第 9 ~ 13) Tj
T*
(行中，线程在它的那部分序列上迭代操作，每次迭代都更新共享全局变量 gsum。注意，我们很小心地用 P 和 V 互斥操作来保护每次更新。) Tj
T*
() Tj
T*
(    /* Thread routine for psum-mutex.c */) Tj
T*
(    void *sum_mutex\(void *vargp\)) Tj
T*
(    {) Tj
T*
(        long myid = *\(\(long *\)vargp\);          /* Extract the thread ID */) Tj
T*
(        long start = myid * nelems_per_thread; /* Start element index */) Tj
T*
(        long end = start + nelems_per_thread;  /* End element index */) Tj
T*
(        long i;) Tj
T*
() Tj
T*
(        for \(i = start; i < end; i++\) {) Tj
T*
(            P\(&mutex\);) Tj
T*
(            gsum += i;) Tj
T*
(            V\(&mutex\);) Tj
T*
(        }) Tj
T*
(        return NULL;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-32 psum-mutex 的线程例程。每个对等线程将各自的和累加进一个用互斥锁保护的共享全局变量中) Tj
T*
() Tj
T*
(我们在一个四核系统上，对一个大小为 $$n=2^{31}$$ 的序列运行 psum-mutex，测量它的运行时间（以秒为单位），作为线程数的函数，得到的结果难懂又令人奇怪：) Tj
T*
() Tj
T*
(|  | 线程数 |  |  |  |  |) Tj
T*
(| :--- | :---: | :---: | :---: | :---: | :---: |) Tj
T*
(| 版本 | 1 | 2 | 4 | 8 | 16 |) Tj
T*
(| psum-mutex | 68 | 432 | 719 | 552 | 599 |) Tj
T*
() Tj
T*
(程序单线程顺序运行时非常慢，几乎比多线程并行运行时慢了一个数量级。不仅如此，使用的核数越多，性能越差。造成性能差的原因是相对于内存更新操作的开销，同步操作（P 和) Tj
T*
(V）代价太大。这突显了并行编程的一项重要教训：同步开销巨大，要尽可能避免。如果无可避免，必须要用尽可能多的有用计算弥补这个开销。) Tj
T*
ET
endstream
endobj
632 0 obj
<< /Length 2846 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(在我们的例子中，一种避免同步的方法是让每个对等线程在一个私有变量中计算它自己的部分和，这个私有变量不与其他任何线程共享，如图 12-33 所示。主线程（图中未显示）定义一个全局数组) Tj
T*
(psum，每个对等线程 i 把它的部分和累积在 psum\\[i\\]) Tj
T*
(中。因为小心地给了每个对等线程一个不同的内存位置来更新，所以不需要用互斥锁来保护这些更新。唯一需要同步的地方是主线程必须等待所有的子线程完成。在对等线程结束后，主线程把 psum) Tj
T*
(向量的元素加起来，得到最终的结果。) Tj
T*
() Tj
T*
(    /* Thread routine for psum-array.c */) Tj
T*
(    void *sum_array\(void *vargp\)) Tj
T*
(    {) Tj
T*
(        long myid = *\(\(long *\)vargp\);          /* Extract the thread ID */) Tj
T*
(        long start = myid * nelems_per_thread; /* Start element index */) Tj
T*
(        long end = start + nelems_per_thread;  /* End element index */) Tj
T*
(        long i;) Tj
T*
() Tj
T*
(        for \(i = start; i < end; i++\) {) Tj
T*
(            psum[myid] += i;) Tj
T*
(        }) Tj
T*
(        return NULL;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-33 psum-array 的线程例程。每个对等线程把它的部分和累积在一个私有数组元素中，不与其他任何对等线程共享该元素) Tj
T*
() Tj
T*
(在四核系统上运行 psum-array 时，我们看到它比 psum-mutex 运行得快好几个数量级：) Tj
T*
() Tj
T*
(|  | 线程数 |  |  |  |  |) Tj
T*
(| :--- | ---: | ---: | ---: | ---: | ---: |) Tj
T*
(| 版本 | 1 | 2 | 4 | 8 | 16 |) Tj
T*
(| psum-mutex | 68.00 | 432.00 | 719.00 | 552.00 | 599.00 |) Tj
T*
(| psum-array | 7.26 | 3.64 | 1.91 | 1.85 | 1.84 |) Tj
T*
() Tj
T*
(在第 5 章中，我们学习到了如何使用局部变量来消除不必要的内存引用。图 12-34) Tj
T*
(展示了如何应用这项原则，让每个对等线程把它的部分和累积在一个局部变量而不是全局变量中。当在四核机器上运行 psum-local 时，得到一组新的递减的运行时间：) Tj
T*
() Tj
T*
(|  | 线程数 |  |  |  |  |) Tj
T*
(| :--- | ---: | ---: | ---: | ---: | ---: |) Tj
T*
(| 版本 |  | 4 | 8 | 16 |  |) Tj
T*
(| psum-mutex | 68.00 | 432.00 | 719.00 | 552.00 | 599.00 |) Tj
T*
(| psum-array | 7.26 | 3.64 | 1.91 | 1.85 | 1.84 |) Tj
T*
(| psum-local | 1.06 | 0.54 | 0.28 | 0.29 | 0.30 |) Tj
T*
() Tj
T*
(    /* Thread routine for psum-local.c */) Tj
T*
(    void *sum_local\(void *vargp\)) Tj
T*
(    {) Tj
T*
(        long myid = *\(\(long *\)vargp\);          /* Extract the thread ID */) Tj
T*
(        long start = myid * nelems_per_thread; /* Start element index */) Tj
T*
(        long end = start + nelems_per_thread;  /* End element index */) Tj
T*
ET
endstream
endobj
633 0 obj
<< /Length 3416 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        long i, sum = 0;) Tj
T*
() Tj
T*
(        for \(i = start; i < end; i++\) {) Tj
T*
(            sum += i;) Tj
T*
(        }) Tj
T*
(        psum[myid] = sum;) Tj
T*
(        return NULL;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-34 psum-local 的线程例程。每个对等线程把它的部分和累积在一个局部变量中) Tj
T*
() Tj
T*
(从这个练习可以学习到一个重要的经验，那就是写并行程序相当棘手。对代码看上去很小的改动可能会对性能有极大的影响。) Tj
T*
() Tj
T*
(刻画并行程序的性能) Tj
T*
() Tj
T*
() Tj
T*
(图 12-35 给出了图 12-34 中程序 psum-local 的运行时间，它是线程数的函数。在每个情况下，程序运行在一个有四个处理器核的系统上，对一个$$n=2^{31}$$) Tj
T*
(个元素的序列求和。我们看到，随着线程数的增加，运行时间下降，直到增加到四个线程，此时，运行时间趋于平稳，甚至开始有点增加。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
(> 图 12-35 psum-local 的性能（图 12-34）。用四个处理器核对一个$$2^{32}$$个元素序列求和) Tj
T*
() Tj
T*
(在理想的情况中，我们会期望运行时间随着核数的增加线性下降。也就是说，我们会期望线程数每增加一倍，运行时间就下降一半。确实是这样，直到到达 t &gt; 4 的时候，此时四个核中的每) Tj
T*
(一个都忙于运行至少一个线程。随着线程数量的增加，运行时间实际上增加了一点儿，这是由于在一个核上多个线程上下文切换的开销。由于这个原因，并行程序常常被写为每个核上只运行一个线程。) Tj
T*
() Tj
T*
(虽然绝对运行时间是衡量程序性能的终极标准，但是还是有一些有用的相对衡量标准能够说明并行程序有多好地利用了潜在的并行性。并行程序的加速比（speedup）通常定义为) Tj
T*
() Tj
T*
($$) Tj
T*
(Sp=\\frac{T1}{T_p}) Tj
T*
($$) Tj
T*
() Tj
T*
(这里 p 是处理器核的数量，$$Tk$$是在 k 个核上的运行时间。这个公式有时被称为强扩展（strong) Tj
T*
(scaling）。当$$T1$$是程序顺序执行版本的执行时间时，$$Sp$$称为绝对加速比（absolute) Tj
T*
(speedup）。当$$T1$$是程序并行版本在一个核上的执行时间时，$$S_p$$称为相对加速比（relative speedup）。绝对加速比比相对加速比能更真实地衡量并行的好) Tj
T*
(处。即使是当并行程序在一个处理器上运行时，也常常会受到同步开销的影响，而这些开销会人为地增加相对加速比的数值，因为它们增加了分子的大小。另一方面，绝对加速比比相对加速比更难以测量，) Tj
T*
(因为测量绝对加速比需要程序的两种不同的版本。对于复杂的并行代码，创建一个独立的顺序版本可能不太实际，或者因为代码太复杂，或者因为源代码不可得。) Tj
T*
() Tj
T*
(—种相关的测量量称为效率（efficiency），定义为) Tj
T*
() Tj
T*
($$) Tj
T*
(Ep = \\frac{Sp}{p}=\\frac{T1}{pTp}) Tj
T*
($$) Tj
T*
() Tj
T*
(通常表示为范围在$$\(0,100]$$之间的百分比。效率是对由于并行化造成的开销的衡量。具有高效率的程序比效率低的程序在有用的工作上花费更多的时间，在同步和通信上花费更少的时间。) Tj
T*
() Tj
T*
ET
endstream
endobj
634 0 obj
<< /Length 3159 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(图 12-36 给出了我们并行求和示例程序的各个加速比和效率测量值。像这样超过 90% 的效率是非常好的，但是不要被欺骗了。能取得这么高的效率是因为我们的问题非常容易并行化。在实际) Tj
T*
(中，很少会这样。数十年来，并行编程一直是一个很活跃的研究领域。随着商用多核机器的出现，这些机器的核数每几年就翻一番，并行编程会继续是一个深入、困难而活跃的研究领域。) Tj
T*
() Tj
T*
(|  |  |  |  |  |  |) Tj
T*
(| :--- | :---: | :---: | :---: | :---: | :---: |) Tj
T*
(| 线程（t） | 1 | 2 | 4 | 8 | 16 |) Tj
T*
(| 核（p） | 1 | 2 | 4 | 4 | 4 |) Tj
T*
(| 运行时间（$$T_p$$） | 1.06 | 0.54 | 0.28 | 0.29 | 0.30 |) Tj
T*
(| 加速比（$$S_p$$） | 1 | 1.9 | 3.8 | 3.7 | 3.5 |) Tj
T*
(| 效率（$$E_p$$） | 100% | 98% | 95% | 91% | 88% |) Tj
T*
() Tj
T*
(> 图 12-36   图 12-35 中执行时间的加速比和并行效率) Tj
T*
() Tj
T*
(加速比还有另外一面，称为弱扩展（weak scaling），在增加处理器数量的同时，增加问题的规模，这样随着处理器数量的增加，每个处理器执行的工作量保持不变。在这种描述中，加速比和) Tj
T*
(效率被表达为单位时间完成的工作总量。例如，如果将处理器数量翻倍，同时每个小时也做了两倍的工作量，那么我们就有线性的加速比和 100% 的效率。) Tj
T*
() Tj
T*
(弱扩展常常是比强扩展更真实的衡量值，因为它更准确地反映了我们用更大的机器做更多的工作的愿望。对于科学计算程序来说尤其如此，科学计算问题的规模很容易增加，更大的问题规模直接就意味着更) Tj
T*
(好地预测。不过，还是有一些应用的规模不那么容易增加，对于这样的应用，强扩展是更合适的。例如，实时信号处理应用所执行的工作量常常是由产生信号的物理传感器的属性决定的。改变工作总量需要) Tj
T*
(用不同的物理传感器，这不太实际或者不太必要。对于这类应用，我们通常想要用并行来尽可能快地完成定量的工作。) Tj
T*
() Tj
T*
(练习题 12.11) Tj
T*
() Tj
T*
() Tj
T*
(对于下表中的并行程序，填写空白处。假设使用强扩展。) Tj
T*
() Tj
T*
(|  |  |  |  |) Tj
T*
(| :--- | :---: | :---: | :---: |) Tj
T*
(| 线程（t） | 1 | 2 | 4 |) Tj
T*
(| 核（p） | 1 | 2 | 4 |) Tj
T*
(| 运行时间（$$T_p$$） | 12 | 8 | 6 |) Tj
T*
(| 加速比（$$S_p$$） |  | 1.5 |  |) Tj
T*
(| 效率（$$E_p$$） | 100% |  | 50% |) Tj
T*
() Tj
T*
(这道题简单地检查你对加速比和并行效率的理解：) Tj
T*
() Tj
T*
(|  |  |  |  |) Tj
T*
(| :--- | :---: | :---: | :---: |) Tj
T*
(| 线程（t） | 1 | 2 | 4 |) Tj
T*
(| 核（p） | 1 | 2 | 4 |) Tj
T*
(| 运行时间（$$T_p$$） | 12 | 8 | 6 |) Tj
T*
(| 加速比（$$S_p$$） | 1 | 1.5 | 2 |) Tj
T*
(| 效率（$$E_p$$） | 100% | 75% | 50% |) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(12.7 其他并发问题) Tj
T*
ET
endstream
endobj
635 0 obj
<< /Length 3437 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(================================================================================) Tj
T*
() Tj
T*
(12.7 其他并发问题) Tj
T*
() Tj
T*
() Tj
T*
(你可能已经注意到了，一旦我们要求同步对共享数据的访问，那么事情就变得复杂得多了。迄今为止，我们已经看到了用于互斥和生产者—消费者同步的技术，但这仅仅是冰山一角。同步从根本上说是很难) Tj
T*
(的问题，它引出了在普通的顺序程序中不会出现的问题。这一小节是关于你在写并发程序时需要注意的一些问题的（非常不完整的）综述。为了让事情具体化，我们将以线程为例描述讨论。不过要记住，这) Tj
T*
(些典型问题是任何类型的并发流操作共享资源时都会出现的。) Tj
T*
() Tj
T*
(12.7.1 线程安全) Tj
T*
() Tj
T*
() Tj
T*
(当用线程编写程序时，必须小心地编写那些具有称为线程安全性（thread safety）属性的函数。一个函数被称为线程安全的（thread-) Tj
T*
(safe），当且仅当被多个并发线程反复地调用时，它会一直产生正确的结果。如果一个函数不是线程安全的，我们就说它是线程不安全的（thread-unsafe）。) Tj
T*
() Tj
T*
(我们能够定义出四个（不相交的）线程不安全函数类：) Tj
T*
() Tj
T*
(第 1 类：不保护共享变量的函数。我们在图 12-16 的 thread 函数中就已经遇到了这样的问题，该函数对一个未受保护的全局计数器变量加) Tj
T*
(1。将这类线程不安全函数变成线程安全的，相对而言比较容易：利用像 P 和 V) Tj
T*
(操作这样的同步操作来保护共享的变量。这个方法的优点是在调用程序中不需要做任何修改。缺点是同步操作将减慢程序的执行时间。) Tj
T*
() Tj
T*
(第 2 类：保持跨越多个调用的状态的函数。一个伪随机数生成器是这类线程不安全函数的简单例子。请参考图 12-37 中的伪随机数生成器程序包。rand) Tj
T*
(函数是线程不安全的，因为当前调用的结果依赖于前次调用的中间结果。当调用 srand 为 rand 设置了一个种子后，我们从一个单线程中反复地调用) Tj
T*
(rand，能够预期得到一个可重复的随机数字序列。然而，如果多线程调用 rand 函数，这种假设就不再成立了。) Tj
T*
() Tj
T*
(    unsigned next_seed = 1;) Tj
T*
() Tj
T*
(    /* rand - return pseudorandom integer in the range 0..32767 */) Tj
T*
(    unsigned rand\(void\)) Tj
T*
(    {) Tj
T*
(        next_seed = next_seed * 1103515245 + 12543;) Tj
T*
(        return \(unsigned\)\(next_seed >> 16\) % 32768;) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* srand - set the initial seed for rand\(\) */) Tj
T*
(    void srand\(unsigned new_seed\)) Tj
T*
(    {) Tj
T*
(        next_seed = new_seed;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-37 一个线程不安全的伪随机数生成器（基于【61】）) Tj
T*
() Tj
T*
(使得像 rand 这样的函数线程安全的唯一方式是重写它，使得它不再使用任何 static 数据，而是依靠调用者在参数中传递状态信息。这样做的缺点是，程序员现在还要被迫修) Tj
T*
() Tj
T*
(改调用程序中的代码。在一个大的程序中，可能有成百上千个不同的调用位置，做这样的修改将是非常麻烦的，而且容易出错。) Tj
T*
() Tj
T*
ET
endstream
endobj
636 0 obj
<< /Length 4298 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(第 3 类：返回指向静态变量的指针的函数。某些函数，例如 ctime 和 gethost-byname，将计算结果放在一个 static) Tj
T*
(变量中，然后返回一个指向这个变量的指针。如果我们从并发线程中调用这些函数，那么将可能发生灾难，因为正在被一个线程使用的结果会被另一个线程悄悄地覆盖了。) Tj
T*
() Tj
T*
(有两种方法来处理这类线程不安全函数。一种选择是重写函数，使得调用者传递存放结果的变量的地址。这就消除了所有共享数据，但是它要求程序员能够修改函数的源代码。) Tj
T*
() Tj
T*
(如果线程不安全函数是难以修改或不可能修改的（例如，代码非常复杂或是没有源代码可用），那么另外一种选择就是使用加锁—复制（lock-and-copy）技术。基本思想是将线程不安全函数) Tj
T*
(与互斥锁联系起来。在每一个调用位置，对互斥锁加锁，调用线程不安全函数，将函数返回的结果复制到一个私有的内存位置，然后对互斥锁解锁。为了尽可能地减少对调用者的修改，你应该定义一个线程) Tj
T*
(安全的包装函数，它执行加锁—复制，然后通过调用这个包装函数来取代所有对线程不安全函数的调用。例如，图 12-38 给出了 ctime) Tj
T*
(的一个线程安全的版本，利用的就是加锁—复制技术。) Tj
T*
() Tj
T*
(    char *ctime_ts\(const time_t *timep, char *privatep\)) Tj
T*
(    {) Tj
T*
(        char *sharedp;) Tj
T*
() Tj
T*
(        P\(&mutex\);) Tj
T*
(        sharedp = ctime\(timep\);) Tj
T*
(        strcpy\(privatep, sharedp\); /* Copy string from shared to private */) Tj
T*
(        V\(&mutex\);) Tj
T*
(        return privatep;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-38 C 标准库函数 ctime 的线程安全的包装函数。使用加锁—复制技术调用一个第 3 类线程不安全函数) Tj
T*
() Tj
T*
(第 4 类：调用线程不安全函数的函数。如果函数 f 调用线程不安全函数 g，那么 f 就是线程不安全的吗？不一定。如果 g 是第 2 类函数，即依赖于跨越多次调用的状态，那么 f) Tj
T*
(也是线程不安全的，而且除了重写 g 以外，没有什么办法。然而，如果 g 是第 1 类或者第 3 类函数，那么只要你用一个互斥锁保护调用位置和任何得到的共享数据，f) Tj
T*
(仍然可能是线程安全的。在图 12-38 中我们看到了一个这种情况很好的示例，其中我们使用加锁—复制编写了一个线程安全函数，它调用了一个线程不安全的函数。) Tj
T*
() Tj
T*
(12.7.2 可重入性) Tj
T*
() Tj
T*
() Tj
T*
(有一类重要的线程安全函数，叫做可重入函数（reentrant function），其特点在于它们具有这样一种属性：当它们被多个线程调用时，不会引用任何共享数据。尽管线程安全和可重入) Tj
T*
(有时会（不正确地）被用做同义词，但是它们之间还是有清晰的技术差别，值得留意。图 12-39) Tj
T*
(展示了可重入函数、线程安全函数和线程不安全函数之间的集合关系。所有函数的集合被划分成不相交的线程安全和线程不安全函数集合。可重入函数集合是线程安全函数的一个真子集。) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-39 &#x53EF;&#x91CD;&#x5165;&#x51FD;&#x6570;&#x3001;&#x7EBF;&#x7A0B;&#x) Tj
T*
(5B89;&#x5168;&#x51FD;&#x6570;&#x548C;&#x7EBF;&#x7A0B;&#x4E0D;&#x5B89;&#x5168;&#x51FD;&#x65) Tj
T*
(70;&#x4E4B;&#x95F4;&#x7684;&#x96C6;&#x5408;&#x5173;&#x7CFB;]) Tj
T*
() Tj
T*
(可重入函数通常要比不可重入的线程安全的函数高效一些，因为它们不需要同步操作。更进一步来说，将第 2) Tj
T*
(类线程不安全函数转化为线程安全函数的唯一方法就是重写它，使之变为可重入的。例如，图 12-40 展示了图 12-37 中 rand) Tj
T*
(函数的一个可重入的版本。关键思想是我们用一个调用者传递进来的指针取代了静态的 next 变量。) Tj
T*
() Tj
T*
(    /* rand_r - return a pseudorandom integer on 0..32767 */) Tj
T*
(    int rand_r\(unsigned int *nextp\)) Tj
T*
(    {) Tj
T*
(        *nextp = *nextp * 1103515245 + 12345;) Tj
T*
ET
endstream
endobj
637 0 obj
<< /Length 3434 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(        return \(unsigned int\)\(*nextp / 65536\) % 32768;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-40 rand\\_r：图 12-37 中的 rand 函数的可重入版本) Tj
T*
() Tj
T*
(检査某个函数的代码并先验地断定它是可重入的，这可能吗？不幸的是，不一定能这样。如果所有的函数参数都是传值传递的（即没有指针），并且所有的数据引用都是本地的自动栈变量（即没有引用静态) Tj
T*
(或全局变量），那么函数就是显式可重入的（explicitly reentrant），也就是说，无论它是被如何调用的，都可以断言它是可重入的。) Tj
T*
() Tj
T*
(然而，如果把假设放宽松一点，允许显式可重入函数中一些参数是引用传递的（即允许它们传递指针），那么我们就得到了一个隐式可重入的（implicitly) Tj
T*
(reentrant）函数，也就是说，如果调用线程小心地传递指向非共享数据的指针，那么它是可重入的。例如，图 12-40 中的 rand\\_r 函数就是隐式可重入的。) Tj
T*
() Tj
T*
(我们总是使用术语可重入的（reentrant）既包括显式可重入函数也包括隐式可重入函数。然而，认识到可重入性有时既是调用者也是被调用者的属性，并不只是被调用者单独的属性是非常重要的) Tj
T*
(。) Tj
T*
() Tj
T*
(练习题 12.12) Tj
T*
() Tj
T*
() Tj
T*
(图 12-38 中的 ctime\\_ts 函数是线程安全的，但不是可重入的。请解释说明。) Tj
T*
() Tj
T*
(ctime\\_ts 函数不是可重入函数，因为每次调用都共享相同的由 gethostbyname 函数返回的 static 变量。然而，它是线程安全的，因为对共享变量的访问是被 P) Tj
T*
(和 V 操作保护的，因此是互斥的。) Tj
T*
() Tj
T*
(12.7.3 在线程化的程序中使用已存在的库函数) Tj
T*
() Tj
T*
() Tj
T*
(大多数 Linux 函数，包括定义在标准 C 库中的函数（例如 malloc、free、realloc、printf 和 scanf）都是线程安全的，只有一小部分是例外。图) Tj
T*
(12-41 列出了常见的例外。（参考【110】可以得到一个完整的列表 Jstrtok 函数是一个已弃用的（不推荐使用）函数。asctime、ctime 和 localtime) Tj
T*
(函数是在不同时间和数据格式间相互来回转换时经常使用的函数。gethostbyname、gethostbyaddr 和 inet\\ntoa) Tj
T*
(函数是已弃用的网络编程函数，已经分别被可重入的 getaddrinfo、getnameinfo 和 inet\\ntop 函数取代（见第 11 章）。除了 rand 和 strtok) Tj
T*
(以外，所有这些线程不安全函数都是第 3 类的，它们返回一个指向静态变量的指针。如果我们需要在一个线程化的程序中调用这些函数中的某一个，对调用者来说最不惹麻烦的方法是加锁—复制。) Tj
T*
() Tj
T*
(| 线程不安全函数 | 线程不安全类 | Linux 线程安全版本 |) Tj
T*
(| :--- | :---: | :--- |) Tj
T*
(| rand | 2 | rand\\_r |) Tj
T*
(| strtok | 2 | strtok\\_r |) Tj
T*
(| asctime | 3 | asctime\\_r |) Tj
T*
(| ctime | 3 | ctime\\_r |) Tj
T*
(| gethostbyaddr | 3 | gethostbyaddr\\_r |) Tj
T*
(| gethostbyname | 3 | gethostbyname\\_r |) Tj
T*
(| inet\\_ntoa | 3 | （无） |) Tj
T*
(| localtime | 3 | localtime\\_r |) Tj
T*
() Tj
T*
(> 图 12-41 常见的线程不安全的库函数) Tj
T*
() Tj
T*
(然而，加锁—复制方法有许多缺点。) Tj
T*
() Tj
T*
ET
endstream
endobj
638 0 obj
<< /Length 2651 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(* 首先，额外的同步降低了程序的速度。) Tj
T*
(* 第二，像 gethostbyname 这样的函数返回指向复杂结构的结构的指针，要复制整个结构层次，需要深层复制（deepcopy）结构。) Tj
T*
(* 第三，加锁—复制方法对像 rand 这样依赖跨越调用的静态状态的第 2 类函数并不有效。) Tj
T*
() Tj
T*
(因此，Linux 系统提供大多数线程不安全函数的可重入版本。可重入版本的名字总是以 “\\r” 后缀结尾。例如，asctime 的可重入版本就叫做) Tj
T*
(asctime\\r。我们建议尽可能地使用这些函数。) Tj
T*
() Tj
T*
(12.7.4 竞争) Tj
T*
() Tj
T*
() Tj
T*
(当一个程序的正确性依赖于一个线程要在另一个线程到达 y 点之前到达它的控制流中的 x) Tj
T*
(点时，就会发生竞争（race）。通常发生竞争是因为程序员假定线程将按照某种特殊的轨迹线穿过执行状态空间，而忘记了另一条准则规定：多线程的程序必须对任何可行的轨迹线都正确工作。) Tj
T*
() Tj
T*
(例子是理解竞争本质的最简单的方法。让我们来看看图 12-42 中的简单程序。主线程创建了四个对等线程，并传递一个指向一个唯一的整数 ID) Tj
T*
(的指针到每个线程。每个对等线程复制它的参数中传递的 ID 到一个局部变量中（第 22 行），然后输出一个包含这个 ID) Tj
T*
(的信息。它看上去足够简单，但是当我们在系统上运行这个程序时，我们得到以下不正确的结果：) Tj
T*
() Tj
T*
(    /* WARNING: This code is buggy! */) Tj
T*
(    #include "csapp.h") Tj
T*
(    #define N 4) Tj
T*
() Tj
T*
(    void *thread\(void *vargp\);) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        pthread_t tid[N];) Tj
T*
(        int i;) Tj
T*
() Tj
T*
(        for \(i = 0; i < N; i++\)) Tj
T*
(            Pthread_create\(&tid[i], NULL, thread, &i\);) Tj
T*
(        for \(i = 0; i < N; i++\)) Tj
T*
(            Pthread_join\(tid[i], NULL\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* Thread routine */) Tj
T*
(    void *thread\(void *vargp\)) Tj
T*
(    {) Tj
T*
(        int myid = *\(\(int *\)vargp\);) Tj
T*
(        printf\("Hello from thread %d\\n", myid\);) Tj
T*
(        return NULL;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-42 一个具有竞争的程序) Tj
T*
() Tj
T*
(问题是由每个对等线程和主线程之间的竞争引起的。你能发现这个竞争吗？下面是发生的情况。当主线程在第 13 行创建了一个对等线程，它传递了一个指向本地栈变量 i) Tj
T*
ET
endstream
endobj
639 0 obj
<< /Length 2115 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(的指针。在此时，竞争出现在下一次在第 12 行对 i 加 1 和第 22 行参数的间接引用和赋值之间。如果对等线程在主线程执行第 12 行对 i 加 1 之前就执行了第 22) Tj
T*
(行，那么 myid 变量就得到正确的 ID。否则，它包含的就会是其他线程的) Tj
T*
(ID。令人惊慌的是，我们是否得到正确的答案依赖于内核是如何调度线程的执行的。在我们的系统中它失败了，但是在其他系统中，它可能就能正确工作，让程序员) Tj
T*
(“幸福地”察觉不到程序的严重错误。) Tj
T*
() Tj
T*
(为了消除竞争，我们可以动态地为每个整数 ID 分配一个独立的块，并且传递给线程例程一个指向这个块的指针，如图 12-43 所示（第 12 ~ 14) Tj
T*
(行）。请注意线程例程必须释放这些块以避免内存泄漏。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
(    #define N 4) Tj
T*
() Tj
T*
(    void *thread\(void *vargp\);) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        pthread_t tid[N];) Tj
T*
(        int i, *ptr;) Tj
T*
() Tj
T*
(        for \(i = 0; i < N; i++\) {) Tj
T*
(            ptr = Malloc\(sizeof\(int\)\);) Tj
T*
(            *ptr = i;) Tj
T*
(            Pthread_create\(&tid[i], NULL, thread, ptr\);) Tj
T*
(        }) Tj
T*
(        for \(i = 0; i < N; i++\)) Tj
T*
(            Pthread_join\(tid[i], NULL\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* Thread routine */) Tj
T*
(    void *thread\(void *vargp\)) Tj
T*
(    {) Tj
T*
(        int myid = *\(\(int *\)vargp\);) Tj
T*
(        Free\(vargp\);) Tj
T*
(        printf\("Hello from thread %d\\n", myid\);) Tj
T*
(        return NULL;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-43   图 12-42 中程序的一个没有竞争的正确版本) Tj
T*
() Tj
T*
(当我们在系统上运行这个程序时，现在得到了正确的结果：) Tj
T*
() Tj
T*
(    linux> ./race) Tj
T*
(    Hello from thread 1) Tj
T*
(    Hello from thread 3) Tj
T*
(    Hello from thread 2) Tj
T*
(    Hello from thread 3) Tj
T*
ET
endstream
endobj
640 0 obj
<< /Length 3406 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(练习题 12.13) Tj
T*
() Tj
T*
() Tj
T*
(在图 12-43 中，我们可能想要在主线程中的第 14 行后立即释放已分配的内存块，而不是在对等线程中释放它。但是这会是个坏注意。为什么？) Tj
T*
() Tj
T*
(如果在第 14 行调用了 pthread\\_create 之后，我们立即释放块，那么将引入一个新的竞争，这次竞争发生在主线程对 free 的调用和线程例程中第 24) Tj
T*
(行的赋值语句之间。) Tj
T*
() Tj
T*
(练习题 12.14) Tj
T*
() Tj
T*
() Tj
T*
(A. 在图 12-43 中，我们通过为每个整数 ID 分配一个独立的块来消除竞争。给出一个不调用 malloc 或者 free 函数的不同的方法。) Tj
T*
() Tj
T*
(B. 这种方法的利弊是什么？) Tj
T*
() Tj
T*
(A. 另一种方法是直接传递整数 ****i，而不是传递一个指向 i 的指针：) Tj
T*
() Tj
T*
(    for \(i = 0; i < N; i++\)) Tj
T*
(        Pthread_create\(&tid[i], NULL, thread, \(void *\)i\);) Tj
T*
() Tj
T*
(在线程例程中，我们将参数强制转换成一个 int 类型，并将它赋值给 myid：) Tj
T*
() Tj
T*
(    int myid = \(int\) vargp;) Tj
T*
() Tj
T*
(B. 优点是它通过消除对 malloc 和 free 的调用降低了开销。一个明显的缺点是，它假设指针至少和 int) Tj
T*
(一样大。即便这种假设对于所有的现代系统来说都为真，但是它对于那些过去遗留下来的或今后的系统来说可能就不为真了。) Tj
T*
() Tj
T*
(12.7.5 死锁) Tj
T*
() Tj
T*
() Tj
T*
(信号量引入了一种潜在的令人厌恶的运行时错误，叫做死锁（deadlock），它指的是一组线程被阻塞了，等待一个永远也不会为真的条件。进度图对于理解死锁是一个无价的工具。例如，图) Tj
T*
(12-44 展示了一对用两个信号量来实现互斥的线程的进程图。) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-44 &#x4E00;&#x4E2A;&#x4F1A;&#x6B7B;&#x9501;&#x7684;&#x7A0B;&#x5E8F;&#x) Tj
T*
(7684;&#x8FDB;&#x5EA6;&#x56FE;]) Tj
T*
() Tj
T*
(从这幅图中，我们能够得到一些关于死锁的重要知识：) Tj
T*
() Tj
T*
(* 程序员使用 P 和 V 操作顺序不当，以至于两个信号量的禁止区域重叠。如果某个执行轨迹线碰巧到达了死锁状态) Tj
T*
(d，那么就不可能有进一步的进展了，因为重叠的禁止区域阻塞了每个合法方向上的进展。换句话说，程序死锁是因为每个线程都在等待其他线程执行一个根不可能发生的 V 操作。) Tj
T*
(* 重叠的禁止区域引起了一组称为死锁区域（deadlock) Tj
T*
(region）的状态。如果一个轨迹线碰巧到达了一个死锁区域中的状态，那么死锁就是不可避免的了。轨迹线可以进入死锁区域，但是它们不可能离开。) Tj
T*
(* 死锁是一个相当困难的问题，因为它不总是可预测的。一些幸运的执行轨迹线将绕开死锁区域，而其他的将会陷入这个区域。图 12-44) Tj
T*
(展示了每种情况的一个示例。对于程序员来说，这其中隐含的着实令人惊慌。你可以运行一个程序 1000) Tj
T*
(次不出任何问题，但是下一次它就死锁了。或者程序在一台机器上可能运行得很好，但是在另外的机器上就会死锁。最糟糕的是，错误常常是不可重复的，因为不同的执行有不同的轨迹线。) Tj
T*
ET
endstream
endobj
641 0 obj
<< /Length 2066 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(程序死锁有很多原因，要避免死锁一般而言是很困难的。然而，当使用二元信号量来实现互斥时，如图 12-44 所示，你可以应用下面的简单而有效的规则来避免死锁：) Tj
T*
() Tj
T*
(互斥锁加锁顺序规则：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的。) Tj
T*
() Tj
T*
(例如，我们可以通过这样的方法来解决图 12-44 中的死锁问题：在每个线程中先对 s 加锁，然后再对 t 加锁。图 12-45 展示了得到的进度图。) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-45) Tj
T*
(&#x4E00;&#x4E2A;&#x65E0;&#x6B7B;&#x9501;&#x7A0B;&#x5E8F;&#x7684;&#x8FDB;&#x5EA6;&#x56FE;]) Tj
T*
() Tj
T*
(练习题 12.15) Tj
T*
() Tj
T*
() Tj
T*
(思考下面的程序，它试图使用一对信号量来实现互斥。) Tj
T*
() Tj
T*
(    初始时： s = 1, t = 0.) Tj
T*
() Tj
T*
(    线程 1    |   线程 2) Tj
T*
(    ---------|-----------) Tj
T*
(    P\(s\);    |   P\(s\);) Tj
T*
(    V\(s\);    |   V\(s\);) Tj
T*
(    P\(t\);    |   P\(t\);) Tj
T*
(    V\(t\);    |   V\(t\);) Tj
T*
() Tj
T*
(A. 画出这个程序的进度图。) Tj
T*
() Tj
T*
(B. 它总是会死锁吗？) Tj
T*
() Tj
T*
(C. 如果是，那么对初始信号量的值做哪些简单的改变就能消除这种潜在的死锁呢？) Tj
T*
() Tj
T*
(D. 画出得到的无死锁程序的进度图。) Tj
T*
() Tj
T*
(A. 原始的程序的进度图如图 12-48 所示。) Tj
T*
() Tj
T*
([Image: &#x56FE; 12-48 &#x4E00;&#x4E2A;&#x6709;&#x6B7B;&#x9501;&#x7684;&#x7A0B;&#x5E8F;&#x) Tj
T*
(7684;&#x8FDB;&#x5EA6;&#x56FE;]) Tj
T*
() Tj
T*
(B. 因为任何可行的轨迹最终都陷入死锁状态中，所以这个程序总是会死锁。) Tj
T*
() Tj
T*
(C. 为了消除潜在的死锁，将二元信号量 t 初始化为 1 而不是 0。) Tj
T*
() Tj
T*
(D. 改成后的程序的进度图如图 12-49 所示。) Tj
T*
() Tj
T*
([Image: Image]) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
642 0 obj
<< /Length 4079 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(================================================================================) Tj
T*
(12.8 小结) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(12.8 小结) Tj
T*
() Tj
T*
() Tj
T*
(一个并发程序是由在时间上重叠的一组逻辑流组成的。在这一章中，我们学习了三种不同的构建并发程序的机制：进程、I/O 多路复用和线程。我们以一个并发网络服务器作为贯穿全章的应用程序。) Tj
T*
() Tj
T*
(进程是由内核自动调度的，而且因为它们有各自独立的虚拟地址空间，所以要实现共享数据，必须要有显式的 IPC 机制。事件驱动程序创建它们自己的并发逻辑流，这些逻辑流被模型化为状态机，用) Tj
T*
(I/O 多路复用来显式地调度这些流。因为程序运行在一个单一进程中，所以在流之间共享数据速度很快而且很容易。线程是这些方法的混合。同基于进程的流一样，线程也是由内核自动调度的。同基于) Tj
T*
(I/O 多路复用的流一样，线程是运行在一个单一进程的上下文中的，因此可以快速而方便地共享数据。) Tj
T*
() Tj
T*
(无论哪种并发机制，同步对共享数据的并发访问都是一个困难的问题。提出对信号量的 P 和 V 操作就是为了帮助解决这个问题。信号量操作可以用来提供对共享数据的互斥访问，也对诸如生产者—) Tj
T*
(消费者程序中有限缓冲区和读者—写者系统中的共享对象这样的资源访问进行调度。一个并发预线程化的 echo 服务器提供了信号量使用场景的很好的例子。) Tj
T*
() Tj
T*
(并发也引入了其他一些困难的问题。被线程调用的函数必须具有一种称为线程安全的属性。我们定义了四类线程不安全的函数，以及一些将它们变为线程安全的建议。可重入函数是线程安全函数的一个真子) Tj
T*
(集，它不访问任何共享数据。可重入函数通常比不可重入函数更为有效，因为它们不需要任何同步原语。竞争和死锁是并发程序中出现的另一些困难的问题。当程序员错误地假设逻辑流该如何调度时，就会) Tj
T*
(发生竞争。当一个流等待一个永远不会发生的事件时，就会产生死锁。) Tj
T*
() Tj
T*
(参考文献说明) Tj
T*
() Tj
T*
() Tj
T*
(信号量操作是 Dijkstra 提出的【31】。进度图的概念是 Coffman【23】提出的，后来由 Carson 和 Reynolds【16】形式化的。Courtois) Tj
T*
(等人【25】提出了读者 - 写者问题。操作系统教科书更详细地描述了经典的同步问题，例如哲学家进餐问题、打瞌睡的理发师问题和吸烟者问题【102，106，113】。Butenhof) Tj
T*
(的书【15】对 Posix 线程接口有全面的描述。Birrell【7】的论文对线程编程以及线程编程中容易遇到的问题做了很好的介绍。Reinders 的书【90】描述了 C/C++) Tj
T*
(库，简化了线程化程序的设计和实现。有一些课本讲述了多核系统上并行编程的基础知识【47，71】。Pugh 描述了 Java) Tj
T*
(线程通过内存进行交互的方式的缺陷，并提出了替代的内存模型【88】。Gustafson 提出了替代强扩展的弱扩展加速模型【43】。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(家庭作业) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(家庭作业) Tj
T*
() Tj
T*
() Tj
T*
(练习题 12.16) Tj
T*
() Tj
T*
() Tj
T*
(编写 hello.c（图 12-13）的一个版本，它创建和回收 n 个可结合的对等线程，其中 n 是一个命令行参数。) Tj
T*
() Tj
T*
(练习题 12.17) Tj
T*
() Tj
T*
() Tj
T*
(A. 图 12-46 中的程序有一个 bug。要求线程睡眠一秒钟，然后输出一个字符串。然而，当在我们的系统上运行它时，却没有任何输出。为什么？) Tj
T*
ET
endstream
endobj
643 0 obj
<< /Length 1707 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(    /* WARNING: This code is buggy! */) Tj
T*
(    #include "csapp.h") Tj
T*
(    void *thread\(void *vargp\);) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        pthread_t tid;) Tj
T*
() Tj
T*
(        Pthread_create\(&tid, NULL, thread, NULL\);) Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(    /* Thread routine */) Tj
T*
(    void *thread\(void *vargp\)) Tj
T*
(    {) Tj
T*
(        Sleep\(1\);) Tj
T*
(        printf\("Hello, world!\\n"\);) Tj
T*
(        return NULL;) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-46 练习题 12.17 的有 bug 的程序) Tj
T*
() Tj
T*
(B. 你可以通过用两个不同的 Pthreads 函数调用中的一个替代第 10 行中的 exit 函数来改正这个错误。选哪一个呢？) Tj
T*
() Tj
T*
(练习题 12.18) Tj
T*
() Tj
T*
() Tj
T*
(用图 12-21 中的进度图，将下面的轨迹线分类为安全或者不安全的。) Tj
T*
() Tj
T*
(A. $$H2,L2,U2,H1,L1,S2,U1,S1,T1,T2$$) Tj
T*
() Tj
T*
(B. $$H2,H1,L1,U1,S1,L2,T1,U2,S2,T2$$) Tj
T*
() Tj
T*
(C. $$H1,L1,H2,L2,U2,S2,U1,S1,T1,T2$$) Tj
T*
() Tj
T*
(练习题 12.19) Tj
T*
() Tj
T*
() Tj
T*
(图 12-26 中第一类读者—写者问题的解答给予读者的是有些弱的优先级，因为读者在离开它的临界区时，可能会重启一个正在等待的写者，而不是一个正在等待的读者。推导出一个解答，它给予读) Tj
T*
(者更强的优先级，当写者离开它的临界区的时候，如果有读者正在等待的话，就总是重启一个正在等待的读者。) Tj
T*
() Tj
T*
(练习题 12.20) Tj
T*
() Tj
T*
() Tj
T*
(考虑读者—写者问题的一个更简单的变种，即最多只有 N) Tj
T*
ET
endstream
endobj
644 0 obj
<< /Length 2224 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(个读者。推导出一个解答，给予读者和写者同等的优先级，即等待中的读者和写者被赋予对资源访问的同等的机会。提示：你可以用一个计数信号量和一个互斥锁来解决这个问题。) Tj
T*
() Tj
T*
(练习题 12.21) Tj
T*
() Tj
T*
() Tj
T*
(推导出第二类读者—写者问题的一个解答，在此写者的优先级高于读者。) Tj
T*
() Tj
T*
(练习题 12.22) Tj
T*
() Tj
T*
() Tj
T*
(检查一下你对 select 函数的理解，请修改图 12-6 中的服务器，使得它在主服务器的每次迭代中最多只回送一个文本行。) Tj
T*
() Tj
T*
(练习题 12.23) Tj
T*
() Tj
T*
() Tj
T*
(图 12-8 中的事件驱动并发 echo) Tj
T*
(服务器是有缺陷的，因为一个恶意的客户端能够通过发送部分的文本行，使服务器拒绝为其他客户端服务。编写一个改进的服务器版本，使之能够非阻塞地处理这些部分文本行。) Tj
T*
() Tj
T*
(练习题 12.24) Tj
T*
() Tj
T*
() Tj
T*
(RIO I/O 包中的函数（10.5 节）都是线程安全的。它们也都是可重入函数吗？) Tj
T*
() Tj
T*
(练习题 12.25) Tj
T*
() Tj
T*
() Tj
T*
(在图 12-28 中的预线程化的并发 echo 服务器中，每个线程都调用 echo\\cnt 函数（图 12-29）。echo\\cnt) Tj
T*
(是线程安全的吗？它是可重入的吗？为什么是或为什么不是呢？) Tj
T*
() Tj
T*
(练习题 12.26) Tj
T*
() Tj
T*
() Tj
T*
(用加锁—复制技术来实现 gethostbyname 的一个线程安全而又不可重入的版本，称为 gethost-byname\\_ts。一个正确的解答是使用由互斥锁保护的 hostent) Tj
T*
(结构的深层副本。) Tj
T*
() Tj
T*
(练习题 12.27) Tj
T*
() Tj
T*
() Tj
T*
(一些网络编程的教科书建议用以下的方法来读和写套接字：和客户端交互之前，在同一个打开的已连接套接字描述符上，打开两个标准 I/O 流，一个用来读，一个用来写：) Tj
T*
() Tj
T*
(    FILE *fpin, *fpout;) Tj
T*
(    fpin  = fdopen\(sockfd, "r"\);) Tj
T*
(    fpout = fdopen\(sockfd, "w"\);) Tj
T*
() Tj
T*
(当服务器完成和客户端的交互之后，像下面这样关闭两个流：) Tj
T*
() Tj
T*
ET
endstream
endobj
645 0 obj
<< /Length 2003 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    fclose\(fpin\);) Tj
T*
(    fclose\(fpout\);) Tj
T*
() Tj
T*
(然而，如果你试图在基于线程的并发服务器上尝试这种方式，将制造一个致命的竞争条件。请解释。) Tj
T*
() Tj
T*
(练习题 12.28) Tj
T*
() Tj
T*
() Tj
T*
(在图 12-45 中，将两个 V 操作的顺序交换，对程序死锁是否有影响？通过画出四种可能情况的进度图来证明你的答案：) Tj
T*
() Tj
T*
(| 情况1 |  | 情况2 |  | 情况3 |  | 情况4 |  |) Tj
T*
(| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |) Tj
T*
(| 线程 1 | 线程 2 | 线程 1 | 线程 2 | 线程 1 | 线程 2 | 线程 1 | 线程 2 |) Tj
T*
(| P\\\(s\\\) | P\\\(s\\\) | P\\\(s\\\) | P\\\(s\\\) | P\\\(s\\\) | P\\\(s\\\) | P\\\(s\\\) | P\\\(s\\\) |) Tj
T*
(| P\\\(t\\\) | P\\\(t\\\) | P\\\(t\\\) | P\\\(t\\\) | P\\\(t\\\) | P\\\(t\\\) | P\\\(t\\\) | P\\\(t\\\) |) Tj
T*
(| V\\\(s\\\) | V\\\(s\\\) | V\\\(s\\\) | V\\\(t\\\) | V\\\(t\\\) | V\\\(s\\\) | V\\\(t\\\) | V\\\(t\\\) |) Tj
T*
(| V\\\(t\\\) | V\\\(t\\\) | V\\\(t\\\) | V\\\(s\\\) | V\\\(s\\\) | V\\\(t\\\) | V\\\(s\\\) | V\\\(s\\\) |) Tj
T*
() Tj
T*
(练习题 12.29) Tj
T*
() Tj
T*
() Tj
T*
(下面的程序会死锁吗？为什么会或者为什么不会？) Tj
T*
() Tj
T*
(    初始时： a = 1, b = 1, c = 1) Tj
T*
() Tj
T*
(    线程 1    |    线程 2) Tj
T*
(    ---------|----------) Tj
T*
(    P\(a\);    |    P\(c\);) Tj
T*
(    P\(b\);    |    P\(b\);) Tj
T*
(    V\(b\);    |    V\(b\);) Tj
T*
(    P\(c\);    |    V\(c\);) Tj
T*
(    V\(c\);    |) Tj
T*
(    V\(a\);    |) Tj
T*
() Tj
T*
(练习题 12.30) Tj
T*
() Tj
T*
() Tj
T*
(考虑下面这个会死锁的程序。) Tj
T*
() Tj
T*
(    初始时： a = 1, b = 1, c = 1) Tj
T*
() Tj
T*
(    线程 1   |   线程 2   |  线程 3) Tj
T*
(    --------|-----------|--------) Tj
T*
(    P\(a\);   |   P\(c\);   |   P\(c\);) Tj
T*
(    P\(b\);   |   P\(b\);   |   V\(c\);) Tj
T*
(    V\(b\);   |   V\(b\);   |   P\(b\);) Tj
T*
ET
endstream
endobj
646 0 obj
<< /Length 2007 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    P\(c\);   |   V\(c\);   |   P\(a\);) Tj
T*
(    V\(c\);   |   P\(a\);   |   V\(a\);) Tj
T*
(    V\(a\);   |   V\(a\);   |   V\(b\);) Tj
T*
() Tj
T*
(A. 列出每个线程同时占用的一对互斥锁。) Tj
T*
() Tj
T*
(B. 如果$$a \\lt b \\lt c$$，那么哪个线程违背了互斥锁加锁顺序规则？) Tj
T*
() Tj
T*
(C. 对于这些线程，指出一个新的保证不会发生死锁的加锁顺序。) Tj
T*
() Tj
T*
(练习题 12.31) Tj
T*
() Tj
T*
() Tj
T*
(实现标准 I/O 函数 fgets 的一个版本，叫做 tfgets，假如它在 5 秒之内没有从标准输入上接收到一个输入行，那么就超时，并返回一个 NULL) Tj
T*
(指针。你的函数应该实现在一个叫做 tfgets-proc.c 的包中，使用进程、信号和非本地跳转。它不应该使用 Linux 的 alarm 函数。使用图 12-47) Tj
T*
(中的驱动程序测试你的结果。) Tj
T*
() Tj
T*
(    #include "csapp.h") Tj
T*
() Tj
T*
(    char *tfgets\(char *s, int size, FILE *stream\);) Tj
T*
() Tj
T*
(    int main\(\)) Tj
T*
(    {) Tj
T*
(        char buf[MAXLINE];) Tj
T*
() Tj
T*
(        if \(tfgets\(buf, MAXLINE, stdin\) == NULL\)) Tj
T*
(            printf\("BOOM!\\n"\);) Tj
T*
(        else) Tj
T*
(            printf\("%s", buf\);) Tj
T*
() Tj
T*
(        exit\(0\);) Tj
T*
(    }) Tj
T*
() Tj
T*
(> 图 12-47 家庭作业题 12.31 ~ 12.33 的驱动程序) Tj
T*
() Tj
T*
(练习题 12.32) Tj
T*
() Tj
T*
() Tj
T*
(使用 select 函数来实现练习题 12.31 中 tfgets 函数的一个版本。你的函数应该在一个叫做 tfgets-select.c 的包中实现。用练习题 12.31) Tj
T*
(中的驱动程序测试你的结果。你可以假定标准输入被赋值为描述符 0。) Tj
T*
() Tj
T*
(练习题 12.33) Tj
T*
() Tj
T*
() Tj
T*
(实现练习题 12.31 中 tfgets 函数的一个线程化的版本。你的函数应该在一个叫做 tfgets-thread.c 的包中实现。用练习题 12.31) Tj
T*
(中的驱动程序测试你的结果。) Tj
T*
ET
endstream
endobj
647 0 obj
<< /Length 2755 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(练习题 12.34) Tj
T*
() Tj
T*
() Tj
T*
(编写一个$$N \\times M$$矩阵乘法核心函数的并行线程化版本。比较它的性能与顺序的版本的性能。) Tj
T*
() Tj
T*
(练习题 12.35) Tj
T*
() Tj
T*
() Tj
T*
(实现一个基于进程的 TINY Web 服务器的并发版本。你的解答应该为每一个新的连接请求创建一个新的子进程。使用一个实际的 Web 浏览器来测试你的解答。) Tj
T*
() Tj
T*
(练习题 12.36) Tj
T*
() Tj
T*
() Tj
T*
(实现一个基于 I/O 多路复用的 TINY Web 服务器的并发版本。使用一个实际的 Web 浏览器来测试你的解答。) Tj
T*
() Tj
T*
(练习题 12.37) Tj
T*
() Tj
T*
() Tj
T*
(实现一个基于线程的 TINY Web 服务器的并发版本。你的解答应该为每一个新的连接请求创建一个新的线程。使用一个实际的 Web 浏览器来测试你的解答。) Tj
T*
() Tj
T*
(练习题 12.38) Tj
T*
() Tj
T*
() Tj
T*
(实现一个 TINY Web) Tj
T*
(服务器的并发预线程化的版本。你的解答应该根据当前的负载，动态地增加或减少线程的数目。一个策略是当缓冲区变满时，将线程数量翻倍，而当缓冲区变为空时，将线程数目减半。使用一个实际的) Tj
T*
(Web 浏览器来测试你的解答。) Tj
T*
() Tj
T*
(练习题 12.39) Tj
T*
() Tj
T*
() Tj
T*
(Web 代理是一个在 Web 服务器和浏览器之间扮演中间角色的程序。浏览器不是直接连接服务器以获取网页，而是与代理连接，代理再将请求转发给服务器。当服务器响应代理时，代理将响应发送) Tj
T*
(给浏览器。为了这个试验，请你编写一个简单的可以过滤和记录请求的 Web 代理：) Tj
T*
() Tj
T*
(A. 试验的第一部分中，你要建立以接收请求的代理，分析 HTTP，转发请求给服务器，并且返回结果给浏览器。你的代理将所有请求的 URL) Tj
T*
(记录在磁盘上一个日志文件中，同时它还要阻塞所有对包含在磁盘上一个过滤文件中的 URL 的请求。) Tj
T*
() Tj
T*
(B. 试验的第二部分中，你要升级代理，它通过派生一个独立的线程来处理每一个请求，使得代理能够一次处理多个打开的连接。当你的代理在等待远程服务器响应一个请求使它能服务于一个浏览器时，) Tj
T*
(它应该可以处理来自另一个浏览器未完成的请求。) Tj
T*
() Tj
T*
(使用一个实际的 Web 浏览器来检验你的解答。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(附录 A：错误处理) Tj
T*
(================================================================================) Tj
T*
ET
endstream
endobj
648 0 obj
<< /Length 2407 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(附录 A：错误处理) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(参考文献) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(参考文献) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(实验总览) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(实验总览) Tj
T*
() Tj
T*
() Tj
T*
(参考资料) Tj
T*
() Tj
T*
() Tj
T*
(* 实验材料) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/labs.html \(http://csapp.cs.cmu.edu/3e/labs.html\)) Tj
T*
(  * https://github.com/Hansimov/csapp/tree/master/\\labs) Tj
T*
(  \(https://github.com/Hansimov/csapp/tree/master/labs\)) Tj
T*
(* 书中所有示例代码) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/code.html \(http://csapp.cs.cmu.edu/3e/code.html\)) Tj
T*
(  * https://github.com/Hansimov/csapp/tree/master/\\codes/code) Tj
T*
(  \(https://github.com/Hansimov/csapp/tree/master/codes/code\)) Tj
T*
(* 【读厚 CSAPP】实验概览 \\| 小土刀 2.0) Tj
T*
(  * https://wdxtub.com/csapp/thick-csapp-lab-0/2016/04/16/) Tj
T*
(  \(https://wdxtub.com/csapp/thick-csapp-lab-0/2016/04/16/\)) Tj
T*
() Tj
T*
(实验综述) Tj
T*
() Tj
T*
() Tj
T*
(所有 CS:APP 的实验都有如下共性：) Tj
T*
() Tj
T*
(* 经历了 CMU 课堂的考验。作者在 10 年时间里，在 150 ~ 250) Tj
T*
(名学生的课堂中开发和完善了这些实验。这门课得到了学生们的高度评价，他们通常认为这些实验是他们喜欢这门课的原因。) Tj
T*
(* 自动测试和评估驱动程序。学生用 C 语言写解答，然后将其链接到 C 驱动程序中。驱动程序运行其解答，检查其正确性，并对解答进行定量评估。学生通过这些反馈逐步完善他们的解答。) Tj
T*
(* 解答。为每位讲师提供了每个实验的完整解答。) Tj
T*
(* 自动评分器。每个实验（Proxy Lab 除外）都有一个 Perl 自动评分器，为每个学生提交的文件运行驱动程序，并且打印一份 ASCII 成绩单。) Tj
T*
(* 完整的实验报告。每个实验都有一份完整的报告（用 Latex 编写），其中包含环境（context）、分步说明和对评分标准的解释。) Tj
T*
ET
endstream
endobj
649 0 obj
<< /Length 1221 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(实验链接) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(常见问题) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(常见问题) Tj
T*
() Tj
T*
() Tj
T*
(gcc not found) Tj
T*
() Tj
T*
() Tj
T*
(原因：机器没有安装 gcc。) Tj
T*
() Tj
T*
(方法：运行下列命令：) Tj
T*
() Tj
T*
(运行：) Tj
T*
() Tj
T*
(    sudo apt-get install build-essential) Tj
T*
() Tj
T*
(参考链接：) Tj
T*
() Tj
T*
(* C compiler not found, Ubuntu - Stack Overflow) Tj
T*
(  * https://stackoverflow.com/questions/22557029/c-compiler-not-found-ubuntu) Tj
T*
(  \(https://stackoverflow.com/questions/22557029/c-compiler-not-found-ubuntu\)) Tj
T*
() Tj
T*
(fatal error: bits/libc-header-start.h: No such file or directory) Tj
T*
() Tj
T*
() Tj
T*
(原因：64 位机器的 gcc 只有 64 位的库，用 -m32 参数便会出错。) Tj
T*
() Tj
T*
(方法 1：删除 -m32 参数。但是这会导致许多依赖 32 位特性的代码错误。) Tj
T*
ET
endstream
endobj
650 0 obj
<< /Length 1908 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(方法 2（推荐）：安装 32 位的库：) Tj
T*
() Tj
T*
(    sudo apt-get install gcc-multilib) Tj
T*
() Tj
T*
(参考链接：) Tj
T*
() Tj
T*
(* c - "fatal error: bits/libc-header-start.h: No such file or directory" while compiling) Tj
T*
(HTK - Stack Overflow) Tj
T*
(  * https://stackoverflow.com/questions/54082459/fatal-error-bits-libc-header-start-h-no-) Tj
T*
(  such-file-or-directory-while-compili) Tj
T*
(  \(https://stackoverflow.com/questions/54082459/fatal-error-bits-libc-header-start-h-no-) Tj
T*
(  such-file-or-directory-while-compili\)) Tj
T*
(* 32 bit - Trouble compiling a 32 bit binary on a 64 bit machine - Ask Ubuntu) Tj
T*
(  * https://askubuntu.com/questions/91909/trouble-compiling-a-32-bit-binary-on-a-64-bit-) Tj
T*
(  machine \(https://askubuntu.com/questions/91909/trouble-compiling-a-32-bit-binary-) Tj
T*
(  on-a-64-bit-machine\)) Tj
T*
() Tj
T*
(每次修改完代码，在 btest 前一定要重新 make) Tj
T*
() Tj
T*
() Tj
T*
(建议写成：) Tj
T*
() Tj
T*
(    make && ./btest) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(实验 1：Data Lab) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(实验 1：Data Lab) Tj
T*
() Tj
T*
() Tj
T*
(实验附件) Tj
T*
() Tj
T*
() Tj
T*
(* README) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/README-datalab \(http://csapp.cs.cmu.edu/3e/README-datalab\)) Tj
T*
(* Writeup) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/datalab.pdf \(http://csapp.cs.cmu.edu/3e/datalab.pdf\)) Tj
T*
(* 版本历史) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/datalab-release.html \(http://csapp.cs.cmu.edu/3e/datalab-) Tj
T*
(  release.html\)) Tj
T*
(* 自学材料) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/datalab-handout.tar \(http://csapp.cs.cmu.edu/3e/datalab-) Tj
T*
(  handout.tar\)) Tj
T*
ET
endstream
endobj
651 0 obj
<< /Length 2252 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(实验简介) Tj
T*
() Tj
T*
() Tj
T*
(学生可以实现简单的逻辑函数、二进制补码和浮点函数，但必须使用 C 语言的一个高度受限的子集。例如，可能会要求仅用位级运算和直线代码（straightline) Tj
T*
(code）来计算一个数的绝对值。该实验帮助学生理解 C 语言数据类型的位级表示和数据操作的位级行为。) Tj
T*
() Tj
T*
(参考链接) Tj
T*
() Tj
T*
() Tj
T*
(* CSAPP 之 DataLab详解，没有比这更详细的了 - 知乎) Tj
T*
(  * https://zhuanlan.zhihu.com/p/59534845 \(https://zhuanlan.zhihu.com/p/59534845\)) Tj
T*
(* CSAPP DataLab 题解 \\| Claude's Blog) Tj
T*
(  * http://claude-ray.com/2019/10/02/csapp-datalab/ \(http://claude-) Tj
T*
(  ray.com/2019/10/02/csapp-datalab/\)) Tj
T*
(* CSAPP - datalab · Mcginn's Blog) Tj
T*
(  * https://mcginn7.github.io/2020/02/14/CSAPP-datalab/) Tj
T*
(  \(https://mcginn7.github.io/2020/02/14/CSAPP-datalab/\)) Tj
T*
(* 【读厚 CSAPP】I Data Lab \\| 小土刀 2.0) Tj
T*
(  * https://wdxtub.com/csapp/thick-csapp-lab-1/2016/04/16/) Tj
T*
(  \(https://wdxtub.com/csapp/thick-csapp-lab-1/2016/04/16/\)) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(README（讲师版）) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(README（讲师版）) Tj
T*
() Tj
T*
() Tj
T*
(> CS:APP Data Lab) Tj
T*
(>) Tj
T*
(> 给讲师的指导) Tj
T*
(>) Tj
T*
(> May 31, 2011：现在包含了“击败教授”比赛) Tj
T*
(>) Tj
T*
(> Copyright \\\(c\\\) 2002-2018, R. Bryant and D. O'Hallaron) Tj
T*
(>) Tj
T*
(> 汉化：Hansimov) Tj
T*
() Tj
T*
(此目录包含运行 CS:APP Data Lab 所需的文件，它有助于培养学生对位表示、补码运算和 IEEE 浮点的理解。) Tj
T*
() Tj
T*
(为了好玩，我们还提供了一个新的基于 HTTP 的用户级“击败教授”竞赛，取代了旧的基于电子邮件的版本。新的比赛是完全独立的，不需要 root 密码。唯一的要求是在 Linux) Tj
T*
(机器上有一个具有 IP 地址的用户帐户。) Tj
T*
() Tj
T*
(系统需求：使用 bison 和 flex 构建 dlc。) Tj
T*
ET
endstream
endobj
652 0 obj
<< /Length 3400 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(1. 概述) Tj
T*
() Tj
T*
() Tj
T*
(在该实验中，学生处理一个名为 bits.c 的 C 文件，它由一系列编程“谜题”) Tj
T*
(组成。每个谜题都是一个需要完善的函数体，从而实现一个特定的数学函数，比如“绝对值”。在解决非浮点谜题时，学生仅能使用直线 C 代码和一组受限的 C) Tj
T*
(语言算术和逻辑运算符。对于浮点谜题，他们可以使用条件句和任意运算符。) Tj
T*
() Tj
T*
(学生使用以下三种工具检查作业。讲师使用相同的工具来评分。) Tj
T*
() Tj
T*
(1. dlc：一个“数据实验编译器”，用 bits.c 检查每个函数是否符合编码准则，检查学生是否使用少于最大数量的运算符，是否只使用直线代码，是否只使用合法运算符。其源代码和一个) Tj
T*
(Linux 二进制文件都包含在实验中。) Tj
T*
(2. btest：一个测试工具，用于检查 bits.c 中函数的正确性。这个工具已经得到了显著的改进，现在可以检查整数和浮点表示的大范围（wide swaths）边缘用例（edge) Tj
T*
(cases），比如 0、最小有符号数（Tmin）、非规格化的数和规格化的数的边界（denorm-norm boundary） 和无限大（inf）。) Tj
T*
(3. driver.pl：一个自动评分驱动程序，它使用 dlc 和 btest 来检查 bits.c 中每个测试函数的正确性，以及是否符合编码准则。) Tj
T*
() Tj
T*
(实验的默认版本包括 15 个谜题，位于 ./src/selections.c 中，从目录 ./src/puzzles/ 中定义的 73) Tj
T*
(个标准谜题中选择。你可以从标准的谜题中选择一组不同的拼图来定制每个学期的实验。) Tj
T*
() Tj
T*
(你也可以自己定义新的谜题，并将它们添加到标准集合中。请参阅 ./src/README 以获取如何向标准集合添加新谜题的说明。) Tj
T*
() Tj
T*
(注：如果你定义了新的谜题，请发送给我（Dave O'Hallaron， droh@cs.cmu.edu）这样我就可以将它们添加到 data lab 发行版的标准谜题集中。) Tj
T*
() Tj
T*
(2. 文件) Tj
T*
() Tj
T*
() Tj
T*
(所有的 CS:APP 实验都有着相同的简单的顶层目录结构：) Tj
T*
() Tj
T*
(| 文件名 | 说明 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| Makefile | 构建整个实验。 |) Tj
T*
(| README | 本文件。 |) Tj
T*
(| src/ | 包含实验的所有源代码。 |) Tj
T*
(| datalab-handout/ | 发给学生的材料目录。由 Makefile 从 ./src 中的文件生成。不要修改此目录中的任何内容。 |) Tj
T*
(| grade/ | 自动评分脚本，讲师可以用它来给学生提交的文件打分。 |) Tj
T*
(| writeup/ | LaTeX 实验报告样例。 |) Tj
T*
(| contest/ | 可选的“击败教授”比赛所需的所有文件。 |) Tj
T*
() Tj
T*
(3. 构建实验) Tj
T*
() Tj
T*
() Tj
T*
(第 0 步。如果你打算开启“击败教授”比赛（第 5 节），那么编辑 ./contest/Contest.pm 文件，以便驱动程序知道将结果发送到何处。参考) Tj
T*
(./contest/README 获取简单的说明。如果您决定不提供比赛，那么在这一步中什么都不做。) Tj
T*
() Tj
T*
(第 1 步。编辑文件 ./src/selections.c 选择要包含的谜题。默认的 ./src/selections.c 来自 CMU 的 Data Lab 此前的一个实例。文件) Tj
T*
(./src/selections-all.c 包含可供选择的谜题的完整列表。) Tj
T*
ET
endstream
endobj
653 0 obj
<< /Length 2472 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(第 2 步。修改 ./writeup 中 的 LaTeX 实验报告，定制成你的课程所需。) Tj
T*
() Tj
T*
(第 3 步。在当前目录中键入以下内容：) Tj
T*
() Tj
T*
(    unix> make clean) Tj
T*
(    unix> make) Tj
T*
() Tj
T*
(Makefile 生成 btest 源文件，构建 dlc 二进制文件（如果需要），格式化实验报告，然后将 btest、dlc) Tj
T*
(二进制文件和驱动程序复制到讲义目录。之后，它将构建讲义目录的 tar 文件（位于 ./datalab-handout.tar），然后你可以将其发给学生。) Tj
T*
() Tj
T*
(关于二进制可移植性的注意事项：dlc 作为二进制文件放在 datalab-handout 目录中。由于动态库的不同版本，Linux) Tj
T*
(二进制文件并非总能跨发行版移植。需要注意的是，应在与学生所用机器兼容的一台机器上编译 dlc。) Tj
T*
() Tj
T*
(注意：运行 “make” 也会自动生成谜题的解答，可以在 ./src/bits.c 和 ./src/bits.c-solution 中找到。) Tj
T*
() Tj
T*
(4. 给实验评分) Tj
T*
() Tj
T*
() Tj
T*
(有个方便的自动评分脚本可以自动为学生提交的作业评分。说明可参见 ./grade/README。) Tj
T*
() Tj
T*
(5. “击败教授”比赛) Tj
T*
() Tj
T*
() Tj
T*
(为了好玩，我们还提供了一个可选的“打败教授”比赛，学生和讲师竞争。目标是用最少的运算符来解决每个数据实验室难题。在每一个谜题中，能匹配或击败讲师的操作符数目的学生是赢家。有关如何设) Tj
T*
(置竞赛的简单说明，参见 ./contest/README 。) Tj
T*
() Tj
T*
(注：比赛是完全可选的。你提供与否对你如何建立和分发该实验没有影响。) Tj
T*
() Tj
T*
(注：如果你决定提供比赛，那么你应该在构建实验之前配置比赛，以便驱动程序知道发送每个学生比赛结果的服务器和端口（使用 ./src/Driverhdrs.pm 文件中定义的常量，它们从) Tj
T*
(./contest/Contest.pm 配置文件自动生成）。) Tj
T*
() Tj
T*
(如果你已经构建完实验并将其分发给学生了，你还是可以提供比赛：) Tj
T*
() Tj
T*
(1）参照 contest/Makefile 中所述配置比赛。) Tj
T*
() Tj
T*
(2）照常重新构建实验：) Tj
T*
() Tj
T*
(    linux> cd datalab) Tj
T*
(    linux> make) Tj
T*
() Tj
T*
(3）将新的 ./src/Driverhdrs.pm 文件分发给学生。) Tj
T*
() Tj
T*
(6. 实验性的 BDD 检查器) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
654 0 obj
<< /Length 2348 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(为了好玩，我们包含了一个基于二进制决策图（binary decision diagram，BDD）的实验性的正确性检查器（R. E. Bryant，IEEE) Tj
T*
(Transactions on Computers，August, 1986），它使用了科罗拉多大学的 CUDD BDD 包。BDD 检查器对 bits.c) Tj
T*
(中的测试函数进行穷举测试，对照参考解答，形式化验证每个测试函数对于所有可能的输入值的正确性。对于和参考解答不同的函数，BDD) Tj
T*
(检查器生成一个反例，该反例以一组函数参数的形式出现，这些参数会让测试解答与参考解答不同。) Tj
T*
() Tj
T*
(源代码包含在 ./src/bddcheck 中。编译方法：) Tj
T*
() Tj
T*
(    unix> cd src/bddcheck) Tj
T*
(    unix> make clean) Tj
T*
(    unix> make) Tj
T*
() Tj
T*
(使用 BDD 检查 ./src/bits.c 的正确性：) Tj
T*
() Tj
T*
(    unix> cd src) Tj
T*
(    unix> ./bddcheck/check.pl    # 包含错误信息和反例) Tj
T*
(    unix> ./bddcheck/check.pl -g # 紧凑的表格输出，不含错误消息) Tj
T*
() Tj
T*
(注意，check.pl 必须在 ./bddcheck 的父目录运行。) Tj
T*
() Tj
T*
(我们在 CMU 使用这个 BDD 检查器而非 btest 已经有好几年了，代码看起来是稳定的。主要缺点在于从 bits.c 中提取函数的 Perl) Tj
T*
(代码，它通常能工作，但是有些事情——比如对其他函数的调用，或者不以一个大括号结尾的函数——会使它混乱。所以我们不愿意让它成为分发的 CS:APP) Tj
T*
(实验的默认检查器。但是，如果您对某个特定解答的正确性有任何疑问，那么这是一个权威的决定方法。) Tj
T*
() Tj
T*
(任何有关 BDD 检查器的意见，请发送给 randy.bryant@cs.cmu.edu。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(README（学生版）) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(README（学生版）) Tj
T*
() Tj
T*
() Tj
T*
(> CS:APP Data Lab) Tj
T*
(>) Tj
T*
(> 给学生的指导) Tj
T*
() Tj
T*
(你的目标是修改你的 bits.c 副本，以便它通过 btest 中的所有测试，并且不违反任何代码准则。) Tj
T*
() Tj
T*
(0. 文件) Tj
T*
ET
endstream
endobj
655 0 obj
<< /Length 2157 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
() Tj
T*
(| 文件名 | 说明 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| Makefile | 构建 btest、fshow 和 ishow |) Tj
T*
(| README | 本文件 |) Tj
T*
(| bits.c | 你将要修改和提交的文件 |) Tj
T*
(| bits.h | 头文件 |) Tj
T*
(| btest.c | btest 主程序 |) Tj
T*
(| btest.h | 用于构建 btest |) Tj
T*
(| decl.c | 用于构建 btest |) Tj
T*
(| tests.c | 用于构建 btest |) Tj
T*
(| tests-header.c | 用于构建 btest |) Tj
T*
(| dlc\\* | 规则检查编译器的二进制文件（data lab 编译器） |) Tj
T*
(| driver.pl\\* | 使用 btest 和 dlc 来为 bits.c 自动评分的驱动程序 |) Tj
T*
(| Driverhdrs.pm | 头文件，用于可选的“击败教授”比赛 |) Tj
T*
(| fshow.c | 实用代码，用于检查浮点表示 |) Tj
T*
(| ishow.c | 实用代码，用于检查整数表示 |) Tj
T*
() Tj
T*
(1. 修改 bits.c 并检查它是否符合 dlc 的要求) Tj
T*
() Tj
T*
() Tj
T*
(重要：在你开始之前，请仔细阅读 bits.c 文件中的说明。说明中给出了代码规则，如果你想获得全部分数，你需要遵守它们。) Tj
T*
() Tj
T*
(使用 dlc 编译器（./dlc）自动检查 bits.c 版本是否符合编码准则：) Tj
T*
() Tj
T*
(如果代码没有问题，dlc 将以静默方式返回。否则，它会打印消息，标记出问题。使用 -e 参数运行 dlc：) Tj
T*
() Tj
T*
(    unix> ./dlc -e bits.c) Tj
T*
() Tj
T*
(可让 dlc 打印每个函数使用的运算符数目。) Tj
T*
() Tj
T*
(一旦有了合法解答，你就可以使用 ./btest 程序测试它的正确性。) Tj
T*
() Tj
T*
(2. 使用 btest 测试) Tj
T*
() Tj
T*
() Tj
T*
(此目录中的 Makefile 使用附加代码编译 bits.c 版本，以创建名为 btest 的程序（或测试工具）。) Tj
T*
() Tj
T*
(要编译并运行 btest 程序，请键入：) Tj
T*
() Tj
T*
(    unix> make btest) Tj
T*
(    unix> ./btest [optional cmd line args]) Tj
T*
() Tj
T*
(每次更改 bits.c 程序时，都需要重新编译 btest。当从一个平台迁移到另一个平台时，你会想删除旧版本 btest 并生成一个新版本。使用以下命令：) Tj
T*
() Tj
T*
ET
endstream
endobj
656 0 obj
<< /Length 2031 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    unix> make clean) Tj
T*
(    unix> make btest) Tj
T*
() Tj
T*
(Btest 通过在每个函数上运行数百万个测试用例来测试代码的正确性。它测试了大范围的边缘用例，比如整数谜题的 Tmin（最小有符号数） 和 0，浮点谜题的) Tj
T*
(0，无限大（inf），以及非规范化和规范化数字之间的边界。当 btest 检测到某个函数中的错误时，它会打印出失败的测试、不正确的结果和预期的结果，然后终止对该函数的测试。) Tj
T*
() Tj
T*
(以下是 btest 的命令行选项：) Tj
T*
() Tj
T*
(      unix> ./btest -h) Tj
T*
(      用法: ./btest [-hg] [-r <n>] [-f <name> [-1|-2|-3 <val>]*] [-T <time limit>]) Tj
T*
(        -1 <val>   指定第一个函数参数) Tj
T*
(        -2 <val>   指定第二个函数参数) Tj
T*
(        -3 <val>   指定第三个函数参数) Tj
T*
(        -f <name>  只测试指定名称的函数) Tj
T*
(        -g         格式化输出评分，不包含错误信息) Tj
T*
(        -h         打印该信息) Tj
T*
(        -r <n>     给所有问题统一的权重 n) Tj
T*
(        -T <lim>   设置超时限制为 lim) Tj
T*
() Tj
T*
(样例：) Tj
T*
() Tj
T*
(测试所有功能的正确性并打印出错误消息：) Tj
T*
() Tj
T*
(    unix> ./btest) Tj
T*
() Tj
T*
(以紧凑的形式测试所有函数，不含错误消息：) Tj
T*
() Tj
T*
(    unix> ./btest -g) Tj
T*
() Tj
T*
(测试函数 foo 的正确性：) Tj
T*
() Tj
T*
(    unix> ./btest -f foo) Tj
T*
() Tj
T*
(使用特定参数测试函数 foo 的正确性：) Tj
T*
() Tj
T*
(    unix> ./btest -f foo -1 27 -2 0xf) Tj
T*
() Tj
T*
(btest 不会检查你的代码是否符合代码准则，需使用 dlc。) Tj
T*
() Tj
T*
(3. 帮助程序) Tj
T*
() Tj
T*
() Tj
T*
(我们提供了 ishow 和 fshow 程序，分别帮助你破译整数和浮点表示。每个都以一个十进制或十六进制数作为参数。要构建它们，请键入：) Tj
T*
() Tj
T*
(    unix> make) Tj
T*
() Tj
T*
ET
endstream
endobj
657 0 obj
<< /Length 1690 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(用法样例：) Tj
T*
() Tj
T*
(    unix> ./ishow 0x27) Tj
T*
(    Hex = 0x00000027,   Signed = 39,    Unsigned = 39) Tj
T*
() Tj
T*
(    unix> ./ishow 27) Tj
T*
(    Hex = 0x0000001b,   Signed = 27,    Unsigned = 27) Tj
T*
() Tj
T*
(    unix> ./fshow 0x15213243) Tj
T*
(    Floating point value 3.255334057e-26) Tj
T*
(    Bit Representation 0x15213243, sign = 0, exponent = 0x2a, fraction = 0x213243) Tj
T*
(    Normalized.  +1.2593463659 X 2^\(-85\)) Tj
T*
() Tj
T*
(    linux> ./fshow 15213243) Tj
T*
(    Floating point value 2.131829405e-38) Tj
T*
(    Bit Representation 0x00e822bb, sign = 0, exponent = 0x01, fraction = 0x6822bb) Tj
T*
(    Normalized.  +1.8135598898 X 2^\(-126\)) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(Writeup) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(Writeup) Tj
T*
() Tj
T*
() Tj
T*
(> datalab.pdf) Tj
T*
(>) Tj
T*
(> 15-213, Fall 20xx) Tj
T*
(>) Tj
T*
(> Data Lab: Manipulating Bits) Tj
T*
() Tj
T*
(Harry Bovik \\\(bovik@cs.cmu.edu\\\) 是本作业的负责人。) Tj
T*
() Tj
T*
(1. 介绍) Tj
T*
() Tj
T*
() Tj
T*
(本作业的目的是更加熟悉整数和浮点数的位级表示。你可以通过解决一系列的编程“谜题”来做到这一点。这些谜题很多都是人造的，但你会发现自己在处理这些谜题的过程中，会更多地考虑位。) Tj
T*
() Tj
T*
(2. 支持) Tj
T*
() Tj
T*
() Tj
T*
(这是一个个人项目。所有提交内容都是电子版。说明和更正将公布在课程网页上。) Tj
T*
() Tj
T*
(3. 讲义说明) Tj
T*
() Tj
T*
ET
endstream
endobj
658 0 obj
<< /Length 3588 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(SITE-SPECIFIC：此处插入一段内容，解释讲师如何给学生分发 datalab.handout.tar 文件。) Tj
T*
() Tj
T*
(开始先将 datalab-handout.tar 复制到一台 Linux 机器上（受保护的）目录中，您打算在该目录完成工作。然后输入命令) Tj
T*
() Tj
T*
(    unix> tar xvf datalab-handout.tar) Tj
T*
() Tj
T*
(这会把许多文件解压到目录中。你唯一需要修改和提交的文件是 bits.c。) Tj
T*
() Tj
T*
(bits.c 文件包含了 13 个编程谜题的框架。你的任务是完成每个函数框架，对于整数谜题只能使用直线代码（即，没有循环或条件语句），以及有限数量的 C) Tj
T*
(语言算术和逻辑运算符，具体来说，你只能使用以下 8 个运算符：) Tj
T*
() Tj
T*
(    ! ˜ & ˆ | + << >>) Tj
T*
() Tj
T*
(一些函数进一步限制了这个列表。此外，不允许使用任何长度超过 8 位的常量。有关详细规则和代码样式要求的讨论，请参见 bits.c 中的注释。) Tj
T*
() Tj
T*
(4. 谜题) Tj
T*
() Tj
T*
() Tj
T*
(本节介绍你将在 bits.c 中解决的谜题。) Tj
T*
() Tj
T*
(表 1) Tj
T*
(列出了从最简单到最困难的谜题。“难度级别”字段给出谜题的难度级别（点数），“最大操作符数”字段提供允许用于实现每个功能的最大运算符的数目。有关函数行为要求的更多详细信息，请参见) Tj
T*
(bits.c 中的注释。您也可以参考 tests.c 中的测试函数。这些函数被用作参考函数来表示函数的正确行为，尽管它们不满足函数的代码规则。) Tj
T*
() Tj
T*
(| 函数名 | 描述 | 难度级别 | 最大操作符数目 |) Tj
T*
(| :--- | :--- | :---: | :---: |) Tj
T*
(| bitXor\\\(x,y\\\) | x 异或 y，只用 & 和 ~ | 1 | 14 |) Tj
T*
(| tmin\\\(\\\) | 最小的整数补码 | 1 | 4 |) Tj
T*
(| isTmax\\\(x\\\) | x 为最大的整数补码时为真 | 1 | 10 |) Tj
T*
(| allOddBits\\\(x\\\) | x 的奇数位都为 1 时为真 | 2 | 12 |) Tj
T*
(| negate\\\(x\\\) | 使用 - 操作符返回 -x | 2 | 5 |) Tj
T*
(| isAsciDigit\\\(x\\\) | $$\\small 0x30\\leqslant x \\leqslant 0x39$$ 时为真 | 3 | 15 |) Tj
T*
(| conditional | 等同于 x ? y : z | 3 | 16 |) Tj
T*
(| isLessOrEqual\\\(x, y\\\) | $$\\small x \\leqslant y $$时为真，否则为假 | 3 | 24 |) Tj
T*
(| logicalNeg\\\(x\\\)\\\) | 不用 ! 运算符计算 !x | 4 | 12 |) Tj
T*
(| howManyBits\\\(x\\\) | 用补码表示 x 的最小位数 | 4 | 90 |) Tj
T*
(| floatScale2\\\(uf\\\) | 对于浮点参数 f，返回 2\\*f 的位级等价数 | 4 | 30 |) Tj
T*
(| floatFloat2Int\\\(uf\\\) | 对于浮点参数 f，返回 \\\(int\\\) f 的位级等价数 | 4 | 30 |) Tj
T*
(| floatPower2\\\(x\\\) | 对于整数 x，返回 2.0^x | 4 | 30 |) Tj
T*
() Tj
T*
(> 表 1：data lab 难题。对于浮点谜题，数值 f 是与无符号整数 uf 具有相同位表示的浮点数。) Tj
T*
() Tj
T*
(对于浮点谜题，你将实现一些常见的单精度浮点运算。对于这些谜题，您可以使用标准控制结构（条件语句、循环语句），并且可以同时使用 int 和 unsigned 数据类型，包括任意无符号) Tj
T*
(和整数常量。不能使用任何联合体（union）、结构体（struct）或数组（array）。最重要的是，不能使用任何浮点数据类型、操作或常量。相反，任何浮点操作数都将作为无符号类型传) Tj
T*
(递给函数，而返回的任何浮点值都将是无符号类型。你的代码应该执行位操作，以实现特定的浮点数运算。) Tj
T*
ET
endstream
endobj
659 0 obj
<< /Length 2600 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(提供的 fshow 程序帮助你理解浮点数的结构。要编译 fshow，请切换到讲义目录并键入：) Tj
T*
() Tj
T*
(    unix> make) Tj
T*
() Tj
T*
(你可以使用 fshow 查看任意模式表示的浮点数：) Tj
T*
() Tj
T*
(    unix> ./fshow 2080374784) Tj
T*
(    Floating point value 2.658455992e+36) Tj
T*
(    Bit Representation 0x7c000000, sign = 0, exponent = f8, fraction = 000000) Tj
T*
(    Normalized. 1.0000000000 X 2ˆ\(121\)) Tj
T*
() Tj
T*
(你也可以给 fshow 提供十六进制和浮点值，它将破译它们的位结构。) Tj
T*
() Tj
T*
(5. 评估) Tj
T*
() Tj
T*
() Tj
T*
(你的分数将根据以下分布计算，最高 67 分：) Tj
T*
() Tj
T*
(| 标准 | 分数 |) Tj
T*
(| :---: | :---: |) Tj
T*
(| 正确性 | 36 |) Tj
T*
(| 性能 | 26 |) Tj
T*
(| 风格 | 5 |) Tj
T*
() Tj
T*
(正确性分数。你必须解决的谜题的难度等级在 1 到 4 之间，因此它们的加权和总计为 36。我们将使用 btest 程序评估你的函数，这将在下一节中介绍。如果一个谜题通过了) Tj
T*
(btest 的所有测试，你将获得满分，否则就没分。) Tj
T*
() Tj
T*
(性能分数。我们在这门课上主要关心的是你能得到正确的答案。然而，我们想给你灌输一种让事情尽可能简短和简单的感觉。此外，有些谜题可以用蛮力解决，但我们希望你更聪明。因此，对于每个函数，) Tj
T*
(我们已经为每个函数设置了允许您使用的最大数量的运算符。这个限制是非常慷慨的，它的目的是为了抓住效率极低的解答。每个满足运算符数目限制的正确函数都将得到 2 分。) Tj
T*
() Tj
T*
(风格分数。最后，我们保留了 5 分，用于主观评价你解答的风格和你的注释。你的解决方案应该尽可能简洁明了。你的注释应当提供有用信息，但不能太多。) Tj
T*
() Tj
T*
(给你的工作自动评分) Tj
T*
() Tj
T*
() Tj
T*
(我们在材料目录提供了一些自动评分工具——btest、dlc 和 driver.pl——帮助你检查工作的正确性。) Tj
T*
() Tj
T*
(btest：此程序检查 bits.c 中函数功能的正确性。要构建和使用它，请键入以下两个命令：) Tj
T*
() Tj
T*
(    unix> make) Tj
T*
(    unix> ./btest) Tj
T*
() Tj
T*
(注意，每次修改 bits.c 文件时都必须重新构建 btest。 你会发现，一次一个地完成这些函数，并在执行过程中对每个函数进行测试是很有帮助的。可以使用 -f 标志指示) Tj
T*
(btest 只测试单个函数：) Tj
T*
() Tj
T*
ET
endstream
endobj
660 0 obj
<< /Length 2341 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(    unix> ./btest -f bitXor) Tj
T*
() Tj
T*
(可以使用选项标志 -1、-2 和 -3 向其提供特定的函数参数：) Tj
T*
() Tj
T*
(    unix> ./btest -f bitXor -1 4 -2 5) Tj
T*
() Tj
T*
(dlc：这是一个来自 MIT CILK 小组的 ANSI C 编译器的修改版本，您可以使用它来检查每个谜题是否符合代码规则。典型用法是：) Tj
T*
() Tj
T*
(    unix> ./dlc bits.c) Tj
T*
() Tj
T*
(程序将静默运行，除非检测到问题，例如非法运算符、运算符过多或整数谜题中的非直线代码。使用 -e 参数运行：) Tj
T*
() Tj
T*
(    unix> ./dlc -e bits.c) Tj
T*
() Tj
T*
(会让 dlc 打印每个函数使用的运算符的数目。键入 ./dlc -help 以获取命令行选项的列表。) Tj
T*
() Tj
T*
(driver.pl：这是一个驱动程序，使用 btest 和 dlc 计算你解答的正确性和性能分数。它不需要任何参数：) Tj
T*
() Tj
T*
(    unix> ./driver.pl) Tj
T*
() Tj
T*
(你的讲师会用 driver.pl 来评估你的解答。) Tj
T*
() Tj
T*
(6. 提交说明) Tj
T*
() Tj
T*
() Tj
T*
(SITE-SPECIFIC：在这里插入文本，告诉每个学生如何在你的学校提交他们的 bits.c 解答文件。) Tj
T*
() Tj
T*
(7. 建议) Tj
T*
() Tj
T*
() Tj
T*
(* 不要在 bits.c 文件中包含 &lt;stdio.h&gt; 头文件，因为它会让 dlc 混乱并导致一些非直观的错误消息。你仍然可以在 bits.c文 件中使用) Tj
T*
(printf 进行调试，而不用包含 &lt;stdio.h&gt; 头文件，尽管 gcc 会打印一个警告，你可以忽略它。) Tj
T*
(* dlc 程序强制执行比 C++ 更严格的 C 声明形式，或者由 gcc) Tj
T*
(强制执行。特别是，任何声明都必须出现在块（用大括号括起来的内容）中的任何非声明语句之前。例如，以下代码它会报错：) Tj
T*
() Tj
T*
(      int foo\(int x\)) Tj
T*
(      {) Tj
T*
(          int a = x;) Tj
T*
(          a *= 3;     /* Statement that is not a declaration */) Tj
T*
(          int b = a;  /* ERROR: Declaration not allowed here */) Tj
T*
(      }) Tj
T*
() Tj
T*
(8. “击败教授”比赛) Tj
T*
() Tj
T*
() Tj
T*
(为了好玩，我们提供了一个可选的“击败教授”比赛，让你与其他学生和讲师竞争，开发出最有效的谜题。目标是用最少的运算符来解决 Data Lab) Tj
T*
ET
endstream
endobj
661 0 obj
<< /Length 2385 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(的每个谜题。在每个谜题中，与讲师的操作符数目相匹配或击败的学生就是赢家！) Tj
T*
() Tj
T*
(要提交参赛作品，请键入：) Tj
T*
() Tj
T*
(    unix> ./driver.pl -u "Your Nickname") Tj
T*
() Tj
T*
(昵称限制为 35 个字符，可以包含字母数字、撇号（'）、逗号、句点、破折号、下划线和) Tj
T*
(&。你可以随时提交。你最近提交的内容将显示在实时记分板上，仅由你的昵称标识。您浏览下面网站查看记分板：) Tj
T*
() Tj
T*
(http://$SERVER\\NAME:$REQUESTD\\PORT) Tj
T*
() Tj
T*
(SITE-SPECIFIC：将 $SERVER\\NAME 和 $REQUESTD\\PORT 替换成你在 ./contest/Contest.pm 文件中设置的值。) Tj
T*
() Tj
T*
(\\\\\\\\) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(实验 2：Bomb Lab) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(实验 2：Bomb Lab) Tj
T*
() Tj
T*
() Tj
T*
(实验附件) Tj
T*
() Tj
T*
() Tj
T*
(* README) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/README-bomblab \(http://csapp.cs.cmu.edu/3e/README-bomblab\)) Tj
T*
(* Writeup) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/bomblab.pdf \(http://csapp.cs.cmu.edu/3e/bomblab.pdf\)) Tj
T*
(* 版本历史) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/bomblab-release.html \(http://csapp.cs.cmu.edu/3e/bomblab-) Tj
T*
(  release.html\)) Tj
T*
(* 自学材料) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/bomb.tar \(http://csapp.cs.cmu.edu/3e/bomb.tar\)) Tj
T*
(* 解答（需使用教师账户登录）) Tj
T*
(  * http://csapp.cs.cmu.edu/im/bomb-solution.txt \(http://csapp.cs.cmu.edu/im/bomb-) Tj
T*
(  solution.txt\)) Tj
T*
() Tj
T*
(实验简介) Tj
T*
() Tj
T*
() Tj
T*
(“二进制炸弹”是一个程序，以目标代码文件的形式提供给学生。运行时，它会提示用户键入 6) Tj
T*
(个不同的字符串。如果其中任何一个错误，炸弹就会“爆炸”，打印错误消息并将事件记录在打分服务器上。学生们必须通过反汇编和逆向程序，“拆除”他们自己独特的炸弹，以确定这 6) Tj
T*
(个字符串应该是什么。该实验教学生理解汇编语言，并迫使他们学习如何使用调试器（debugger）。它也很有趣。这是 CMU 本科生的一个传奇实验。) Tj
T*
() Tj
T*
ET
endstream
endobj
662 0 obj
<< /Length 2826 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(上面的自学讲义中给出了一个 Linux/x86-64 二进制炸弹，你可以自己试试。通知打分服务器的功能已被禁用，所以你可以随意引爆此炸弹而不受惩罚。如果你是一个拥有 CS:APP) Tj
T*
(帐户的讲师，那么你可以下载解答。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(README（讲师版）) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(README（讲师版）) Tj
T*
() Tj
T*
() Tj
T*
(> CS:APP Bomb Lab) Tj
T*
(>) Tj
T*
(> 给讲师的指导) Tj
T*
(>) Tj
T*
(> Copyright \\\(c\\\) 2003-2016, R. Bryant and D. O'Hallaron) Tj
T*
() Tj
T*
(此目录包含你用于构建和运行 CS:APP Bomb Lab 的文件。Bomb Lab 教授学生机器级程序的原理，以及一般的调试器和逆向工程技能。) Tj
T*
() Tj
T*
(1. 概述) Tj
T*
() Tj
T*
() Tj
T*
(1.1 二进制炸弹) Tj
T*
() Tj
T*
() Tj
T*
(一个“二进制炸弹”是由六个 “阶段” 组成的 Linux 可执行 C 程序，每个阶段都要求学生在 stdin 上输入一个特定的字符串。如果学生输入预期的字符串，则该阶段为) Tj
T*
(“拆除”，否则炸弹则打印 “BOOM!!!” 表示“爆炸”。学生们的目标是拆除尽可能多的阶段。) Tj
T*
() Tj
T*
(1.2 解决二进制炸弹) Tj
T*
() Tj
T*
() Tj
T*
(为了拆除炸弹，学生必须使用一个调试器，通常是 gdb 或 ddd，在每个阶段反汇编二进制文件，并对机器码单步调试。想法是让学生理解每个汇编语句的作用，然后使用这些知识来推断要拆除的) Tj
T*
(字符串。学生通过拆除阶段获得分数，每次爆炸都会损失分数（由讲师配置，但通常为 1/2) Tj
T*
(分）。因此，他们将很快学会在每个阶段和引爆炸弹的函数之前设置断点。这是一个很好的教训，迫使他们学会使用调试器。) Tj
T*
() Tj
T*
(1.3 自动评分服务) Tj
T*
() Tj
T*
() Tj
T*
(我们创建了一个独立的用户级自动评分服务，为你处理 Bomb Lab 的所有方面：学生从服务器下载他们的炸弹。当学生们在研究他们的炸弹时，每一次爆炸和拆除都会传回到服务器上，在服务器) Tj
T*
(上，每个炸弹的当前结果都会显示在一个网络“记分板”上。没有明显的提交，实验会自己评分。) Tj
T*
() Tj
T*
(自动评分服务由四个用户级程序组成，这些程序运行在 ./bomblab 主目录中：) Tj
T*
() Tj
T*
(* 请求服务器（bomblab-requestd.pl）。学生下载炸弹并显示记分牌，方法是将浏览器指向一个名为“请求服务器”的简单 HTTP 服务器。请求服务器生成炸弹，将其存档在) Tj
T*
ET
endstream
endobj
663 0 obj
<< /Length 3891 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(tar 文件中，然后将生成的 tar 文件上传回浏览器，在浏览器中可以将其保存在磁盘上并解压。请求服务器还为讲师创建炸弹及其解答的副本。) Tj
T*
(* 结果服务器（bomblab-resultd.pl）。每次学生拆除炸弹阶段或引起爆炸时，炸弹都会向 HTTP “结果服务器”发送一条名为 “自动结果字符串” 的简短 HTTP) Tj
T*
(消息，该服务器只是将自动结果字符串附加到“记分板日志文件”中。) Tj
T*
(* 报告守护进程（bomblab-reportd.pl）。“报告守护进程”定期扫描记分板日志文件。报表守护进程查找每个学生为每个阶段提交的最新的拆除字符串，并将这些字符串应用于学生) Tj
T*
(炸弹的本地副本，来验证这些字符串。然后它会更新 HTML 记分板，该记分板汇总了每枚炸弹的当前爆炸和拆除次数，按累计点数排序。) Tj
T*
(* 主守护进程（bomblab.pl）. “主守护进程”启动并保护请求服务器、结果服务器和报表守护进程，确保这些进程（以及它本身）在任何时间点都在运行。如果其中一个进程由于某种原因) Tj
T*
(死亡，主守护进程会检测到并自动重新启动它。主守护进程是您实际需要运行的唯一程序。) Tj
T*
() Tj
T*
(2. 文件) Tj
T*
() Tj
T*
() Tj
T*
(./bomblab 目录包含下列文件：) Tj
T*
() Tj
T*
(| 文件名 | 说明 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| Makefile | 开始/停止实验和清除文件 |) Tj
T*
(| bomblab.pl\\* | 主守护进程，守护其他服务器和守护进程 |) Tj
T*
(| Bomblab.pm | Bomb Lab 配置文件 |) Tj
T*
(| bomblab-reportd.pl\\* | 报告守护进程，持续更新记分板 |) Tj
T*
(| bomblab-requestd.pl\\* | 请求服务器，将炸弹提供给学生 |) Tj
T*
(| bomblab-resultd.pl\\* | 结果服务器，从炸弹得到自动结果字符串 |) Tj
T*
(| bomblab-scoreboard.html | 实时网络记分板 |) Tj
T*
(| bomblab-update.pl\\* | 帮助 bomblab-reportd.pl 更新记分板 |) Tj
T*
(| bombs/ | 包含发送给每个学生的炸弹 |) Tj
T*
(| log-status.txt | 状态日志，来自不同服务器和守护进程的消息 |) Tj
T*
(| log.txt | 自动结果记分板日志，接受自炸弹 |) Tj
T*
(| makebomb.pl\\* | 帮助脚本，用于制作炸弹 |) Tj
T*
(| scores.txt | 合计每个学生的当前记分板分数 |) Tj
T*
(| src/ | 炸弹源文件 |) Tj
T*
(| writeup/ | Bomb Lab 的 LaTeX 报告样例 |) Tj
T*
() Tj
T*
(3. 炸弹术语) Tj
T*
() Tj
T*
() Tj
T*
(* LabID：该实验的每个实例（用品）都由唯一的名称标识，例如 “f12” 或 “s13”，由讲师选择。和当前 LabID 不同的炸弹的爆炸和拆除动作将被忽略。LabID) Tj
T*
(不能有空格。) Tj
T*
(* BombID：实验给定实例中的每个炸弹都有唯一的非负整数，称为 “bombID”。) Tj
T*
(* 通知炸弹（Notifying Bomb）：一个炸弹可以用一个 NOTIFY 选项编译，当学生每次爆炸或拆除一个阶段时，炸弹都会发送一条消息。这种炸弹被称为“通知炸弹”。) Tj
T*
(* 安静炸弹（Quiet Bomb）：如果使用 NONOTIFY 选项编译，则炸弹在爆炸或拆除时不会发送任何消息。这种炸弹被称为“安静炸弹”。) Tj
T*
() Tj
T*
(我们还会发现区分定制炸弹和普通炸弹很有帮助：) Tj
T*
() Tj
T*
(* 定制炸弹（Custom Bomb）：“定制炸弹”的 BombID &gt; 0，与特定学生关联，可以是通知的或安静的。定制的通知炸弹被限制在讲师确定的一组特定的 Linux) Tj
T*
(主机上运行。另一方面，定制的安静炸弹可以在任何 Linux 主机上运行。) Tj
T*
(* 通用炸弹（Generic Bomb）：一个“通用炸弹”的 BombID = 0，与任何特定的学生没有关联，是安静的，因此可以在任何主机上运行。) Tj
T*
() Tj
T*
ET
endstream
endobj
664 0 obj
<< /Length 2479 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(4. 提供炸弹实验) Tj
T*
() Tj
T*
() Tj
T*
(Bomb Lab 有两种基础版本：在“在线”版本中，讲师使用自动评分服务向每个学生分发定制的通知炸弹，并在实时记分板上自动跟踪他们的进度。在“离线”版本中，讲师手动制作、分发和评分) Tj
T*
(学生炸弹，而不使用自动评分服务。) Tj
T*
() Tj
T*
(虽然这两个版本都给了学生丰富的经验，我们推荐在线版本。对于学生来说，这显然是最吸引人和最有趣的，也是老师最容易评分的。但是，它要求你不停地运行自动评分服务，因为在实验期间，讲义、评) Tj
T*
(分和报告都是连续不断地进行的。我们已经使这项服务非常容易运行，但是一些讲师可能不喜欢这个要求，而是选择离线版本。) Tj
T*
() Tj
T*
(以下是提供两个版本的实验的说明。) Tj
T*
() Tj
T*
(4.1 创建一个 Bomb Lab 目录) Tj
T*
() Tj
T*
() Tj
T*
(确定要创建 Bomb Lab 目录（./bomblab）的通用 Linux) Tj
T*
(机器（$SERVER\\NAME），如果提供联机版本，请运行自动评分服务。你只需在这台机器上有一个用户帐户，不需要 root 权限。 Bomb Lab 的每个实例启动时，都伴随着) Tj
T*
($SERVER\\NAME 上一个全新的 ./bomblab 目录。例如：) Tj
T*
() Tj
T*
(    linux> tar xvf bomblab.tar) Tj
T*
(    linux> cd bomblab) Tj
T*
(    linux> make cleanallfiles) Tj
T*
() Tj
T*
(4.2 配置 Bomb Lab) Tj
T*
() Tj
T*
() Tj
T*
(通过编辑以下文件配置 Bomb Lab：) Tj
T*
() Tj
T*
(* ./Bomblab.pm：这是主配置文件。你只需修改或检查此文件第 1 节的几个变量。每个变量前面都有一个描述性注释。如果提供离线版本，那么可以忽略其中的大多数设置。) Tj
T*
() Tj
T*
(如果你提供在线版本，则还需要编辑以下文件：) Tj
T*
() Tj
T*
(* ./src/config.h：此文件列出了允许运行炸弹的主机的域名。确保你正确地更新了这个，否则你和你的学生将无法运行你的炸弹。) Tj
T*
() Tj
T*
(4.3 更新实验报告) Tj
T*
() Tj
T*
() Tj
T*
(更新完配置文件后，请根据你的环境，修改 writeup/bomblab.tex 中的 LaTeX 报告。然后在 ./writeup 目录中键入以下内容：) Tj
T*
() Tj
T*
(    unix> make clean) Tj
T*
(    unix> make) Tj
T*
() Tj
T*
(这会创建报告的 ps 和 pdf 版本。) Tj
T*
() Tj
T*
(4.4 运行在线 Bomb Lab) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
665 0 obj
<< /Length 2787 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(4.4.1 简短版本) Tj
T*
() Tj
T*
() Tj
T*
(来自 ./bomblab 目录：) Tj
T*
() Tj
T*
(（1）重置 Bomb Lab，键入：) Tj
T*
() Tj
T*
(    linux> make cleanallfiles) Tj
T*
() Tj
T*
(（2）开启自动评分服务，键入：) Tj
T*
() Tj
T*
(    linux> make start) Tj
T*
() Tj
T*
(（3）停止自动评分服务，键入：) Tj
T*
() Tj
T*
(    linux> make stop) Tj
T*
() Tj
T*
(你可以随时开启和停止自动评分服务，这不会丢失任何信息。如果不确定服务状态，输入 “make stop; make start” 可以让一切都进入稳定状态。) Tj
T*
() Tj
T*
(但是，重置实验室删除所有旧的炸弹、状态日志和记分板日志。只有在调试期间，或者第一次为学生开启实验时，才可以这样做。) Tj
T*
() Tj
T*
(学生用浏览器访问如下网址请求炸弹：) Tj
T*
() Tj
T*
(http://$SERVER\\NAME:$REQUESTD\\PORT/) Tj
T*
() Tj
T*
(学生用浏览器访问如下网址查看记分板：) Tj
T*
() Tj
T*
(http://$SERVER\\NAME:$REQUESTD\\PORT/scoreboard) Tj
T*
() Tj
T*
(4.4.2 较长版本) Tj
T*
() Tj
T*
() Tj
T*
(（1）重置 Bomb Lab。“make stop” 确保没有服务器在运行。“make cleanallfiles”) Tj
T*
(重置实验，删除实验中特定实例的所有数据，例如状态日志、请求服务器创建的所有炸弹以及记分板日志。当你准备好将实验“上线”给学生时，就这样做。) Tj
T*
() Tj
T*
(你准备实验的时候，重置也很有用。在实验上线之前，你可能想为自己请求一些炸弹，运行它们，拆除一些，引爆一些，并确保结果在记分板上正确显示。如果出现问题（比如因为你忘记更新) Tj
T*
(src/config.h 中允许运行炸弹的机器列表），你可以修复配置，重置实验，然后请求并运行更多的测试炸弹。) Tj
T*
() Tj
T*
(注意：如果你在开启实验后重新设置，你将丢失所有学生炸弹记录和他们的解答。你不能验证学生提交的内容。你的学生就得获得新的炸弹并重新开始。) Tj
T*
() Tj
T*
(（2）开启 Bomb Lab。“make start” 运行 bomblab.pl，主守护进程启动并监视服务中的其他程序，每隔几秒检查它们的状态，如有必要则重启它们：) Tj
T*
() Tj
T*
(（3）停止 Bomb Lab。“make start” 会关闭所有正在运行的服务器。您可以随时开启和停止自动评分服务，而不会丢失任何信息。如果不确定服务状态，输入 “make) Tj
T*
(stop; make start” 可以让一切都进入稳定状态。) Tj
T*
() Tj
T*
(请求服务器：请求服务器是一个简单的专用HTTP服务器，它（1）根据需要制作并向学生的浏览器提供自定义炸弹，（2）显示实时记分板的当前状态。) Tj
T*
ET
endstream
endobj
666 0 obj
<< /Length 3602 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(学生通过两个步骤从请求守护进程请求炸弹：) Tj
T*
() Tj
T*
(* 首先，学生用他们最喜欢的浏览器访问) Tj
T*
(http://$SERVER\\NAME:$REQUESTD\\PORT/。例如，http://foo.cs.cmu.edu:15213/。请求服务器产生相应，将 HTML) Tj
T*
(表单发送回浏览器。) Tj
T*
(* 接着，学生用他们的用户名和电子邮件地址填写此表单，然后提交表单。请求服务器解析表单，制作一个 bombID = n 的定制的通知炸弹，并将 tar 文件发送到浏览器。然后学生将) Tj
T*
(tar 文件保存到磁盘上。当学生解压此文件时，会创建一个目录（./bomb），其中包含以下四个文件：) Tj
T*
() Tj
T*
(| 文件名 | 说明 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| bomb\\* | 定制的通知炸弹可执行程序 |) Tj
T*
(| bomb.c | 主炸弹程序的源码 |) Tj
T*
(| ID | 标识与该炸弹有关的学生 |) Tj
T*
(| README | 列出炸弹号码、学生和电子邮件地址 |) Tj
T*
(| solution.txt | 该炸弹的解答 |) Tj
T*
() Tj
T*
(结果服务器：每次学生拆除一个阶段或引爆炸弹时，炸弹都会向结果服务器发送一条 HTTP 消息（称为自动结果字符串（autoresult) Tj
T*
(string）），然后结果服务器将消息附加到记分板日志中。每个消息都包含一个) Tj
T*
(BombID、一个阶段和所发生事件的标示。如果是拆除事件，则消息还包含学生键入的“拆除字符串（defusing string）”以消除阶段。) Tj
T*
() Tj
T*
(报告守护进程：报告守护进程定期扫描记分板日志并更新网络记分板。对于每个炸弹，它统计爆炸的次数，最后一个拆除阶段，使用一个安静炸弹的副本验证每个最后拆除的阶段，并在一个标签分隔的文本) Tj
T*
(文件中计算每个学生的分数，该文件名为 “scores. txt” 更新频率适中的配置变量 Bomblab.pm。) Tj
T*
() Tj
T*
(讲师和学生使用浏览器访问以下地址查看记分板：) Tj
T*
() Tj
T*
(http://$SERVER\\NAME:$REQUESTD\\PORT/scoreboard) Tj
T*
() Tj
T*
(4.4.3. 为在线 Bomb Lab 评分) Tj
T*
() Tj
T*
() Tj
T*
(在线的炸弹实验可以自己评分。在任何时间点，制表符分隔的文件（./bomblab/scores.txt\\\)包含每个学生的最新分数。这个文件是由报告守护进程在每次生成新的记分板时创建的) Tj
T*
(。) Tj
T*
() Tj
T*
(4.4.4 在线 Bomb Lab 的补充说明) Tj
T*
() Tj
T*
() Tj
T*
(由于请求服务器和报告守护进程都需要执行炸弹，因此必须在 bomblab/src/config.h 文件的合法计算机列表中包含 $server\\_NAME。) Tj
T*
() Tj
T*
(所有的服务器和守护进程都是无状态（stateless）的，所以您可以随意多次停止（“make stop”）和开启（“make) Tj
T*
(start”）实验，而不会产生任何不良影响。如果您不小心杀死了其中一个守护进程，或者修改了一个守护进程，或者该守护进程由于某种原因死亡，那么请使用 “make stop”) Tj
T*
(进行清理，然后使用 “make start” 重新启动。如果 Linux 机器崩溃或重启，只需使用 “make start” 重新启动守护进程。) Tj
T*
() Tj
T*
(来自服务器的信息和错误消息被添加到“状态日志” bomblab/log-status.txt 中。服务器安静地运行，因此可以在启动时从 init.rc 脚本启动它们。) Tj
T*
() Tj
T*
(请参阅 src/README，了解更多关于炸弹的解剖结构以及它们是如何构造的。你不需要理解这些来提供实验，给出它们只是为了完整。) Tj
T*
ET
endstream
endobj
667 0 obj
<< /Length 2264 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(在将实验“上线”给学生之前，我们喜欢做些测试来检查一切，需键入以下内容：) Tj
T*
() Tj
T*
(    linux> make cleanallfiles) Tj
T*
(    linux> make start) Tj
T*
() Tj
T*
(然后我们用浏览器访问如下地址，为自己请求一个炸弹：) Tj
T*
() Tj
T*
(http://$SERVER\\NAME:$REQUESTD\\PORT) Tj
T*
() Tj
T*
(在保存炸弹到磁盘后，我们将其解压，复制到 src/config.h 里已批准列表中的一台主机上，然后对其进行多次引爆和拆除，以确保爆炸和拆除正确记录在记分板上，可以在这里检查：) Tj
T*
() Tj
T*
(http://$SERVER\\NAME:$REQUESTD\\PORT/scoreboard) Tj
T*
() Tj
T*
(一旦我们确信一切正常，我们就停止实验：) Tj
T*
() Tj
T*
(    linux> make stop) Tj
T*
() Tj
T*
(然后将其上线：) Tj
T*
() Tj
T*
(    linux> make cleanallfiles) Tj
T*
(    linux> make start) Tj
T*
() Tj
T*
(一旦实验上线，我们可根据需要输入 “make stop” 和 “make start”，但要小心绝不能再次输入 “make cleanallfiles”。) Tj
T*
() Tj
T*
(4.5 运行离线 Bomb Lab) Tj
T*
() Tj
T*
() Tj
T*
(在这个版本的实验中，你可以手动制作你自己的安静炸弹，然后把它们分发给学生。学生们在离线状态下（即，独立于任何自动评分服务）拆除炸弹，然后将他们的解答文件交给你，每个文件都由你手动评) Tj
T*
(分。) Tj
T*
() Tj
T*
(你可以使用 makebomb.pl 脚本手动制作自己的炸弹。这个 makebomb.pl 脚本也生成炸弹的解答。键入 “./makebomb.pl -h” 查看其参数。) Tj
T*
() Tj
T*
(选项 1：提供离线炸弹实验室的最简单方法，是制造一个单一的通用炸弹，每个学生都试图将其拆除：) Tj
T*
() Tj
T*
(    linux> ./makebomb.pl -s ./src -b ./bombs) Tj
T*
() Tj
T*
(这会在 ./bombs/bomb0 下面创建一个通用炸弹和其他文件：) Tj
T*
() Tj
T*
(| 文件名 | 说明 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| bomb\\* | 通用炸弹执行程序（分发给学生） |) Tj
T*
(| bomb.c | 主程序的源代码（分发给学生） |) Tj
T*
(| bomb-quiet\\* | 请忽略该文件 |) Tj
T*
(| ID | 请忽略该文件 |) Tj
T*
(| phases.c | 炸弹阶段的 C 代码 |) Tj
T*
ET
endstream
endobj
668 0 obj
<< /Length 2077 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(| README | 请忽略该文件 |) Tj
T*
(| solution.txt | 该炸弹的解答 |) Tj
T*
() Tj
T*
(你只向学生分发其中两个文件：./bomb 和./bomb.c。) Tj
T*
() Tj
T*
(学生提交他们的解答文件，你可以将解答输入给炸弹来验证：) Tj
T*
() Tj
T*
(    linux> cd bombs/bomb0) Tj
T*
(    linux> ./bomb < student_solution.txt) Tj
T*
() Tj
T*
(这个选项对老师来说很容易，但是我们不推荐它，因为它太容易让学生作弊了。) Tj
T*
() Tj
T*
(选项 2。提供离线实验的另一个选项是使用 makebomb.pl 脚本，为每个学生制作一个唯一的定制的安静炸弹：) Tj
T*
() Tj
T*
(    linux> ./makebomb.pl -i <n> -s ./src -b ./bombs -l bomblab -u <email> -v <uid>) Tj
T*
() Tj
T*
(这将为电子邮件地址为 &lt;email&gt; 且用户名为 &lt;uid&gt; 的学生在 ./bombs/bomb 中创建一个定制的安静炸弹：) Tj
T*
() Tj
T*
(| 文件名 | 说明 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| bomb\\* | 定制的炸弹执行程序（分发给学生） |) Tj
T*
(| bomb.c | 主程序的源代码（分发给学生） |) Tj
T*
(| bomb-quiet\\* | 请忽略该文件 |) Tj
T*
(| ID | 标识与该炸弹关联的学生 |) Tj
T*
(| phases.c | 炸弹阶段的 C 代码 |) Tj
T*
(| README | 列出炸弹号码、学生和电子邮件地址 |) Tj
T*
(| solution.txt | 该炸弹的解答 |) Tj
T*
() Tj
T*
(你将向学生分发其中的四个文件：bomb、bomb.c、ID 和 README。) Tj
T*
() Tj
T*
(每个学生都将提交他们的解答文件，你可以针对运行他们的解答运行他们的定制炸弹，来手动验证：) Tj
T*
() Tj
T*
(    linux> cd ./bombs/bomb<n>) Tj
T*
(    linux> ./bomb < student_n_solution.txt) Tj
T*
() Tj
T*
(不同阶段变种的源代码在 ./src/phases/ 中。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(Writeup) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(Writeup) Tj
T*
() Tj
T*
() Tj
T*
(> bomblab.pdf) Tj
T*
ET
endstream
endobj
669 0 obj
<< /Length 2739 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(>) Tj
T*
(> 15-213 Fall 20xx) Tj
T*
(>) Tj
T*
(> Defusing a Binary Bomb) Tj
T*
() Tj
T*
(Harry Bovik \\\(bovik@cs.cmu.edu\\\) 是本作业的负责人。) Tj
T*
() Tj
T*
(1. 介绍) Tj
T*
() Tj
T*
() Tj
T*
(邪恶的邪恶博士在我们的班级机器上放置了大量的“二进制炸弹”。二进制炸弹是由一系列阶段组成的程序。每个阶段都要求你在 stdin) Tj
T*
(上键入一个特定的字符串。如果你输入了正确的字符串，那么这个阶段就被拆除，炸弹进入下一个阶段。否则炸弹会爆炸，并打印出) Tj
T*
(“BOOM!!!”，然后终止。当每一个阶段都被拆除时，炸弹才算拆除。) Tj
T*
() Tj
T*
(有太多炸弹要我们处理，所以我们给每个学生一个炸弹来拆除。这是你的任务，你别无选择，只能接受，就是在截止时间前拆除你的炸弹。祝你好运，欢迎加入拆弹小组！) Tj
T*
() Tj
T*
(步骤 1：获得你的炸弹) Tj
T*
() Tj
T*
() Tj
T*
(你可以用 Web 浏览器访问以下地址获得炸弹：) Tj
T*
() Tj
T*
(http://$Bomblab::SERVER\\NAME:$Bomblab::REQUESTD\\PORT/) Tj
T*
() Tj
T*
(这会显示一个二进制炸弹请求表，让你填写。输入你的用户名和电子邮件地址，然后单击“提交”按钮。服务器将制作你的炸弹，并将其返回给你浏览器一个 tar 文件，名为) Tj
T*
(bombk.tar，其中 k 是你炸弹的唯一编号。) Tj
T*
() Tj
T*
(将 bombk.tar 文件保存到你打算工作的（受保护）目录下。然后给出命令：tar -xvf bombk.tar。这会创建一个名为 ./bombk 的目录，包含以下文件：) Tj
T*
() Tj
T*
(| 文件名 | 描述 |) Tj
T*
(| :--- | :--- |) Tj
T*
(| README | 标识炸弹和拥有者 |) Tj
T*
(| bomb | 可执行二进制炸弹 |) Tj
T*
(| bomb.c | 炸弹主程序的源文件，伴随着邪恶博士的友好问候 |) Tj
T*
(| writeup.{.pdf,ps} | 实验报告 |) Tj
T*
() Tj
T*
(步骤 2：拆除你的炸弹) Tj
T*
() Tj
T*
() Tj
T*
(你在这个实验中的工作就是拆除你的炸弹。) Tj
T*
() Tj
T*
(你必须在其中一台机器上完成作业。事实上，有传言说邪恶博士是真的邪恶，如果在别处运行，炸弹总会爆炸。炸弹里还有其他几种防篡改装置，反正我们是这么听说的。) Tj
T*
() Tj
T*
(你可以用很多工具来帮助你拆除炸弹。请看提示小节的一些提示和想法。最好的方法是使用你最喜欢的调试器来逐步检查反汇编的二进制文件。) Tj
T*
() Tj
T*
(每次你的炸弹爆炸，它都会通知 bomblab 服务器，你在实验的最终分数中会损失 1/2 分（最多 20 分），所以引爆炸弹会有后果。你一定要小心！) Tj
T*
() Tj
T*
ET
endstream
endobj
670 0 obj
<< /Length 3551 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(前四个阶段各有 10 分。第五阶段和第六阶段比较困难，所以他们各有 15 分。所以你能得到的最高分数是 70 分。) Tj
T*
() Tj
T*
(虽然阶段逐渐变得更难拆除，但是你从一个阶段到另一个阶段所获得的专业知识应该可以抵消这个困难。然而，最后一个阶段甚至会难住最好的学生，所以请不要等到最后一刻才开始。) Tj
T*
() Tj
T*
(炸弹会忽略空白输入行。例如，如果你用命令行参数运行炸弹：) Tj
T*
() Tj
T*
(    linux> ./bomb psol.txt) Tj
T*
() Tj
T*
(它从 psol.txt 读入文本行，直至 EOF（文件结束），然后切换到 stdin。由于一时心软，邪恶博士添加了这个功能，这样你就不必再为你已经拆除的阶段重新输入解答了。) Tj
T*
() Tj
T*
(为了避免意外引爆炸弹，你需要学习如何单步执行汇编代码以及如何设置断点。你还需要学习如何检查寄存器和内存状态。做这个实验的一个好的附带效果是，你会很好地使用调试器。这是一项至关重要的) Tj
T*
(技能，它将给你的职业生涯带来丰厚的回报。) Tj
T*
() Tj
T*
(2. 支持) Tj
T*
() Tj
T*
() Tj
T*
(这是一个个人项目。所有提交内容都是电子版。说明和更正将公布在课程网页上。) Tj
T*
() Tj
T*
(3. 提交) Tj
T*
() Tj
T*
() Tj
T*
(该实验没有显式的提交。炸弹会自动通知讲师你工作的进度。你可以通过查看班级记分板来了解自己的表现：) Tj
T*
() Tj
T*
(http://$Bomblab::SERVER\\NAME:$Bomblab::REQUESTD\\PORT/scoreboard) Tj
T*
() Tj
T*
(网页会不断更新，以显示每个炸弹的进度。) Tj
T*
() Tj
T*
(4. 提示（请读这个！）) Tj
T*
() Tj
T*
() Tj
T*
(拆除炸弹的方法有很多种。你可以在不运行程序的情况下对其进行详细的检查，并确切地了解它的功能。这是一种有用的技巧，但并不总是容易做到的。您也可以在调试器下运行它，一步一步地观察它做什) Tj
T*
(么，并使用这些信息来消除它。这可能是最快的化解方法。) Tj
T*
() Tj
T*
(我们只提出一个要求，请不要暴力穷举！你可以编写一个程序，尝试所有可能的密钥来找到正确的。但这并不好，有这几个原因：) Tj
T*
() Tj
T*
(* 每次你猜错了炸弹爆炸，你就会损失 1/2 分（最多20分）。) Tj
T*
(* 每次你猜错了，就会有一条消息发送到 bomblab 服务器。你可能很快就会让网络中充斥着这些消息，导致系统管理员取消你的计算机访问权限。) Tj
T*
(* 我们没有告诉你这些字符串有多长，也没有告诉你其中有哪些字符。即使你做了（不正确的）假设，它们的长度都小于 80) Tj
T*
(个字符，并且只包含字母，那么每个阶段都会有$$26^{80}$$个猜测。这要很长时间才能跑完，作业到期了你都无法得到答案。) Tj
T*
() Tj
T*
(有很多工具都是用来帮助你弄清楚程序是如何工作的，以及当程序不工作时有什么问题。以下是一些工具的清单，你可能会发现有助于分析你的炸弹，并提示如何使用它们。) Tj
T*
() Tj
T*
(* gdb) Tj
T*
() Tj
T*
(  GNU 调试器，这是几乎所有平台上都可用的命令行调试器工具。您可以逐行跟踪程序，检查内存和寄存器，同时查看源代码和汇编代码（我们不会为您提供大多数炸弹的源代码）、设置断点、设置) Tj
T*
(  内存监视点以及编写脚本。) Tj
T*
ET
endstream
endobj
671 0 obj
<< /Length 2488 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
(  CS:APP 网站 http://csapp.cs.cmu.edu/public/students.html) Tj
T*
(  \(http://csapp.cs.cmu.edu/public/students.html\) 有一个非常方便的单页 gdb 总结，可以打印出来用作参考。下面是使用 gdb) Tj
T*
(  的一些其他提示。) Tj
T*
() Tj
T*
(  * 为了防止每次输入错误的输入时炸弹爆炸，你需要学习如何设置断点。) Tj
T*
(  * 对于在线文档，请在 gdb 命令提示符处键入 “help”，或在 Unix 提示符下键入 “man-gdb” 或 “info-gdb”。有些人还喜欢在 emacs 中以) Tj
T*
(  gdb-mode 运行 gdb。) Tj
T*
() Tj
T*
(* objdump -t) Tj
T*
() Tj
T*
(  这会打印出炸弹的符号表。符号表包括炸弹中所有函数和全局变量的名称、炸弹调用的所有函数的名称及其地址。通过查看函数名，你可能会学到一些东西！) Tj
T*
() Tj
T*
(* objdump -d) Tj
T*
() Tj
T*
(  用这个来分解炸弹里的所有代码。你也可以只看单个函数。阅读汇编代码可以告诉你炸弹是如何工作的。) Tj
T*
() Tj
T*
(  虽然 objdump -d 提供了很多信息，但它并不能告诉你整个过程。对系统级函数的调用，是以一种神秘形式显示的。例如，对 sscanf 的调用可能显示为 ：) Tj
T*
() Tj
T*
(      8048c36:   e8 99 fc ff ff   call   80488d4 <_init+0x1a0>) Tj
T*
() Tj
T*
(  要确定调用的是 sscanf，你需要在 gdb 中反汇编。) Tj
T*
() Tj
T*
(* strings) Tj
T*
() Tj
T*
(  这个实用程序会显示炸弹中的可打印字符串。) Tj
T*
() Tj
T*
(在找一个特别的工具？文档怎么样？别忘了，命令 apropos、man 和 info 是你的朋友。尤其是 man ascii 可能会有用。info gas 将告诉你 GNU) Tj
T*
(汇编器的信息，可能比你想知道的都多。此外，网络也可能是信息的宝库。如果你被难住了，放心向你的讲师寻求帮助。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(实验 3：Attack Lab) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(实验 3：Attack Lab) Tj
T*
() Tj
T*
() Tj
T*
(实验附件) Tj
T*
() Tj
T*
() Tj
T*
(* README) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/README-attacklab \(http://csapp.cs.cmu.edu/3e/README-) Tj
T*
(  attacklab\)) Tj
T*
(* Writeup) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/attacklab.pdf \(http://csapp.cs.cmu.edu/3e/attacklab.pdf\)) Tj
T*
ET
endstream
endobj
672 0 obj
<< /Length 2296 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(* 版本历史) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/attacklab-release.html) Tj
T*
(  \(http://csapp.cs.cmu.edu/3e/attacklab-release.html\)) Tj
T*
(* 自学材料) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/target1.tar \(http://csapp.cs.cmu.edu/3e/target1.tar\)) Tj
T*
(* 解答（需使用教师账户登录）) Tj
T*
(  * http://csapp.cs.cmu.edu/im/labs/target1-sol.tar) Tj
T*
(  \(http://csapp.cs.cmu.edu/im/labs/target1-sol.tar\)) Tj
T*
() Tj
T*
(实验简介) Tj
T*
() Tj
T*
() Tj
T*
(> 注：该实验是 32 位 Buffer Lab 的 64 位后继版本。) Tj
T*
() Tj
T*
(给学生一对唯一的自定义生成的 x86-64) Tj
T*
(二进制可执行文件，称为目标（targets），它们包含缓冲区溢出错误。一个目标存在代码注入攻击漏洞。另一个存在面向返回的编程（ROP，return-oriented) Tj
T*
(programming）攻击漏洞。要求学生基于代码注入或 ROP，开发漏洞利用，修改目标的行为。该实验教学生堆栈的规则，以及编写有缓冲区溢出漏洞的代码的危险。) Tj
T*
() Tj
T*
(如果你是自学的学生，自学讲义里有两个 Ubuntu 12.4 目标，你可以自己试试。你需要用 “-q” 选项运行目标，这样它们就不会试图和不存在的打分服务器通信。如果你是一个拥有) Tj
T*
(CS:APP 账号的讲师，那么你可以下载解答。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(实验 4：Architechture Lab) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(实验 4：Architechture Lab) Tj
T*
() Tj
T*
() Tj
T*
(实验附件) Tj
T*
() Tj
T*
() Tj
T*
(* README) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/README-archlab \(http://csapp.cs.cmu.edu/3e/README-archlab\)) Tj
T*
(* Writeup) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/archlab.pdf \(http://csapp.cs.cmu.edu/3e/archlab.pdf\)) Tj
T*
(* 版本历史) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/archlab-release.html \(http://csapp.cs.cmu.edu/3e/archlab-) Tj
T*
(  release.html\)) Tj
T*
(* 自学材料) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/archlab-handout.tar \(http://csapp.cs.cmu.edu/3e/archlab-) Tj
T*
(  handout.tar\)) Tj
T*
() Tj
T*
(实验简介) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
673 0 obj
<< /Length 2146 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(> 注：为 CSAPP 第 3 版更新到 Y86-64。) Tj
T*
() Tj
T*
(给学生一个 Y86-64 默认的小的数组复制函数，和一个工作的流水线化的 Y86-64 处理器设计，该处理器以每个数组元素（CPE）的某些标称（nomial) Tj
T*
(number）时钟周期数运行复制函数。学生试图通过修改函数和处理器设计来最小化 CPE。这让学生对硬件和软件之间的交互有深刻的理解。) Tj
T*
() Tj
T*
(注：实验材料包括 Y86-64 处理器模拟器的主分支源代码和 Y86-64 模拟器指南。) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(实验 5：Cache Lab) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(实验 5：Cache Lab) Tj
T*
() Tj
T*
() Tj
T*
(实验附件) Tj
T*
() Tj
T*
() Tj
T*
(* README) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/README-cachelab \(http://csapp.cs.cmu.edu/3e/README-) Tj
T*
(  cachelab\)) Tj
T*
(* Writeup) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/cachelab.pdf \(http://csapp.cs.cmu.edu/3e/cachelab.pdf\)) Tj
T*
(* 版本历史) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/cachelab-release.html \(http://csapp.cs.cmu.edu/3e/cachelab-) Tj
T*
(  release.html\)) Tj
T*
(* 自学材料) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/cachelab-handout.tar \(http://csapp.cs.cmu.edu/3e/cachelab-) Tj
T*
(  handout.tar\)) Tj
T*
() Tj
T*
(实验简介) Tj
T*
() Tj
T*
() Tj
T*
(CMU 用该实验替代 Performance Lab。学生编写一个通用缓存模拟器，然后优化一个小矩阵转置内核，从而最小化模拟缓存上的未命中次数。这个实验室使用 Valgrind) Tj
T*
(工具来生成地址踪迹（address traces）。) Tj
T*
() Tj
T*
(注意：该实验室必须运行在 64位 x86-64 系统上。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(实验 6：Performance Lab) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(实验 6：Performance Lab) Tj
T*
ET
endstream
endobj
674 0 obj
<< /Length 1729 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
() Tj
T*
() Tj
T*
(实验附件) Tj
T*
() Tj
T*
() Tj
T*
(* README) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/README-perflab \(http://csapp.cs.cmu.edu/3e/README-perflab\)) Tj
T*
(* Writeup) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/perflab.pdf \(http://csapp.cs.cmu.edu/3e/perflab.pdf\)) Tj
T*
(* 版本历史) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/perflab-release.html \(http://csapp.cs.cmu.edu/3e/perflab-) Tj
T*
(  release.html\)) Tj
T*
(* 自学材料) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/perflab-handout.tar \(http://csapp.cs.cmu.edu/3e/perflab-) Tj
T*
(  handout.tar\)) Tj
T*
() Tj
T*
(实验简介) Tj
T*
() Tj
T*
() Tj
T*
(学生优化应用核心函数的性能，比如卷积或矩阵转置。该实验清晰地演示了高速缓存（cache memories）的属性，并让学生积累了优化底层程序的经验。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(实验 7：Shell Lab) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(实验 7：Shell Lab) Tj
T*
() Tj
T*
() Tj
T*
(实验附件) Tj
T*
() Tj
T*
() Tj
T*
(* README) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/README-shlab \(http://csapp.cs.cmu.edu/3e/README-shlab\)) Tj
T*
(* Writeup) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/shlab.pdf \(http://csapp.cs.cmu.edu/3e/shlab.pdf\)) Tj
T*
(* 版本历史) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/shlab-release.html \(http://csapp.cs.cmu.edu/3e/shlab-) Tj
T*
(  release.html\)) Tj
T*
(* 自学材料) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/shlab-handout.tar \(http://csapp.cs.cmu.edu/3e/shlab-) Tj
T*
(  handout.tar\)) Tj
T*
() Tj
T*
(实验简介) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
675 0 obj
<< /Length 1919 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(学生通过作业控制（job control）实现他们自己的简单的 Unix shell 程序，包括 ctrl-c 和 ctrl-z 击键、fg、bg 和 jobs) Tj
T*
(命令。这是第一次向学生介绍应用级并发（application level concurrency），并让他们清楚地了解 Unix 的进程控制、信号和信号处理。) Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(实验 8：Malloc Lab) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(实验 8：Malloc Lab) Tj
T*
() Tj
T*
() Tj
T*
(实验附件) Tj
T*
() Tj
T*
() Tj
T*
(* README) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/README-malloclab \(http://csapp.cs.cmu.edu/3e/README-) Tj
T*
(  malloclab\)) Tj
T*
(* Writeup) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/malloclab.pdf \(http://csapp.cs.cmu.edu/3e/malloclab.pdf\)) Tj
T*
(* 版本历史) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/malloclab-release.html) Tj
T*
(  \(http://csapp.cs.cmu.edu/3e/malloclab-release.html\)) Tj
T*
(* 自学材料) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/malloclab-handout.tar) Tj
T*
(  \(http://csapp.cs.cmu.edu/3e/malloclab-handout.tar\)) Tj
T*
() Tj
T*
(实验简介) Tj
T*
() Tj
T*
() Tj
T*
(学生实现他们自己版本的 malloc、free 和) Tj
T*
(realloc。该实验让学生对数据布局和组织有一个清晰的理解，并要求他们评估空间和时间效率之间的不同权衡。我们最喜欢的实验之一。学生完成它后，将真正理解指针！) Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
() Tj
T*
(================================================================================) Tj
T*
(实验 9：Proxy Lab) Tj
T*
(================================================================================) Tj
T*
() Tj
T*
(实验 9：Proxy Lab) Tj
T*
() Tj
T*
() Tj
T*
(实验附件) Tj
T*
() Tj
T*
() Tj
T*
(* README) Tj
T*
ET
endstream
endobj
676 0 obj
<< /Length 995 >>
stream
BT
/F1 12 Tf
14 TL
72 720 Td
(  * http://csapp.cs.cmu.edu/3e/README-proxylab \(http://csapp.cs.cmu.edu/3e/README-) Tj
T*
(  proxylab\)) Tj
T*
(* Writeup) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/proxylab.pdf \(http://csapp.cs.cmu.edu/3e/proxylab.pdf\)) Tj
T*
(* 版本历史) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/proxylab-release.html \(http://csapp.cs.cmu.edu/3e/proxylab-) Tj
T*
(  release.html\)) Tj
T*
(* 自学材料) Tj
T*
(  * http://csapp.cs.cmu.edu/3e/proxylab-handout.tar \(http://csapp.cs.cmu.edu/3e/proxylab-) Tj
T*
(  handout.tar\)) Tj
T*
() Tj
T*
(实验简介) Tj
T*
() Tj
T*
() Tj
T*
(学生实现一个并发缓存（concurrent caching）的 Web) Tj
T*
(代理，该代理位于学生的浏览器和其他万维网之间。该实验让学生接触到有趣的网络编程世界，并将课程中的许多概念联系在一起，例如字节序（byte) Tj
T*
(ordering）、缓存、进程控制、信号、信号处理、文件 I/O、并发和同步。) Tj
T*
() Tj
T*
() Tj
T*
ET
endstream
endobj
677 0 obj
<< /Type /Font /Subtype /Type1 /BaseFont /Helvetica >>
endobj
xref
0 678
0000000000 65535 f 
0000000009 00000 n 
0000000058 00000 n 
0000002703 00000 n 
0000002833 00000 n 
0000002963 00000 n 
0000003093 00000 n 
0000003223 00000 n 
0000003353 00000 n 
0000003483 00000 n 
0000003613 00000 n 
0000003744 00000 n 
0000003875 00000 n 
0000004006 00000 n 
0000004137 00000 n 
0000004268 00000 n 
0000004399 00000 n 
0000004530 00000 n 
0000004661 00000 n 
0000004792 00000 n 
0000004923 00000 n 
0000005054 00000 n 
0000005185 00000 n 
0000005316 00000 n 
0000005447 00000 n 
0000005578 00000 n 
0000005709 00000 n 
0000005840 00000 n 
0000005971 00000 n 
0000006102 00000 n 
0000006233 00000 n 
0000006364 00000 n 
0000006495 00000 n 
0000006626 00000 n 
0000006757 00000 n 
0000006888 00000 n 
0000007019 00000 n 
0000007150 00000 n 
0000007281 00000 n 
0000007412 00000 n 
0000007543 00000 n 
0000007674 00000 n 
0000007805 00000 n 
0000007936 00000 n 
0000008067 00000 n 
0000008198 00000 n 
0000008329 00000 n 
0000008460 00000 n 
0000008591 00000 n 
0000008722 00000 n 
0000008853 00000 n 
0000008984 00000 n 
0000009115 00000 n 
0000009246 00000 n 
0000009377 00000 n 
0000009508 00000 n 
0000009639 00000 n 
0000009770 00000 n 
0000009901 00000 n 
0000010032 00000 n 
0000010163 00000 n 
0000010294 00000 n 
0000010425 00000 n 
0000010556 00000 n 
0000010687 00000 n 
0000010818 00000 n 
0000010949 00000 n 
0000011080 00000 n 
0000011211 00000 n 
0000011342 00000 n 
0000011473 00000 n 
0000011604 00000 n 
0000011735 00000 n 
0000011866 00000 n 
0000011997 00000 n 
0000012128 00000 n 
0000012259 00000 n 
0000012390 00000 n 
0000012521 00000 n 
0000012652 00000 n 
0000012783 00000 n 
0000012914 00000 n 
0000013045 00000 n 
0000013176 00000 n 
0000013307 00000 n 
0000013438 00000 n 
0000013569 00000 n 
0000013700 00000 n 
0000013831 00000 n 
0000013962 00000 n 
0000014093 00000 n 
0000014224 00000 n 
0000014355 00000 n 
0000014486 00000 n 
0000014617 00000 n 
0000014748 00000 n 
0000014879 00000 n 
0000015010 00000 n 
0000015141 00000 n 
0000015272 00000 n 
0000015403 00000 n 
0000015535 00000 n 
0000015667 00000 n 
0000015799 00000 n 
0000015931 00000 n 
0000016063 00000 n 
0000016195 00000 n 
0000016327 00000 n 
0000016459 00000 n 
0000016591 00000 n 
0000016723 00000 n 
0000016855 00000 n 
0000016987 00000 n 
0000017119 00000 n 
0000017251 00000 n 
0000017383 00000 n 
0000017515 00000 n 
0000017647 00000 n 
0000017779 00000 n 
0000017911 00000 n 
0000018043 00000 n 
0000018175 00000 n 
0000018307 00000 n 
0000018439 00000 n 
0000018571 00000 n 
0000018703 00000 n 
0000018835 00000 n 
0000018967 00000 n 
0000019099 00000 n 
0000019231 00000 n 
0000019363 00000 n 
0000019495 00000 n 
0000019627 00000 n 
0000019759 00000 n 
0000019891 00000 n 
0000020023 00000 n 
0000020155 00000 n 
0000020287 00000 n 
0000020419 00000 n 
0000020551 00000 n 
0000020683 00000 n 
0000020815 00000 n 
0000020947 00000 n 
0000021079 00000 n 
0000021211 00000 n 
0000021343 00000 n 
0000021475 00000 n 
0000021607 00000 n 
0000021739 00000 n 
0000021871 00000 n 
0000022003 00000 n 
0000022135 00000 n 
0000022267 00000 n 
0000022399 00000 n 
0000022531 00000 n 
0000022663 00000 n 
0000022795 00000 n 
0000022927 00000 n 
0000023059 00000 n 
0000023191 00000 n 
0000023323 00000 n 
0000023455 00000 n 
0000023587 00000 n 
0000023719 00000 n 
0000023851 00000 n 
0000023983 00000 n 
0000024115 00000 n 
0000024247 00000 n 
0000024379 00000 n 
0000024511 00000 n 
0000024643 00000 n 
0000024775 00000 n 
0000024907 00000 n 
0000025039 00000 n 
0000025171 00000 n 
0000025303 00000 n 
0000025435 00000 n 
0000025567 00000 n 
0000025699 00000 n 
0000025831 00000 n 
0000025963 00000 n 
0000026095 00000 n 
0000026227 00000 n 
0000026359 00000 n 
0000026491 00000 n 
0000026623 00000 n 
0000026755 00000 n 
0000026887 00000 n 
0000027019 00000 n 
0000027151 00000 n 
0000027283 00000 n 
0000027415 00000 n 
0000027547 00000 n 
0000027679 00000 n 
0000027811 00000 n 
0000027943 00000 n 
0000028075 00000 n 
0000028207 00000 n 
0000028339 00000 n 
0000028471 00000 n 
0000028603 00000 n 
0000028735 00000 n 
0000028867 00000 n 
0000028999 00000 n 
0000029131 00000 n 
0000029263 00000 n 
0000029395 00000 n 
0000029527 00000 n 
0000029659 00000 n 
0000029791 00000 n 
0000029923 00000 n 
0000030055 00000 n 
0000030187 00000 n 
0000030319 00000 n 
0000030451 00000 n 
0000030583 00000 n 
0000030715 00000 n 
0000030847 00000 n 
0000030979 00000 n 
0000031111 00000 n 
0000031243 00000 n 
0000031375 00000 n 
0000031507 00000 n 
0000031639 00000 n 
0000031771 00000 n 
0000031903 00000 n 
0000032035 00000 n 
0000032167 00000 n 
0000032299 00000 n 
0000032431 00000 n 
0000032563 00000 n 
0000032695 00000 n 
0000032827 00000 n 
0000032959 00000 n 
0000033091 00000 n 
0000033223 00000 n 
0000033355 00000 n 
0000033487 00000 n 
0000033619 00000 n 
0000033751 00000 n 
0000033883 00000 n 
0000034015 00000 n 
0000034147 00000 n 
0000034279 00000 n 
0000034411 00000 n 
0000034543 00000 n 
0000034675 00000 n 
0000034807 00000 n 
0000034939 00000 n 
0000035071 00000 n 
0000035203 00000 n 
0000035335 00000 n 
0000035467 00000 n 
0000035599 00000 n 
0000035731 00000 n 
0000035863 00000 n 
0000035995 00000 n 
0000036127 00000 n 
0000036259 00000 n 
0000036391 00000 n 
0000036523 00000 n 
0000036655 00000 n 
0000036787 00000 n 
0000036919 00000 n 
0000037051 00000 n 
0000037183 00000 n 
0000037315 00000 n 
0000037447 00000 n 
0000037579 00000 n 
0000037711 00000 n 
0000037843 00000 n 
0000037975 00000 n 
0000038107 00000 n 
0000038239 00000 n 
0000038371 00000 n 
0000038503 00000 n 
0000038635 00000 n 
0000038767 00000 n 
0000038899 00000 n 
0000039031 00000 n 
0000039163 00000 n 
0000039295 00000 n 
0000039427 00000 n 
0000039559 00000 n 
0000039691 00000 n 
0000039823 00000 n 
0000039955 00000 n 
0000040087 00000 n 
0000040219 00000 n 
0000040351 00000 n 
0000040483 00000 n 
0000040615 00000 n 
0000040747 00000 n 
0000040879 00000 n 
0000041011 00000 n 
0000041143 00000 n 
0000041275 00000 n 
0000041407 00000 n 
0000041539 00000 n 
0000041671 00000 n 
0000041803 00000 n 
0000041935 00000 n 
0000042067 00000 n 
0000042199 00000 n 
0000042331 00000 n 
0000042463 00000 n 
0000042595 00000 n 
0000042727 00000 n 
0000042859 00000 n 
0000042991 00000 n 
0000043123 00000 n 
0000043255 00000 n 
0000043387 00000 n 
0000043519 00000 n 
0000043651 00000 n 
0000043783 00000 n 
0000043915 00000 n 
0000044047 00000 n 
0000044179 00000 n 
0000044311 00000 n 
0000044443 00000 n 
0000044575 00000 n 
0000044707 00000 n 
0000044839 00000 n 
0000044971 00000 n 
0000045103 00000 n 
0000045235 00000 n 
0000045367 00000 n 
0000045499 00000 n 
0000045631 00000 n 
0000045763 00000 n 
0000045895 00000 n 
0000046027 00000 n 
0000046159 00000 n 
0000046291 00000 n 
0000046423 00000 n 
0000046555 00000 n 
0000046687 00000 n 
0000046819 00000 n 
0000046951 00000 n 
0000047083 00000 n 
0000049304 00000 n 
0000053442 00000 n 
0000060411 00000 n 
0000066891 00000 n 
0000071054 00000 n 
0000076034 00000 n 
0000083387 00000 n 
0000090748 00000 n 
0000096474 00000 n 
0000102334 00000 n 
0000106627 00000 n 
0000111755 00000 n 
0000115743 00000 n 
0000120134 00000 n 
0000125041 00000 n 
0000129029 00000 n 
0000134017 00000 n 
0000137980 00000 n 
0000142741 00000 n 
0000147555 00000 n 
0000152238 00000 n 
0000157686 00000 n 
0000161717 00000 n 
0000165879 00000 n 
0000169662 00000 n 
0000172877 00000 n 
0000178331 00000 n 
0000182596 00000 n 
0000187562 00000 n 
0000192705 00000 n 
0000197550 00000 n 
0000199252 00000 n 
0000200717 00000 n 
0000207878 00000 n 
0000213132 00000 n 
0000217866 00000 n 
0000224181 00000 n 
0000226741 00000 n 
0000230462 00000 n 
0000233027 00000 n 
0000236117 00000 n 
0000239492 00000 n 
0000243998 00000 n 
0000248437 00000 n 
0000250518 00000 n 
0000254818 00000 n 
0000257944 00000 n 
0000261277 00000 n 
0000265029 00000 n 
0000267765 00000 n 
0000272150 00000 n 
0000276913 00000 n 
0000280206 00000 n 
0000283415 00000 n 
0000285815 00000 n 
0000289066 00000 n 
0000290455 00000 n 
0000291977 00000 n 
0000295108 00000 n 
0000296143 00000 n 
0000300180 00000 n 
0000302766 00000 n 
0000305250 00000 n 
0000309654 00000 n 
0000313311 00000 n 
0000316762 00000 n 
0000319237 00000 n 
0000321579 00000 n 
0000323736 00000 n 
0000326459 00000 n 
0000329345 00000 n 
0000334230 00000 n 
0000338768 00000 n 
0000342274 00000 n 
0000344340 00000 n 
0000348694 00000 n 
0000353662 00000 n 
0000356456 00000 n 
0000358111 00000 n 
0000359766 00000 n 
0000362159 00000 n 
0000363936 00000 n 
0000367710 00000 n 
0000369893 00000 n 
0000371848 00000 n 
0000373505 00000 n 
0000375420 00000 n 
0000380653 00000 n 
0000385003 00000 n 
0000388830 00000 n 
0000393434 00000 n 
0000396744 00000 n 
0000400002 00000 n 
0000404653 00000 n 
0000407472 00000 n 
0000412908 00000 n 
0000416486 00000 n 
0000418958 00000 n 
0000422045 00000 n 
0000426664 00000 n 
0000428674 00000 n 
0000432307 00000 n 
0000435150 00000 n 
0000437178 00000 n 
0000440268 00000 n 
0000441938 00000 n 
0000443900 00000 n 
0000446813 00000 n 
0000449323 00000 n 
0000451345 00000 n 
0000453630 00000 n 
0000455838 00000 n 
0000460025 00000 n 
0000463477 00000 n 
0000465635 00000 n 
0000468339 00000 n 
0000471210 00000 n 
0000474346 00000 n 
0000476527 00000 n 
0000479101 00000 n 
0000482404 00000 n 
0000484770 00000 n 
0000488905 00000 n 
0000491873 00000 n 
0000494902 00000 n 
0000496480 00000 n 
0000499231 00000 n 
0000502224 00000 n 
0000505515 00000 n 
0000508253 00000 n 
0000510329 00000 n 
0000512838 00000 n 
0000515074 00000 n 
0000517545 00000 n 
0000519535 00000 n 
0000522103 00000 n 
0000524880 00000 n 
0000528005 00000 n 
0000529249 00000 n 
0000530400 00000 n 
0000531512 00000 n 
0000532856 00000 n 
0000534432 00000 n 
0000536630 00000 n 
0000539615 00000 n 
0000541368 00000 n 
0000546160 00000 n 
0000549619 00000 n 
0000552437 00000 n 
0000557202 00000 n 
0000560010 00000 n 
0000564397 00000 n 
0000569493 00000 n 
0000572985 00000 n 
0000575399 00000 n 
0000578641 00000 n 
0000582289 00000 n 
0000586495 00000 n 
0000590659 00000 n 
0000592918 00000 n 
0000595277 00000 n 
0000599770 00000 n 
0000604387 00000 n 
0000609115 00000 n 
0000614500 00000 n 
0000618214 00000 n 
0000620306 00000 n 
0000624037 00000 n 
0000627345 00000 n 
0000630607 00000 n 
0000634309 00000 n 
0000638627 00000 n 
0000642758 00000 n 
0000646757 00000 n 
0000651352 00000 n 
0000655542 00000 n 
0000658328 00000 n 
0000661770 00000 n 
0000665030 00000 n 
0000668048 00000 n 
0000670534 00000 n 
0000673049 00000 n 
0000675243 00000 n 
0000678884 00000 n 
0000684007 00000 n 
0000686786 00000 n 
0000691812 00000 n 
0000694433 00000 n 
0000698943 00000 n 
0000701587 00000 n 
0000704332 00000 n 
0000707092 00000 n 
0000709432 00000 n 
0000714400 00000 n 
0000715522 00000 n 
0000716651 00000 n 
0000718586 00000 n 
0000721411 00000 n 
0000726427 00000 n 
0000730339 00000 n 
0000732575 00000 n 
0000734645 00000 n 
0000736951 00000 n 
0000741159 00000 n 
0000743588 00000 n 
0000746522 00000 n 
0000749095 00000 n 
0000751342 00000 n 
0000753999 00000 n 
0000756375 00000 n 
0000758474 00000 n 
0000761111 00000 n 
0000763582 00000 n 
0000765555 00000 n 
0000767933 00000 n 
0000770617 00000 n 
0000775251 00000 n 
0000777820 00000 n 
0000779842 00000 n 
0000783639 00000 n 
0000788698 00000 n 
0000793088 00000 n 
0000797152 00000 n 
0000800149 00000 n 
0000802081 00000 n 
0000804137 00000 n 
0000807234 00000 n 
0000810505 00000 n 
0000814112 00000 n 
0000817285 00000 n 
0000819816 00000 n 
0000822735 00000 n 
0000825963 00000 n 
0000830502 00000 n 
0000833690 00000 n 
0000836044 00000 n 
0000838360 00000 n 
0000840612 00000 n 
0000843494 00000 n 
0000845880 00000 n 
0000848376 00000 n 
0000851417 00000 n 
0000855120 00000 n 
0000858386 00000 n 
0000861906 00000 n 
0000865785 00000 n 
0000868610 00000 n 
0000870939 00000 n 
0000873491 00000 n 
0000876468 00000 n 
0000878365 00000 n 
0000881479 00000 n 
0000883830 00000 n 
0000886295 00000 n 
0000888723 00000 n 
0000892189 00000 n 
0000896552 00000 n 
0000898878 00000 n 
0000902932 00000 n 
0000907009 00000 n 
0000909013 00000 n 
0000912801 00000 n 
0000916563 00000 n 
0000918716 00000 n 
0000923594 00000 n 
0000925998 00000 n 
0000928712 00000 n 
0000931286 00000 n 
0000935900 00000 n 
0000939550 00000 n 
0000942121 00000 n 
0000945264 00000 n 
0000947282 00000 n 
0000950197 00000 n 
0000952758 00000 n 
0000956875 00000 n 
0000959471 00000 n 
0000961262 00000 n 
0000964347 00000 n 
0000966510 00000 n 
0000969965 00000 n 
0000973133 00000 n 
0000976305 00000 n 
0000980504 00000 n 
0000983422 00000 n 
0000987291 00000 n 
0000989194 00000 n 
0000993042 00000 n 
0000995684 00000 n 
0000998722 00000 n 
0001002145 00000 n 
0001004927 00000 n 
0001007827 00000 n 
0001011297 00000 n 
0001014510 00000 n 
0001018001 00000 n 
0001022353 00000 n 
0001025841 00000 n 
0001028546 00000 n 
0001030715 00000 n 
0001034175 00000 n 
0001036295 00000 n 
0001040428 00000 n 
0001042189 00000 n 
0001044467 00000 n 
0001046524 00000 n 
0001048585 00000 n 
0001051394 00000 n 
0001053855 00000 n 
0001055130 00000 n 
0001057092 00000 n 
0001059398 00000 n 
0001062852 00000 n 
0001065378 00000 n 
0001067780 00000 n 
0001069991 00000 n 
0001072076 00000 n 
0001073820 00000 n 
0001077462 00000 n 
0001080116 00000 n 
0001082511 00000 n 
0001084950 00000 n 
0001087830 00000 n 
0001091775 00000 n 
0001094308 00000 n 
0001097149 00000 n 
0001100805 00000 n 
0001103123 00000 n 
0001105254 00000 n 
0001108047 00000 n 
0001111652 00000 n 
0001114194 00000 n 
0001116544 00000 n 
0001118744 00000 n 
0001120527 00000 n 
0001122500 00000 n 
0001123548 00000 n 
trailer
<< /Size 678 /Root 1 0 R >>
startxref
1123620
%%EOF
